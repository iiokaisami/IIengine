### ðŸŒ³ Codebase File Tree (Excluding ignored directories)

â””â”€â”€ project/
    â”œâ”€â”€ MyGame.vcxproj
    â”œâ”€â”€ MyGame.vcxproj.filters
    â”œâ”€â”€ application/
    â””â”€â”€ â”œâ”€â”€ BaseObject/
    â””â”€â”€ â””â”€â”€ â”œâ”€â”€ GameObject.cpp
    â””â”€â”€ â””â”€â”€ â””â”€â”€ GameObject.h
    â””â”€â”€ â”œâ”€â”€ Objects/
    â””â”€â”€ â””â”€â”€ â”œâ”€â”€ Enemy/
    â””â”€â”€ â””â”€â”€ â””â”€â”€ â”œâ”€â”€ BehaviorState/
    â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€ TrapEnemyState/
    â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€     â”œâ”€â”€ TrapEnemyBehaviorDead.cpp
    â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€     â”œâ”€â”€ TrapEnemyBehaviorDead.h
    â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€     â”œâ”€â”€ TrapEnemyBehaviorHitReact.cpp
    â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€     â”œâ”€â”€ TrapEnemyBehaviorHitReact.h
    â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€     â”œâ”€â”€ TrapEnemyBehaviorMove.cpp
    â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€     â”œâ”€â”€ TrapEnemyBehaviorMove.h
    â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€     â”œâ”€â”€ TrapEnemyBehaviorSetTrap.cpp
    â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€     â”œâ”€â”€ TrapEnemyBehaviorSetTrap.h
    â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€     â”œâ”€â”€ TrapEnemyBehaviorSpawn.cpp
    â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€     â”œâ”€â”€ TrapEnemyBehaviorSpawn.h
    â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€     â”œâ”€â”€ TrapEnemyBehaviorState.cpp
    â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€     â””â”€â”€ TrapEnemyBehaviorState.h
    â””â”€â”€ â””â”€â”€ â””â”€â”€ â”œâ”€â”€ Bullet/
    â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€ â”œâ”€â”€ EnemyBullet.cpp
    â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€ â”œâ”€â”€ EnemyBullet.h
    â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€ â”œâ”€â”€ TimeBomb.cpp
    â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€ â”œâ”€â”€ TimeBomb.h
    â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€ â”œâ”€â”€ VignetteTrap.cpp
    â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€ VignetteTrap.h
    â””â”€â”€ â””â”€â”€ â””â”€â”€ â”œâ”€â”€ EnemyManager.cpp
    â””â”€â”€ â””â”€â”€ â””â”€â”€ â”œâ”€â”€ EnemyManager.h
    â””â”€â”€ â””â”€â”€ â””â”€â”€ â”œâ”€â”€ NormalEnemy.cpp
    â””â”€â”€ â””â”€â”€ â””â”€â”€ â”œâ”€â”€ NormalEnemy.h
    â””â”€â”€ â””â”€â”€ â””â”€â”€ â”œâ”€â”€ TrapEnemy.cpp
    â””â”€â”€ â””â”€â”€ â””â”€â”€ â”œâ”€â”€ TrapEnemy.h
    â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€ WaveState/
    â””â”€â”€ â””â”€â”€ â””â”€â”€     â”œâ”€â”€ EnemyWaveStage1.cpp
    â””â”€â”€ â””â”€â”€ â””â”€â”€     â”œâ”€â”€ EnemyWaveStage1.h
    â””â”€â”€ â””â”€â”€ â””â”€â”€     â”œâ”€â”€ EnemyWaveStage2.cpp
    â””â”€â”€ â””â”€â”€ â””â”€â”€     â”œâ”€â”€ EnemyWaveStage2.h
    â””â”€â”€ â””â”€â”€ â””â”€â”€     â”œâ”€â”€ EnemyWaveState.cpp
    â””â”€â”€ â””â”€â”€ â””â”€â”€     â””â”€â”€ EnemyWaveState.h
    â””â”€â”€ â””â”€â”€ â”œâ”€â”€ Field/
    â””â”€â”€ â””â”€â”€ â””â”€â”€ â”œâ”€â”€ Barrie.cpp
    â””â”€â”€ â””â”€â”€ â””â”€â”€ â”œâ”€â”€ Barrie.h
    â””â”€â”€ â””â”€â”€ â””â”€â”€ â”œâ”€â”€ Field.cpp
    â””â”€â”€ â””â”€â”€ â””â”€â”€ â”œâ”€â”€ Field.h
    â””â”€â”€ â””â”€â”€ â””â”€â”€ â”œâ”€â”€ Goal.cpp
    â””â”€â”€ â””â”€â”€ â””â”€â”€ â”œâ”€â”€ Goal.h
    â””â”€â”€ â””â”€â”€ â””â”€â”€ â”œâ”€â”€ Wall.cpp
    â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€ Wall.h
    â””â”€â”€ â””â”€â”€ â””â”€â”€ Player/
    â””â”€â”€ â””â”€â”€     â”œâ”€â”€ Bullet/
    â””â”€â”€ â””â”€â”€     â””â”€â”€ â”œâ”€â”€ PlayerBullet.cpp
    â””â”€â”€ â””â”€â”€     â””â”€â”€ â””â”€â”€ PlayerBullet.h
    â””â”€â”€ â””â”€â”€     â”œâ”€â”€ Player.cpp
    â””â”€â”€ â””â”€â”€     â””â”€â”€ Player.h
    â””â”€â”€ â”œâ”€â”€ objects/
    â””â”€â”€ â””â”€â”€ â””â”€â”€ enemy/
    â””â”€â”€ â””â”€â”€     â”œâ”€â”€ Corruptor.cpp
    â””â”€â”€ â””â”€â”€     â”œâ”€â”€ Corruptor.h
    â””â”€â”€ â””â”€â”€     â”œâ”€â”€ EnemyManager.cpp
    â””â”€â”€ â””â”€â”€     â”œâ”€â”€ EnemyManager.h
    â””â”€â”€ â””â”€â”€     â””â”€â”€ behaviorState/
    â””â”€â”€ â””â”€â”€         â”œâ”€â”€ corruptorState/
    â””â”€â”€ â””â”€â”€         â””â”€â”€ â”œâ”€â”€ CorruptorBehaviorMove.cpp
    â””â”€â”€ â””â”€â”€         â””â”€â”€ â”œâ”€â”€ CorruptorBehaviorMove.h
    â””â”€â”€ â””â”€â”€         â””â”€â”€ â”œâ”€â”€ CorruptorBehaviorSelfDestruct.cpp
    â””â”€â”€ â””â”€â”€         â””â”€â”€ â”œâ”€â”€ CorruptorBehaviorSelfDestruct.h
    â””â”€â”€ â””â”€â”€         â””â”€â”€ â”œâ”€â”€ CorruptorBehaviorSpawn.cpp
    â””â”€â”€ â””â”€â”€         â””â”€â”€ â”œâ”€â”€ CorruptorBehaviorSpawn.h
    â””â”€â”€ â””â”€â”€         â””â”€â”€ â”œâ”€â”€ CorruptorBehaviorState.cpp
    â””â”€â”€ â””â”€â”€         â””â”€â”€ â””â”€â”€ CorruptorBehaviorState.h
    â””â”€â”€ â””â”€â”€         â”œâ”€â”€ normalEnemyState/
    â””â”€â”€ â””â”€â”€         â””â”€â”€ â”œâ”€â”€ EnemyBehaviorAttack.cpp
    â””â”€â”€ â””â”€â”€         â””â”€â”€ â”œâ”€â”€ EnemyBehaviorAttack.h
    â””â”€â”€ â””â”€â”€         â””â”€â”€ â”œâ”€â”€ EnemyBehaviorDead.cpp
    â””â”€â”€ â””â”€â”€         â””â”€â”€ â”œâ”€â”€ EnemyBehaviorDead.h
    â””â”€â”€ â””â”€â”€         â””â”€â”€ â”œâ”€â”€ EnemyBehaviorHitReact.cpp
    â””â”€â”€ â””â”€â”€         â””â”€â”€ â”œâ”€â”€ EnemyBehaviorHitReact.h
    â””â”€â”€ â””â”€â”€         â””â”€â”€ â”œâ”€â”€ EnemyBehaviorMove.cpp
    â””â”€â”€ â””â”€â”€         â””â”€â”€ â”œâ”€â”€ EnemyBehaviorMove.h
    â””â”€â”€ â””â”€â”€         â””â”€â”€ â”œâ”€â”€ EnemyBehaviorSpawn.cpp
    â””â”€â”€ â””â”€â”€         â””â”€â”€ â”œâ”€â”€ EnemyBehaviorSpawn.h
    â””â”€â”€ â””â”€â”€         â””â”€â”€ â”œâ”€â”€ EnemyBehaviorState.cpp
    â””â”€â”€ â””â”€â”€         â””â”€â”€ â””â”€â”€ EnemyBehaviorState.h
    â””â”€â”€ â””â”€â”€         â””â”€â”€ trapEnemyState/
    â””â”€â”€ â””â”€â”€             â”œâ”€â”€ TrapEnemyBehaviorDead.cpp
    â””â”€â”€ â””â”€â”€             â”œâ”€â”€ TrapEnemyBehaviorSpawn.cpp
    â””â”€â”€ â””â”€â”€             â””â”€â”€ TrapEnemyBehaviorState.h
    â””â”€â”€ â””â”€â”€ scene/
    â””â”€â”€     â”œâ”€â”€ ClearScene.cpp
    â””â”€â”€     â”œâ”€â”€ ClearScene.h
    â””â”€â”€     â”œâ”€â”€ GameOverScene.cpp
    â””â”€â”€     â”œâ”€â”€ GameOverScene.h
    â””â”€â”€     â”œâ”€â”€ GamePlayScene.cpp
    â””â”€â”€     â”œâ”€â”€ GamePlayScene.h
    â””â”€â”€     â”œâ”€â”€ SceneFactory.cpp
    â””â”€â”€     â”œâ”€â”€ SceneFactory.h
    â””â”€â”€     â”œâ”€â”€ TitleScene.cpp
    â””â”€â”€     â””â”€â”€ TitleScene.h
    â”œâ”€â”€ gameEngine/
    â””â”€â”€ â”œâ”€â”€ 2d/
    â””â”€â”€ â””â”€â”€ â”œâ”€â”€ Sprite.cpp
    â””â”€â”€ â””â”€â”€ â”œâ”€â”€ Sprite.h
    â””â”€â”€ â””â”€â”€ â”œâ”€â”€ SpriteCommon.cpp
    â””â”€â”€ â””â”€â”€ â””â”€â”€ SpriteCommon.h
    â””â”€â”€ â”œâ”€â”€ 3d/
    â””â”€â”€ â””â”€â”€ â”œâ”€â”€ Camera.cpp
    â””â”€â”€ â””â”€â”€ â”œâ”€â”€ Camera.h
    â””â”€â”€ â””â”€â”€ â”œâ”€â”€ CameraManager.cpp
    â””â”€â”€ â””â”€â”€ â”œâ”€â”€ CameraManager.h
    â””â”€â”€ â””â”€â”€ â”œâ”€â”€ Model.cpp
    â””â”€â”€ â””â”€â”€ â”œâ”€â”€ Model.h
    â””â”€â”€ â””â”€â”€ â”œâ”€â”€ ModelCommon.cpp
    â””â”€â”€ â””â”€â”€ â”œâ”€â”€ ModelCommon.h
    â””â”€â”€ â””â”€â”€ â”œâ”€â”€ ModelManager.cpp
    â””â”€â”€ â””â”€â”€ â”œâ”€â”€ ModelManager.h
    â””â”€â”€ â””â”€â”€ â”œâ”€â”€ Object3d.cpp
    â””â”€â”€ â””â”€â”€ â”œâ”€â”€ Object3d.h
    â””â”€â”€ â””â”€â”€ â”œâ”€â”€ Object3dCommon.cpp
    â””â”€â”€ â””â”€â”€ â””â”€â”€ Object3dCommon.h
    â””â”€â”€ â”œâ”€â”€ Collider/
    â””â”€â”€ â””â”€â”€ â”œâ”€â”€ Collider.cpp
    â””â”€â”€ â””â”€â”€ â”œâ”€â”€ Collider.h
    â””â”€â”€ â””â”€â”€ â”œâ”€â”€ ColliderManager.cpp
    â””â”€â”€ â””â”€â”€ â”œâ”€â”€ ColliderManager.h
    â””â”€â”€ â””â”€â”€ â””â”€â”€ Shape.h
    â””â”€â”€ â”œâ”€â”€ audio/
    â””â”€â”€ â””â”€â”€ â”œâ”€â”€ Audio.cpp
    â””â”€â”€ â””â”€â”€ â””â”€â”€ Audio.h
    â””â”€â”€ â”œâ”€â”€ base/
    â””â”€â”€ â””â”€â”€ â”œâ”€â”€ D3DResourceLeakChecker.cpp
    â””â”€â”€ â””â”€â”€ â”œâ”€â”€ D3DResourceLeakChecker.h
    â””â”€â”€ â””â”€â”€ â”œâ”€â”€ DirectXCommon.cpp
    â””â”€â”€ â””â”€â”€ â”œâ”€â”€ DirectXCommon.h
    â””â”€â”€ â””â”€â”€ â”œâ”€â”€ Framework.cpp
    â””â”€â”€ â””â”€â”€ â”œâ”€â”€ Framework.h
    â””â”€â”€ â””â”€â”€ â”œâ”€â”€ RenderTexture.cpp
    â””â”€â”€ â””â”€â”€ â”œâ”€â”€ RenderTexture.h
    â””â”€â”€ â””â”€â”€ â”œâ”€â”€ SrvManager.cpp
    â””â”€â”€ â””â”€â”€ â”œâ”€â”€ SrvManager.h
    â””â”€â”€ â””â”€â”€ â”œâ”€â”€ TextureManager.cpp
    â””â”€â”€ â””â”€â”€ â”œâ”€â”€ TextureManager.h
    â””â”€â”€ â””â”€â”€ â”œâ”€â”€ WinApp.cpp
    â””â”€â”€ â””â”€â”€ â”œâ”€â”€ WinApp.h
    â””â”€â”€ â””â”€â”€ â””â”€â”€ postEffect/
    â””â”€â”€ â””â”€â”€     â”œâ”€â”€ BasePostEffectPass.cpp
    â””â”€â”€ â””â”€â”€     â”œâ”€â”€ BasePostEffectPass.h
    â””â”€â”€ â””â”€â”€     â”œâ”€â”€ BoxFilterPass.cpp
    â””â”€â”€ â””â”€â”€     â”œâ”€â”€ BoxFilterPass.h
    â””â”€â”€ â””â”€â”€     â”œâ”€â”€ GaussianFilterPass.cpp
    â””â”€â”€ â””â”€â”€     â”œâ”€â”€ GaussianFilterPass.h
    â””â”€â”€ â””â”€â”€     â”œâ”€â”€ GrayscalePass.cpp
    â””â”€â”€ â””â”€â”€     â”œâ”€â”€ GrayscalePass.h
    â””â”€â”€ â””â”€â”€     â”œâ”€â”€ IPostEffectPass.cpp
    â””â”€â”€ â””â”€â”€     â”œâ”€â”€ IPostEffectPass.h
    â””â”€â”€ â””â”€â”€     â”œâ”€â”€ NoneEffectPass.cpp
    â””â”€â”€ â””â”€â”€     â”œâ”€â”€ NoneEffectPass.h
    â””â”€â”€ â””â”€â”€     â”œâ”€â”€ PostEffectManager.cpp
    â””â”€â”€ â””â”€â”€     â”œâ”€â”€ PostEffectManager.h
    â””â”€â”€ â””â”€â”€     â”œâ”€â”€ VignettePass.cpp
    â””â”€â”€ â””â”€â”€     â””â”€â”€ VignettePass.h
    â””â”€â”€ â”œâ”€â”€ baseScene/
    â””â”€â”€ â””â”€â”€ â”œâ”€â”€ AbstractSceneFactory.h
    â””â”€â”€ â””â”€â”€ â”œâ”€â”€ BaseScene.cpp
    â””â”€â”€ â””â”€â”€ â”œâ”€â”€ BaseScene.h
    â””â”€â”€ â””â”€â”€ â”œâ”€â”€ MyGame.cpp
    â””â”€â”€ â””â”€â”€ â”œâ”€â”€ MyGame.h
    â””â”€â”€ â””â”€â”€ â”œâ”€â”€ SceneManager.cpp
    â””â”€â”€ â””â”€â”€ â””â”€â”€ SceneManager.h
    â””â”€â”€ â”œâ”€â”€ imgui/
    â””â”€â”€ â””â”€â”€ â”œâ”€â”€ ImGuiManager.cpp
    â””â”€â”€ â””â”€â”€ â””â”€â”€ ImGuiManager.h
    â””â”€â”€ â”œâ”€â”€ io/
    â””â”€â”€ â””â”€â”€ â”œâ”€â”€ Input.cpp
    â””â”€â”€ â””â”€â”€ â””â”€â”€ Input.h
    â””â”€â”€ â”œâ”€â”€ level_editor/
    â””â”€â”€ â””â”€â”€ â”œâ”€â”€ LevelDataLoader.cpp
    â””â”€â”€ â””â”€â”€ â”œâ”€â”€ LevelDataLoader.h
    â””â”€â”€ â””â”€â”€ â””â”€â”€ level_editor/
    â””â”€â”€ â””â”€â”€     â”œâ”€â”€ enemy/
    â””â”€â”€ â””â”€â”€     â”œâ”€â”€ player/
    â””â”€â”€ â”œâ”€â”€ math/
    â””â”€â”€ â””â”€â”€ â”œâ”€â”€ Ease.h
    â””â”€â”€ â””â”€â”€ â”œâ”€â”€ Matrix4x4.cpp
    â””â”€â”€ â””â”€â”€ â”œâ”€â”€ Matrix4x4.h
    â””â”€â”€ â””â”€â”€ â”œâ”€â”€ MyMath.cpp
    â””â”€â”€ â””â”€â”€ â”œâ”€â”€ MyMath.h
    â””â”€â”€ â””â”€â”€ â”œâ”€â”€ Quaternion.cpp
    â””â”€â”€ â””â”€â”€ â”œâ”€â”€ Quaternion.h
    â””â”€â”€ â””â”€â”€ â”œâ”€â”€ Vector2.cpp
    â””â”€â”€ â””â”€â”€ â”œâ”€â”€ Vector2.h
    â””â”€â”€ â””â”€â”€ â”œâ”€â”€ Vector3.cpp
    â””â”€â”€ â””â”€â”€ â””â”€â”€ Vector3.h
    â””â”€â”€ â”œâ”€â”€ particle/
    â””â”€â”€ â””â”€â”€ â”œâ”€â”€ MeshBuilder.cpp
    â””â”€â”€ â””â”€â”€ â”œâ”€â”€ MeshBuilder.h
    â””â”€â”€ â””â”€â”€ â”œâ”€â”€ Particle.cpp
    â””â”€â”€ â””â”€â”€ â”œâ”€â”€ Particle.h
    â””â”€â”€ â””â”€â”€ â”œâ”€â”€ ParticleEmitter.cpp
    â””â”€â”€ â””â”€â”€ â”œâ”€â”€ ParticleEmitter.h
    â””â”€â”€ â””â”€â”€ â”œâ”€â”€ ParticleManager.cpp
    â””â”€â”€ â””â”€â”€ â”œâ”€â”€ ParticleManager.h
    â””â”€â”€ â””â”€â”€ â”œâ”€â”€ ParticleMotion.cpp
    â””â”€â”€ â””â”€â”€ â””â”€â”€ ParticleMotion.h
    â””â”€â”€ â”œâ”€â”€ skybox/
    â””â”€â”€ â””â”€â”€ â”œâ”€â”€ Skybox.cpp
    â””â”€â”€ â””â”€â”€ â””â”€â”€ Skybox.h
    â””â”€â”€ â”œâ”€â”€ time/
    â””â”€â”€ â””â”€â”€ â”œâ”€â”€ TimeManager.cpp
    â””â”€â”€ â””â”€â”€ â””â”€â”€ TimeManager.h
    â””â”€â”€ â”œâ”€â”€ transition/
    â””â”€â”€ â””â”€â”€ â”œâ”€â”€ BaseTransition.cpp
    â””â”€â”€ â””â”€â”€ â”œâ”€â”€ BaseTransition.h
    â””â”€â”€ â””â”€â”€ â”œâ”€â”€ BlockRiseTransition.cpp
    â””â”€â”€ â””â”€â”€ â”œâ”€â”€ BlockRiseTransition.h
    â””â”€â”€ â””â”€â”€ â”œâ”€â”€ FadeTransition.cpp
    â””â”€â”€ â””â”€â”€ â”œâ”€â”€ FadeTransition.h
    â””â”€â”€ â””â”€â”€ â”œâ”€â”€ TransitionManager.cpp
    â””â”€â”€ â””â”€â”€ â””â”€â”€ TransitionManager.h
    â””â”€â”€ â””â”€â”€ utillity/
    â””â”€â”€     â”œâ”€â”€ Logger.cpp
    â””â”€â”€     â”œâ”€â”€ Logger.h
    â””â”€â”€     â”œâ”€â”€ StringUtility.cpp
    â””â”€â”€     â””â”€â”€ StringUtility.h
    â””â”€â”€ main.cpp
================================================================================


============================================================
File Path: project/MyGame.vcxproj
============================================================
ï»¿<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>17.0</VCProjectVersion>
    <Keyword>Win32Proj</Keyword>
    <ProjectGuid>{b6dbb98e-3268-4b15-9ba5-8be74293ec79}</ProjectGuid>
    <RootNamespace>MyGame</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <OutDir>$(SolutionDir)..\generated\outputs\$(Configuration)\</OutDir>
    <IntDir>$(SolutionDir)..\generated\obj\$(ProjectName)\$(Configuration)\</IntDir>
    <IncludePath>$(SolutionDir)externals\imgui;$(IncludePath)</IncludePath>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <OutDir>$(SolutionDir)..\generated\outputs\$(Configuration)\</OutDir>
    <IntDir>$(SolutionDir)..\generated\obj\$(ProjectName)\$(Configuration)\</IntDir>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <WarningLevel>Level4</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_DEBUG;_CONSOLE;USE_IMGUI;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <LanguageStandard>stdcpp20</LanguageStandard>
      <AdditionalOptions>/utf-8 %(AdditionalOptions)</AdditionalOptions>
      <MultiProcessorCompilation>true</MultiProcessorCompilation>
      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
      <AdditionalIncludeDirectories>$(ProjectDir)gameEngine\2d;$(ProjectDir)gameEngine\3d;$(ProjectDir)gameEngine\audio;$(ProjectDir)gameEngine\base;$(ProjectDir)gameEngine\io;$(ProjectDir)gameEngine\math;$(ProjectDir)gameEngine\utillity;$(ProjectDir)externals\assimp\include;$(ProjectDir)externals\imgui;$(ProjectDir)gameEngine\time;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <TreatWarningAsError>true</TreatWarningAsError>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <AdditionalLibraryDirectories>$(ProjectDir)externals\assimp\lib\Debug;%(AdditionalLibraryDirectories);$(SolutionDir)..\generated\outputs\$(Configuration)\</AdditionalLibraryDirectories>
      <AdditionalDependencies>assimp-vc143-mtd.lib;imgui.lib;%(AdditionalDependencies)</AdditionalDependencies>
    </Link>
    <PostBuildEvent>
      <Command>copy "$(WindowsSdkDir)bin\$(TargetPlatformVersion)\x64\dxcompiler.dll" "$(TargetDir)dxcompiler.dll"
copy "$(WindowsSdkDir)bin\$(TargetPlatformVersion)\x64\dxil.dll" "$(TargetDir)dxil.dll"
</Command>
    </PostBuildEvent>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level4</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <LanguageStandard>stdcpp20</LanguageStandard>
      <AdditionalOptions>/utf-8 %(AdditionalOptions)</AdditionalOptions>
      <MultiProcessorCompilation>true</MultiProcessorCompilation>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
      <TreatWarningAsError>true</TreatWarningAsError>
      <AdditionalIncludeDirectories>$(ProjectDir)gameEngine\2d;$(ProjectDir)gameEngine\3d;$(ProjectDir)gameEngine\audio;$(ProjectDir)gameEngine\base;$(ProjectDir)gameEngine\io;$(ProjectDir)gameEngine\math;$(ProjectDir)gameEngine\utillity;$(ProjectDir)externals\assimp\include;$(ProjectDir)externals\imgui;$(ProjectDir)gameEngine\time;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <Optimization>MinSpace</Optimization>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <TreatLinkerWarningAsErrors>true</TreatLinkerWarningAsErrors>
      <AdditionalLibraryDirectories>$(ProjectDir)externals\assimp\lib\Release;%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
      <AdditionalDependencies>assimp-vc143-mt.lib;%(AdditionalDependencies)</AdditionalDependencies>
    </Link>
    <PostBuildEvent>
      <Command>copy "$(WindowsSdkDir)bin\$(TargetPlatformVersion)\x64\dxcompiler.dll" "$(TargetDir)dxcompiler.dll"
copy "$(WindowsSdkDir)bin\$(TargetPlatformVersion)\x64\dxil.dll" "$(TargetDir)dxil.dll"
</Command>
    </PostBuildEvent>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="application\BaseObject\GameObject.cpp" />
    <ClCompile Include="application\Objects\Enemy\NormalEnemy.cpp" />
    <ClCompile Include="application\Objects\Field\Field.cpp" />
    <ClCompile Include="application\Objects\Enemy\Bullet\EnemyBullet.cpp" />
    <ClCompile Include="application\Objects\Field\Barrie.cpp" />
    <ClCompile Include="application\objects\enemy\Corruptor.cpp" />
    <ClCompile Include="application\objects\enemy\behaviorState\corruptorState\CorruptorBehaviorMove.cpp" />
    <ClCompile Include="application\objects\enemy\behaviorState\corruptorState\CorruptorBehaviorSelfDestruct.cpp" />
    <ClCompile Include="application\objects\enemy\behaviorState\corruptorState\CorruptorBehaviorSpawn.cpp" />
    <ClCompile Include="application\objects\enemy\behaviorState\corruptorState\CorruptorBehaviorState.cpp" />
    <ClCompile Include="gameEngine\transition\BaseTransition.cpp" />
    <ClCompile Include="gameEngine\transition\BlockRiseTransition.cpp" />
    <ClCompile Include="gameEngine\transition\FadeTransition.cpp" />
    <ClCompile Include="gameEngine\Collider\Collider.cpp" />
    <ClCompile Include="gameEngine\Collider\ColliderManager.cpp" />
    <ClCompile Include="application\Objects\Enemy\EnemyManager.cpp" />
    <ClCompile Include="application\Objects\Enemy\WaveState\EnemyWaveState.cpp" />
    <ClCompile Include="application\Objects\Enemy\WaveState\EnemyWaveStage1.cpp" />
    <ClCompile Include="application\Objects\Enemy\WaveState\EnemyWaveStage2.cpp" />
    <ClCompile Include="application\objects\enemy\behaviorState\normalEnemyState\EnemyBehaviorAttack.cpp" />
    <ClCompile Include="application\objects\enemy\behaviorState\normalEnemyState\EnemyBehaviorDead.cpp" />
    <ClCompile Include="application\objects\enemy\behaviorState\normalEnemyState\EnemyBehaviorHitReact.cpp" />
    <ClCompile Include="application\objects\enemy\behaviorState\normalEnemyState\EnemyBehaviorMove.cpp" />
    <ClCompile Include="application\objects\enemy\behaviorState\normalEnemyState\EnemyBehaviorSpawn.cpp" />
    <ClCompile Include="application\objects\enemy\behaviorState\normalEnemyState\EnemyBehaviorState.cpp" />
    <ClCompile Include="application\Objects\Player\Bullet\PlayerBullet.cpp" />
    <ClCompile Include="application\Objects\Player\Player.cpp" />
    <ClCompile Include="application\Objects\Field\Goal.cpp" />
    <ClCompile Include="application\scene\ClearScene.cpp" />
    <ClCompile Include="gameEngine\base\postEffect\BoxFilterPass.cpp" />
    <ClCompile Include="gameEngine\base\postEffect\BasePostEffectPass.cpp" />
    <ClCompile Include="gameEngine\audio\Audio.cpp" />
    <ClCompile Include="gameEngine\math\Quaternion.cpp" />
    <ClCompile Include="application\scene\GameOverScene.cpp" />
    <ClCompile Include="gameEngine\base\RenderTexture.cpp" />
    <ClCompile Include="gameEngine\base\postEffect\IPostEffectPass.cpp" />
    <ClCompile Include="gameEngine\base\postEffect\GrayscalePass.cpp" />
    <ClCompile Include="gameEngine\base\postEffect\PostEffectManager.cpp" />
    <ClCompile Include="gameEngine\base\postEffect\GaussianFilterPass.cpp" />
    <ClCompile Include="gameEngine\base\postEffect\NoneEffectPass.cpp" />
    <ClCompile Include="gameEngine\particle\MeshBuilder.cpp" />
    <ClCompile Include="gameEngine\particle\ParticleMotion.cpp" />
    <ClCompile Include="gameEngine\level_editor\LevelDataLoader.cpp" />
    <ClCompile Include="application\scene\SceneFactory.cpp" />
    <ClCompile Include="gameEngine\baseScene\SceneManager.cpp" />
    <ClCompile Include="gameEngine\baseScene\BaseScene.cpp" />
    <ClCompile Include="gameEngine\base\Framework.cpp" />
    <ClCompile Include="gameEngine\3d\CameraManager.cpp" />
    <ClCompile Include="gameEngine\3d\Camera.cpp" />
    <ClCompile Include="gameEngine\base\D3DResourceLeakChecker.cpp" />
    <ClCompile Include="gameEngine\base\DirectXCommon.cpp" />
    <ClCompile Include="gameEngine\io\Input.cpp" />
    <ClCompile Include="gameEngine\utillity\Logger.cpp" />
    <ClCompile Include="application\scene\GamePlayScene.cpp" />
    <ClCompile Include="gameEngine\imgui\ImGuiManager.cpp" />
    <ClCompile Include="main.cpp" />
    <ClCompile Include="gameEngine\3d\Model.cpp" />
    <ClCompile Include="gameEngine\3d\ModelCommon.cpp" />
    <ClCompile Include="gameEngine\3d\ModelManager.cpp" />
    <ClCompile Include="gameEngine\math\MyMath.cpp" />
    <ClCompile Include="gameEngine\3d\Object3d.cpp" />
    <ClCompile Include="gameEngine\3d\Object3dCommon.cpp" />
    <ClCompile Include="gameEngine\2d\Sprite.cpp" />
    <ClCompile Include="gameEngine\2d\SpriteCommon.cpp" />
    <ClCompile Include="gameEngine\utillity\StringUtility.cpp" />
    <ClCompile Include="gameEngine\base\TextureManager.cpp" />
    <ClCompile Include="gameEngine\base\WinApp.cpp" />
    <ClCompile Include="gameEngine\math\Vector2.cpp" />
    <ClCompile Include="gameEngine\math\Matrix4x4.cpp" />
    <ClCompile Include="gameEngine\math\Vector3.cpp" />
    <ClCompile Include="gameEngine\base\SrvManager.cpp" />
    <ClCompile Include="gameEngine\baseScene\MyGame.cpp" />
    <ClCompile Include="gameEngine\particle\Particle.cpp" />
    <ClCompile Include="gameEngine\particle\ParticleEmitter.cpp" />
    <ClCompile Include="gameEngine\particle\ParticleManager.cpp" />
    <ClCompile Include="application\scene\TitleScene.cpp" />
    <ClCompile Include="gameEngine\base\postEffect\VignettePass.cpp" />
    <ClCompile Include="gameEngine\skybox\Skybox.cpp" />
    <ClCompile Include="application\Objects\Field\Wall.cpp" />
    <ClCompile Include="application\Objects\Enemy\TrapEnemy.cpp" />
    <ClCompile Include="application\Objects\Enemy\Bullet\TimeBomb.cpp" />
    <ClCompile Include="application\Objects\Enemy\Bullet\VignetteTrap.cpp" />
    <ClCompile Include="application\Objects\Enemy\BehaviorState\TrapEnemyState\TrapEnemyBehaviorState.cpp" />
    <ClCompile Include="application\Objects\Enemy\BehaviorState\TrapEnemyState\TrapEnemyBehaviorSpawn.cpp" />
    <ClCompile Include="application\Objects\Enemy\BehaviorState\TrapEnemyState\TrapEnemyBehaviorDead.cpp" />
    <ClCompile Include="application\Objects\Enemy\BehaviorState\TrapEnemyState\TrapEnemyBehaviorHitReact.cpp" />
    <ClCompile Include="application\Objects\Enemy\BehaviorState\TrapEnemyState\TrapEnemyBehaviorMove.cpp" />
    <ClCompile Include="application\Objects\Enemy\BehaviorState\TrapEnemyState\TrapEnemyBehaviorSetTrap.cpp" />
    <ClCompile Include="gameEngine\transition\TransitionManager.cpp" />
    <ClCompile Include="gameEngine\time\TimeManager.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="application\BaseObject\GameObject.h" />
    <ClInclude Include="application\Collider\Shape.h" />
    <ClInclude Include="application\Objects\Enemy\NormalEnemy.h" />
    <ClInclude Include="application\Objects\Field\Field.h" />
    <ClInclude Include="application\Objects\Enemy\Bullet\EnemyBullet.h" />
    <ClInclude Include="application\Objects\Field\Barrie.h" />
    <ClInclude Include="application\objects\enemy\Corruptor.h" />
    <ClInclude Include="application\objects\enemy\behaviorState\corruptorState\CorruptorBehaviorMove.h" />
    <ClInclude Include="application\objects\enemy\behaviorState\corruptorState\CorruptorBehaviorSelfDestruct.h" />
    <ClInclude Include="application\objects\enemy\behaviorState\corruptorState\CorruptorBehaviorSpawn.h" />
    <ClInclude Include="application\objects\enemy\behaviorState\corruptorState\CorruptorBehaviorState.h" />
    <ClInclude Include="gameEngine\transition\BaseTransition.h" />
    <ClInclude Include="gameEngine\transition\BlockRiseTransition.h" />
    <ClInclude Include="gameEngine\transition\FadeTransition.h" />
    <ClInclude Include="gameEngine\Collider\Collider.h" />
    <ClInclude Include="gameEngine\Collider\ColliderManager.h" />
    <ClInclude Include="application\Objects\Enemy\EnemyManager.h" />
    <ClInclude Include="application\Objects\Enemy\WaveState\EnemyWaveState.h" />
    <ClInclude Include="application\Objects\Enemy\WaveState\EnemyWaveStage1.h" />
    <ClInclude Include="application\Objects\Enemy\WaveState\EnemyWaveStage2.h" />
    <ClInclude Include="application\objects\enemy\behaviorState\normalEnemyState\EnemyBehaviorAttack.h" />
    <ClInclude Include="application\objects\enemy\behaviorState\normalEnemyState\EnemyBehaviorDead.h" />
    <ClInclude Include="application\objects\enemy\behaviorState\normalEnemyState\EnemyBehaviorHitReact.h" />
    <ClInclude Include="application\objects\enemy\behaviorState\normalEnemyState\EnemyBehaviorMove.h" />
    <ClInclude Include="application\objects\enemy\behaviorState\normalEnemyState\EnemyBehaviorSpawn.h" />
    <ClInclude Include="application\objects\enemy\behaviorState\normalEnemyState\EnemyBehaviorState.h" />
    <ClInclude Include="application\Objects\Player\Bullet\PlayerBullet.h" />
    <ClInclude Include="application\Objects\Player\Player.h" />
    <ClInclude Include="gameEngine\math\Ease.h" />
    <ClInclude Include="application\Objects\Field\Goal.h" />
    <ClInclude Include="application\scene\ClearScene.h" />
    <ClInclude Include="gameEngine\base\postEffect\BoxFilterPass.h" />
    <ClInclude Include="gameEngine\base\postEffect\BasePostEffectPass.h" />
    <ClInclude Include="gameEngine\audio\Audio.h" />
    <ClInclude Include="gameEngine\math\Quaternion.h" />
    <ClInclude Include="gameEngine\level_editor\LevelDataLoader.h" />
    <ClInclude Include="application\scene\GameOverScene.h" />
    <ClInclude Include="gameEngine\base\RenderTexture.h" />
    <ClInclude Include="gameEngine\base\postEffect\IPostEffectPass.h" />
    <ClInclude Include="gameEngine\base\postEffect\GrayscalePass.h" />
    <ClInclude Include="gameEngine\base\postEffect\PostEffectManager.h" />
    <ClInclude Include="gameEngine\base\postEffect\GaussianFilterPass.h" />
    <ClInclude Include="gameEngine\base\postEffect\NoneEffectPass.h" />
    <ClInclude Include="gameEngine\particle\MeshBuilder.h" />
    <ClInclude Include="gameEngine\particle\ParticleMotion.h" />
    <ClInclude Include="application\scene\SceneFactory.h" />
    <ClInclude Include="gameEngine\baseScene\AbstractSceneFactory.h" />
    <ClInclude Include="gameEngine\baseScene\SceneManager.h" />
    <ClInclude Include="gameEngine\baseScene\BaseScene.h" />
    <ClInclude Include="gameEngine\base\Framework.h" />
    <ClInclude Include="gameEngine\3d\CameraManager.h" />
    <ClInclude Include="gameEngine\3d\Camera.h" />
    <ClInclude Include="gameEngine\base\D3DResourceLeakChecker.h" />
    <ClInclude Include="gameEngine\base\DirectXCommon.h" />
    <ClInclude Include="gameEngine\io\Input.h" />
    <ClInclude Include="gameEngine\utillity\Logger.h" />
    <ClInclude Include="gameEngine\3d\Model.h" />
    <ClInclude Include="gameEngine\3d\ModelCommon.h" />
    <ClInclude Include="gameEngine\3d\ModelManager.h" />
    <ClInclude Include="gameEngine\math\MyMath.h" />
    <ClInclude Include="gameEngine\3d\Object3d.h" />
    <ClInclude Include="gameEngine\3d\Object3dCommon.h" />
    <ClInclude Include="gameEngine\2d\Sprite.h" />
    <ClInclude Include="gameEngine\2d\SpriteCommon.h" />
    <ClInclude Include="gameEngine\utillity\StringUtility.h" />
    <ClInclude Include="gameEngine\base\TextureManager.h" />
    <ClInclude Include="gameEngine\base\WinApp.h" />
    <ClInclude Include="gameEngine\math\Vector2.h" />
    <ClInclude Include="gameEngine\math\Matrix4x4.h" />
    <ClInclude Include="gameEngine\math\Vector3.h" />
    <ClInclude Include="gameEngine\base\SrvManager.h" />
    <ClInclude Include="application\scene\GamePlayScene.h" />
    <ClInclude Include="gameEngine\imgui\ImGuiManager.h" />
    <ClInclude Include="gameEngine\baseScene\MyGame.h" />
    <ClInclude Include="gameEngine\particle\Particle.h" />
    <ClInclude Include="gameEngine\particle\ParticleEmitter.h" />
    <ClInclude Include="gameEngine\particle\ParticleManager.h" />
    <ClInclude Include="application\scene\TitleScene.h" />
    <ClInclude Include="gameEngine\Collider\Shape.h" />
    <ClInclude Include="application\Objects\Field\Wall.h" />
    <ClInclude Include="gameEngine\base\postEffect\VignettePass.h" />
    <ClInclude Include="gameEngine\skybox\Skybox.h" />
    <ClInclude Include="application\Objects\Enemy\TrapEnemy.h" />
    <ClInclude Include="application\Objects\Enemy\Bullet\TimeBomb.h" />
    <ClInclude Include="application\Objects\Enemy\Bullet\VignetteTrap.h" />
    <ClInclude Include="application\Objects\Enemy\BehaviorState\TrapEnemyState\TrapEnemyBehaviorState.h" />
    <ClInclude Include="application\Objects\Enemy\BehaviorState\TrapEnemyState\TrapEnemyBehaviorSpawn.h" />
    <ClInclude Include="application\Objects\Enemy\BehaviorState\TrapEnemyState\TrapEnemyBehaviorDead.h" />
    <ClInclude Include="application\Objects\Enemy\BehaviorState\TrapEnemyState\TrapEnemyBehaviorHitReact.h" />
    <ClInclude Include="application\Objects\Enemy\BehaviorState\TrapEnemyState\TrapEnemyBehaviorMove.h" />
    <ClInclude Include="application\Objects\Enemy\BehaviorState\TrapEnemyState\TrapEnemyBehaviorSetTrap.h" />
    <ClInclude Include="gameEngine\transition\TransitionManager.h" />
    <ClInclude Include="gameEngine\time\TimeManager.h" />
  </ItemGroup>
  <ItemGroup>
    <ProjectReference Include="externals\DirectXTex\DirectXTex_Desktop_2022_Win10.vcxproj">
      <Project>{371b9fa9-4c90-4ac6-a123-aced756d6c77}</Project>
    </ProjectReference>
  </ItemGroup>
  <ItemGroup>
    <None Include="resources\shaders\BoxFilter.hlsli" />
    <None Include="resources\shaders\GaussianFilter.hlsli" />
    <None Include="resources\shaders\Grayscale.hlsli" />
    <None Include="resources\shaders\NoneEffect.hlsli" />
    <None Include="resources\shaders\Object3d.hlsli" />
    <None Include="resources\shaders\Particle.hlsli" />
    <None Include="resources\shaders\Skybox.hlsli" />
    <None Include="resources\shaders\Sprite.hlsli" />
    <None Include="resources\shaders\Vignette.hlsli" />
  </ItemGroup>
  <ItemGroup>
    <FxCompile Include="resources\shaders\BoxFilter.PS.hlsl">
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">true</ExcludedFromBuild>
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release|x64'">true</ExcludedFromBuild>
    </FxCompile>
    <FxCompile Include="resources\shaders\BoxFilter.VS.hlsl">
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release|x64'">true</ExcludedFromBuild>
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">true</ExcludedFromBuild>
    </FxCompile>
    <FxCompile Include="resources\shaders\GaussianFilter.PS.hlsl">
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">true</ExcludedFromBuild>
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release|x64'">true</ExcludedFromBuild>
    </FxCompile>
    <FxCompile Include="resources\shaders\GaussianFilter.VS.hlsl">
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release|x64'">true</ExcludedFromBuild>
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">true</ExcludedFromBuild>
    </FxCompile>
    <FxCompile Include="resources\shaders\Grayscale.PS.hlsl">
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release|x64'">true</ExcludedFromBuild>
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">true</ExcludedFromBuild>
    </FxCompile>
    <FxCompile Include="resources\shaders\Grayscale.VS.hlsl">
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release|x64'">true</ExcludedFromBuild>
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">true</ExcludedFromBuild>
    </FxCompile>
    <FxCompile Include="resources\shaders\NoneEffect.PS.hlsl">
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">true</ExcludedFromBuild>
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release|x64'">true</ExcludedFromBuild>
    </FxCompile>
    <FxCompile Include="resources\shaders\NoneEffect.VS.hlsl">
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release|x64'">true</ExcludedFromBuild>
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">true</ExcludedFromBuild>
    </FxCompile>
    <FxCompile Include="resources\shaders\Object3d.PS.hlsl">
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">true</ExcludedFromBuild>
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release|x64'">true</ExcludedFromBuild>
    </FxCompile>
    <FxCompile Include="resources\shaders\Object3d.VS.hlsl">
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">true</ExcludedFromBuild>
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release|x64'">true</ExcludedFromBuild>
    </FxCompile>
    <FxCompile Include="resources\shaders\Particle.PS.hlsl">
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">true</ExcludedFromBuild>
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release|x64'">true</ExcludedFromBuild>
    </FxCompile>
    <FxCompile Include="resources\shaders\Particle.VS.hlsl">
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">true</ExcludedFromBuild>
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release|x64'">true</ExcludedFromBuild>
    </FxCompile>
    <FxCompile Include="resources\shaders\Skybox.PS.hlsl">
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release|x64'">true</ExcludedFromBuild>
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">true</ExcludedFromBuild>
    </FxCompile>
    <FxCompile Include="resources\shaders\Skybox.VS.hlsl">
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">true</ExcludedFromBuild>
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release|x64'">true</ExcludedFromBuild>
    </FxCompile>
    <FxCompile Include="resources\shaders\Vignette.PS.hlsl">
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">true</ExcludedFromBuild>
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release|x64'">true</ExcludedFromBuild>
    </FxCompile>
    <FxCompile Include="resources\shaders\Vignette.VS.hlsl">
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release|x64'">true</ExcludedFromBuild>
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">true</ExcludedFromBuild>
    </FxCompile>
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>

============================================================
File Path: project/MyGame.vcxproj.filters
============================================================
ï»¿<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <FxCompile Include="resources\shaders\BoxFilter.PS.hlsl">
      <Filter>resources\shaders</Filter>
    </FxCompile>
    <FxCompile Include="resources\shaders\BoxFilter.VS.hlsl">
      <Filter>resources\shaders</Filter>
    </FxCompile>
    <FxCompile Include="resources\shaders\GaussianFilter.PS.hlsl">
      <Filter>resources\shaders</Filter>
    </FxCompile>
    <FxCompile Include="resources\shaders\GaussianFilter.VS.hlsl">
      <Filter>resources\shaders</Filter>
    </FxCompile>
    <FxCompile Include="resources\shaders\Grayscale.PS.hlsl">
      <Filter>resources\shaders</Filter>
    </FxCompile>
    <FxCompile Include="resources\shaders\Grayscale.VS.hlsl">
      <Filter>resources\shaders</Filter>
    </FxCompile>
    <FxCompile Include="resources\shaders\NoneEffect.PS.hlsl">
      <Filter>resources\shaders</Filter>
    </FxCompile>
    <FxCompile Include="resources\shaders\NoneEffect.VS.hlsl">
      <Filter>resources\shaders</Filter>
    </FxCompile>
    <FxCompile Include="resources\shaders\Object3d.PS.hlsl">
      <Filter>resources\shaders</Filter>
    </FxCompile>
    <FxCompile Include="resources\shaders\Object3d.VS.hlsl">
      <Filter>resources\shaders</Filter>
    </FxCompile>
    <FxCompile Include="resources\shaders\Particle.PS.hlsl">
      <Filter>resources\shaders</Filter>
    </FxCompile>
    <FxCompile Include="resources\shaders\Particle.VS.hlsl">
      <Filter>resources\shaders</Filter>
    </FxCompile>
    <FxCompile Include="resources\shaders\Skybox.PS.hlsl">
      <Filter>resources\shaders</Filter>
    </FxCompile>
    <FxCompile Include="resources\shaders\Skybox.VS.hlsl">
      <Filter>resources\shaders</Filter>
    </FxCompile>
    <FxCompile Include="resources\shaders\Vignette.VS.hlsl">
      <Filter>resources\shaders</Filter>
    </FxCompile>
    <FxCompile Include="resources\shaders\Vignette.PS.hlsl">
      <Filter>resources\shaders</Filter>
    </FxCompile>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="main.cpp" />
    <ClCompile Include="gameEngine\2d\Sprite.cpp">
      <Filter>gameEngine\2d</Filter>
    </ClCompile>
    <ClCompile Include="gameEngine\2d\SpriteCommon.cpp">
      <Filter>gameEngine\2d</Filter>
    </ClCompile>
    <ClCompile Include="gameEngine\3d\Camera.cpp">
      <Filter>gameEngine\3d</Filter>
    </ClCompile>
    <ClCompile Include="gameEngine\3d\CameraManager.cpp">
      <Filter>gameEngine\3d</Filter>
    </ClCompile>
    <ClCompile Include="gameEngine\3d\Model.cpp">
      <Filter>gameEngine\3d</Filter>
    </ClCompile>
    <ClCompile Include="gameEngine\3d\ModelCommon.cpp">
      <Filter>gameEngine\3d</Filter>
    </ClCompile>
    <ClCompile Include="gameEngine\3d\ModelManager.cpp">
      <Filter>gameEngine\3d</Filter>
    </ClCompile>
    <ClCompile Include="gameEngine\3d\Object3dCommon.cpp">
      <Filter>gameEngine\3d</Filter>
    </ClCompile>
    <ClCompile Include="gameEngine\3d\Object3d.cpp">
      <Filter>gameEngine\3d</Filter>
    </ClCompile>
    <ClCompile Include="gameEngine\audio\Audio.cpp">
      <Filter>gameEngine\audio</Filter>
    </ClCompile>
    <ClCompile Include="gameEngine\base\postEffect\BasePostEffectPass.cpp">
      <Filter>gameEngine\base\postEffect</Filter>
    </ClCompile>
    <ClCompile Include="gameEngine\base\postEffect\BoxFilterPass.cpp">
      <Filter>gameEngine\base\postEffect</Filter>
    </ClCompile>
    <ClCompile Include="gameEngine\base\postEffect\GaussianFilterPass.cpp">
      <Filter>gameEngine\base\postEffect</Filter>
    </ClCompile>
    <ClCompile Include="gameEngine\base\postEffect\GrayscalePass.cpp">
      <Filter>gameEngine\base\postEffect</Filter>
    </ClCompile>
    <ClCompile Include="gameEngine\base\postEffect\IPostEffectPass.cpp">
      <Filter>gameEngine\base\postEffect</Filter>
    </ClCompile>
    <ClCompile Include="gameEngine\base\postEffect\NoneEffectPass.cpp">
      <Filter>gameEngine\base\postEffect</Filter>
    </ClCompile>
    <ClCompile Include="gameEngine\base\postEffect\PostEffectManager.cpp">
      <Filter>gameEngine\base\postEffect</Filter>
    </ClCompile>
    <ClCompile Include="gameEngine\base\postEffect\VignettePass.cpp">
      <Filter>gameEngine\base\postEffect</Filter>
    </ClCompile>
    <ClCompile Include="gameEngine\base\D3DResourceLeakChecker.cpp">
      <Filter>gameEngine\base</Filter>
    </ClCompile>
    <ClCompile Include="gameEngine\base\DirectXCommon.cpp">
      <Filter>gameEngine\base</Filter>
    </ClCompile>
    <ClCompile Include="gameEngine\base\Framework.cpp">
      <Filter>gameEngine\base</Filter>
    </ClCompile>
    <ClCompile Include="gameEngine\base\RenderTexture.cpp">
      <Filter>gameEngine\base</Filter>
    </ClCompile>
    <ClCompile Include="gameEngine\base\SrvManager.cpp">
      <Filter>gameEngine\base</Filter>
    </ClCompile>
    <ClCompile Include="gameEngine\base\TextureManager.cpp">
      <Filter>gameEngine\base</Filter>
    </ClCompile>
    <ClCompile Include="gameEngine\base\WinApp.cpp">
      <Filter>gameEngine\base</Filter>
    </ClCompile>
    <ClCompile Include="gameEngine\baseScene\BaseScene.cpp">
      <Filter>gameEngine\baseScene</Filter>
    </ClCompile>
    <ClCompile Include="gameEngine\baseScene\MyGame.cpp">
      <Filter>gameEngine\baseScene</Filter>
    </ClCompile>
    <ClCompile Include="application\scene\SceneFactory.cpp">
      <Filter>gameEngine\baseScene</Filter>
    </ClCompile>
    <ClCompile Include="gameEngine\baseScene\SceneManager.cpp">
      <Filter>gameEngine\baseScene</Filter>
    </ClCompile>
    <ClCompile Include="gameEngine\Collider\Collider.cpp">
      <Filter>gameEngine\collider</Filter>
    </ClCompile>
    <ClCompile Include="gameEngine\Collider\ColliderManager.cpp">
      <Filter>gameEngine\collider</Filter>
    </ClCompile>
    <ClCompile Include="gameEngine\io\Input.cpp">
      <Filter>gameEngine\io</Filter>
    </ClCompile>
    <ClCompile Include="gameEngine\level_editor\LevelDataLoader.cpp">
      <Filter>gameEngine\level_editor</Filter>
    </ClCompile>
    <ClCompile Include="gameEngine\math\MyMath.cpp">
      <Filter>gameEngine\math</Filter>
    </ClCompile>
    <ClCompile Include="gameEngine\math\Matrix4x4.cpp">
      <Filter>gameEngine\math</Filter>
    </ClCompile>
    <ClCompile Include="gameEngine\math\Quaternion.cpp">
      <Filter>gameEngine\math</Filter>
    </ClCompile>
    <ClCompile Include="gameEngine\math\Vector2.cpp">
      <Filter>gameEngine\math</Filter>
    </ClCompile>
    <ClCompile Include="gameEngine\math\Vector3.cpp">
      <Filter>gameEngine\math</Filter>
    </ClCompile>
    <ClCompile Include="gameEngine\particle\MeshBuilder.cpp">
      <Filter>gameEngine\particle</Filter>
    </ClCompile>
    <ClCompile Include="gameEngine\particle\ParticleEmitter.cpp">
      <Filter>gameEngine\particle</Filter>
    </ClCompile>
    <ClCompile Include="gameEngine\particle\ParticleManager.cpp">
      <Filter>gameEngine\particle</Filter>
    </ClCompile>
    <ClCompile Include="gameEngine\particle\ParticleMotion.cpp">
      <Filter>gameEngine\particle</Filter>
    </ClCompile>
    <ClCompile Include="gameEngine\particle\Particle.cpp">
      <Filter>gameEngine\particle</Filter>
    </ClCompile>
    <ClCompile Include="gameEngine\skybox\Skybox.cpp">
      <Filter>gameEngine\skybox</Filter>
    </ClCompile>
    <ClCompile Include="gameEngine\utillity\Logger.cpp">
      <Filter>gameEngine\utillity</Filter>
    </ClCompile>
    <ClCompile Include="gameEngine\utillity\StringUtility.cpp">
      <Filter>gameEngine\utillity</Filter>
    </ClCompile>
    <ClCompile Include="application\scene\ClearScene.cpp">
      <Filter>application\scene</Filter>
    </ClCompile>
    <ClCompile Include="application\scene\GameOverScene.cpp">
      <Filter>application\scene</Filter>
    </ClCompile>
    <ClCompile Include="application\scene\GamePlayScene.cpp">
      <Filter>application\scene</Filter>
    </ClCompile>
    <ClCompile Include="application\scene\TitleScene.cpp">
      <Filter>application\scene</Filter>
    </ClCompile>
    <ClCompile Include="application\BaseObject\GameObject.cpp">
      <Filter>application\baseObject</Filter>
    </ClCompile>
    <ClCompile Include="application\objects\enemy\behaviorState\normalEnemyState\EnemyBehaviorAttack.cpp">
      <Filter>application\objects\enemy\behaviorState\normalEnemyState</Filter>
    </ClCompile>
    <ClCompile Include="application\objects\enemy\behaviorState\normalEnemyState\EnemyBehaviorDead.cpp">
      <Filter>application\objects\enemy\behaviorState\normalEnemyState</Filter>
    </ClCompile>
    <ClCompile Include="application\objects\enemy\behaviorState\normalEnemyState\EnemyBehaviorHitReact.cpp">
      <Filter>application\objects\enemy\behaviorState\normalEnemyState</Filter>
    </ClCompile>
    <ClCompile Include="application\objects\enemy\behaviorState\normalEnemyState\EnemyBehaviorMove.cpp">
      <Filter>application\objects\enemy\behaviorState\normalEnemyState</Filter>
    </ClCompile>
    <ClCompile Include="application\objects\enemy\behaviorState\normalEnemyState\EnemyBehaviorSpawn.cpp">
      <Filter>application\objects\enemy\behaviorState\normalEnemyState</Filter>
    </ClCompile>
    <ClCompile Include="application\objects\enemy\behaviorState\normalEnemyState\EnemyBehaviorState.cpp">
      <Filter>application\objects\enemy\behaviorState\normalEnemyState</Filter>
    </ClCompile>
    <ClCompile Include="application\Objects\Enemy\BehaviorState\TrapEnemyState\TrapEnemyBehaviorDead.cpp">
      <Filter>application\objects\enemy\behaviorState\trapEnemyState</Filter>
    </ClCompile>
    <ClCompile Include="application\Objects\Enemy\BehaviorState\TrapEnemyState\TrapEnemyBehaviorHitReact.cpp">
      <Filter>application\objects\enemy\behaviorState\trapEnemyState</Filter>
    </ClCompile>
    <ClCompile Include="application\Objects\Enemy\BehaviorState\TrapEnemyState\TrapEnemyBehaviorMove.cpp">
      <Filter>application\objects\enemy\behaviorState\trapEnemyState</Filter>
    </ClCompile>
    <ClCompile Include="application\Objects\Enemy\BehaviorState\TrapEnemyState\TrapEnemyBehaviorSetTrap.cpp">
      <Filter>application\objects\enemy\behaviorState\trapEnemyState</Filter>
    </ClCompile>
    <ClCompile Include="application\Objects\Enemy\BehaviorState\TrapEnemyState\TrapEnemyBehaviorSpawn.cpp">
      <Filter>application\objects\enemy\behaviorState\trapEnemyState</Filter>
    </ClCompile>
    <ClCompile Include="application\Objects\Enemy\BehaviorState\TrapEnemyState\TrapEnemyBehaviorState.cpp">
      <Filter>application\objects\enemy\behaviorState\trapEnemyState</Filter>
    </ClCompile>
    <ClCompile Include="application\Objects\Enemy\Bullet\EnemyBullet.cpp">
      <Filter>application\objects\enemy\bullet</Filter>
    </ClCompile>
    <ClCompile Include="application\Objects\Enemy\Bullet\TimeBomb.cpp">
      <Filter>application\objects\enemy\bullet</Filter>
    </ClCompile>
    <ClCompile Include="application\Objects\Enemy\Bullet\VignetteTrap.cpp">
      <Filter>application\objects\enemy\bullet</Filter>
    </ClCompile>
    <ClCompile Include="application\Objects\Enemy\WaveState\EnemyWaveStage1.cpp">
      <Filter>application\objects\enemy\waveState</Filter>
    </ClCompile>
    <ClCompile Include="application\Objects\Enemy\WaveState\EnemyWaveStage2.cpp">
      <Filter>application\objects\enemy\waveState</Filter>
    </ClCompile>
    <ClCompile Include="application\Objects\Enemy\WaveState\EnemyWaveState.cpp">
      <Filter>application\objects\enemy\waveState</Filter>
    </ClCompile>
    <ClCompile Include="application\Objects\Enemy\EnemyManager.cpp">
      <Filter>application\objects\enemy</Filter>
    </ClCompile>
    <ClCompile Include="application\Objects\Enemy\NormalEnemy.cpp">
      <Filter>application\objects\enemy</Filter>
    </ClCompile>
    <ClCompile Include="application\Objects\Enemy\TrapEnemy.cpp">
      <Filter>application\objects\enemy</Filter>
    </ClCompile>
    <ClCompile Include="application\Objects\Field\Barrie.cpp">
      <Filter>application\objects\field</Filter>
    </ClCompile>
    <ClCompile Include="application\Objects\Field\Field.cpp">
      <Filter>application\objects\field</Filter>
    </ClCompile>
    <ClCompile Include="application\Objects\Field\Goal.cpp">
      <Filter>application\objects\field</Filter>
    </ClCompile>
    <ClCompile Include="application\Objects\Field\Wall.cpp">
      <Filter>application\objects\field</Filter>
    </ClCompile>
    <ClCompile Include="application\Objects\Player\Player.cpp">
      <Filter>application\objects\player</Filter>
    </ClCompile>
    <ClCompile Include="application\Objects\Player\Bullet\PlayerBullet.cpp">
      <Filter>application\objects\player\bullet</Filter>
    </ClCompile>
    <ClCompile Include="gameEngine\imgui\ImGuiManager.cpp">
      <Filter>gameEngine\imgui</Filter>
    </ClCompile>
    <ClCompile Include="gameEngine\transition\BaseTransition.cpp">
      <Filter>gameEngine\transition</Filter>
    </ClCompile>
    <ClCompile Include="gameEngine\transition\BlockRiseTransition.cpp">
      <Filter>gameEngine\transition</Filter>
    </ClCompile>
    <ClCompile Include="gameEngine\transition\FadeTransition.cpp">
      <Filter>gameEngine\transition</Filter>
    </ClCompile>
    <ClCompile Include="gameEngine\transition\TransitionManager.cpp">
      <Filter>gameEngine\transition</Filter>
    </ClCompile>
    <ClCompile Include="application\objects\enemy\Corruptor.cpp" />
    <ClCompile Include="application\objects\enemy\behaviorState\corruptorState\CorruptorBehaviorSpawn.cpp" />
    <ClCompile Include="application\objects\enemy\behaviorState\corruptorState\CorruptorBehaviorState.cpp" />
    <ClCompile Include="application\objects\enemy\behaviorState\corruptorState\CorruptorBehaviorMove.cpp" />
    <ClCompile Include="application\objects\enemy\behaviorState\corruptorState\CorruptorBehaviorSelfDestruct.cpp" />
    <ClCompile Include="gameEngine\time\TimeManager.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="gameEngine\2d\Sprite.h">
      <Filter>gameEngine\2d</Filter>
    </ClInclude>
    <ClInclude Include="gameEngine\2d\SpriteCommon.h">
      <Filter>gameEngine\2d</Filter>
    </ClInclude>
    <ClInclude Include="gameEngine\3d\Camera.h">
      <Filter>gameEngine\3d</Filter>
    </ClInclude>
    <ClInclude Include="gameEngine\3d\CameraManager.h">
      <Filter>gameEngine\3d</Filter>
    </ClInclude>
    <ClInclude Include="gameEngine\3d\Model.h">
      <Filter>gameEngine\3d</Filter>
    </ClInclude>
    <ClInclude Include="gameEngine\3d\ModelCommon.h">
      <Filter>gameEngine\3d</Filter>
    </ClInclude>
    <ClInclude Include="gameEngine\3d\ModelManager.h">
      <Filter>gameEngine\3d</Filter>
    </ClInclude>
    <ClInclude Include="gameEngine\3d\Object3dCommon.h">
      <Filter>gameEngine\3d</Filter>
    </ClInclude>
    <ClInclude Include="gameEngine\3d\Object3d.h">
      <Filter>gameEngine\3d</Filter>
    </ClInclude>
    <ClInclude Include="gameEngine\audio\Audio.h">
      <Filter>gameEngine\audio</Filter>
    </ClInclude>
    <ClInclude Include="gameEngine\base\postEffect\BasePostEffectPass.h">
      <Filter>gameEngine\base\postEffect</Filter>
    </ClInclude>
    <ClInclude Include="gameEngine\base\postEffect\BoxFilterPass.h">
      <Filter>gameEngine\base\postEffect</Filter>
    </ClInclude>
    <ClInclude Include="gameEngine\base\postEffect\GaussianFilterPass.h">
      <Filter>gameEngine\base\postEffect</Filter>
    </ClInclude>
    <ClInclude Include="gameEngine\base\postEffect\GrayscalePass.h">
      <Filter>gameEngine\base\postEffect</Filter>
    </ClInclude>
    <ClInclude Include="gameEngine\base\postEffect\IPostEffectPass.h">
      <Filter>gameEngine\base\postEffect</Filter>
    </ClInclude>
    <ClInclude Include="gameEngine\base\postEffect\NoneEffectPass.h">
      <Filter>gameEngine\base\postEffect</Filter>
    </ClInclude>
    <ClInclude Include="gameEngine\base\postEffect\PostEffectManager.h">
      <Filter>gameEngine\base\postEffect</Filter>
    </ClInclude>
    <ClInclude Include="gameEngine\base\postEffect\VignettePass.h">
      <Filter>gameEngine\base\postEffect</Filter>
    </ClInclude>
    <ClInclude Include="gameEngine\base\D3DResourceLeakChecker.h">
      <Filter>gameEngine\base</Filter>
    </ClInclude>
    <ClInclude Include="gameEngine\base\DirectXCommon.h">
      <Filter>gameEngine\base</Filter>
    </ClInclude>
    <ClInclude Include="gameEngine\base\Framework.h">
      <Filter>gameEngine\base</Filter>
    </ClInclude>
    <ClInclude Include="gameEngine\base\RenderTexture.h">
      <Filter>gameEngine\base</Filter>
    </ClInclude>
    <ClInclude Include="gameEngine\base\SrvManager.h">
      <Filter>gameEngine\base</Filter>
    </ClInclude>
    <ClInclude Include="gameEngine\base\TextureManager.h">
      <Filter>gameEngine\base</Filter>
    </ClInclude>
    <ClInclude Include="gameEngine\base\WinApp.h">
      <Filter>gameEngine\base</Filter>
    </ClInclude>
    <ClInclude Include="gameEngine\baseScene\AbstractSceneFactory.h">
      <Filter>gameEngine\baseScene</Filter>
    </ClInclude>
    <ClInclude Include="gameEngine\baseScene\BaseScene.h">
      <Filter>gameEngine\baseScene</Filter>
    </ClInclude>
    <ClInclude Include="gameEngine\baseScene\MyGame.h">
      <Filter>gameEngine\baseScene</Filter>
    </ClInclude>
    <ClInclude Include="application\scene\SceneFactory.h">
      <Filter>gameEngine\baseScene</Filter>
    </ClInclude>
    <ClInclude Include="gameEngine\baseScene\SceneManager.h">
      <Filter>gameEngine\baseScene</Filter>
    </ClInclude>
    <ClInclude Include="gameEngine\Collider\Collider.h">
      <Filter>gameEngine\collider</Filter>
    </ClInclude>
    <ClInclude Include="gameEngine\Collider\ColliderManager.h">
      <Filter>gameEngine\collider</Filter>
    </ClInclude>
    <ClInclude Include="application\Collider\Shape.h">
      <Filter>gameEngine\collider</Filter>
    </ClInclude>
    <ClInclude Include="gameEngine\io\Input.h">
      <Filter>gameEngine\io</Filter>
    </ClInclude>
    <ClInclude Include="gameEngine\level_editor\LevelDataLoader.h">
      <Filter>gameEngine\level_editor</Filter>
    </ClInclude>
    <ClInclude Include="gameEngine\math\Ease.h">
      <Filter>gameEngine\math</Filter>
    </ClInclude>
    <ClInclude Include="gameEngine\math\MyMath.h">
      <Filter>gameEngine\math</Filter>
    </ClInclude>
    <ClInclude Include="gameEngine\math\Matrix4x4.h">
      <Filter>gameEngine\math</Filter>
    </ClInclude>
    <ClInclude Include="gameEngine\math\Quaternion.h">
      <Filter>gameEngine\math</Filter>
    </ClInclude>
    <ClInclude Include="gameEngine\math\Vector2.h">
      <Filter>gameEngine\math</Filter>
    </ClInclude>
    <ClInclude Include="gameEngine\math\Vector3.h">
      <Filter>gameEngine\math</Filter>
    </ClInclude>
    <ClInclude Include="gameEngine\particle\MeshBuilder.h">
      <Filter>gameEngine\particle</Filter>
    </ClInclude>
    <ClInclude Include="gameEngine\particle\Particle.h">
      <Filter>gameEngine\particle</Filter>
    </ClInclude>
    <ClInclude Include="gameEngine\particle\ParticleEmitter.h">
      <Filter>gameEngine\particle</Filter>
    </ClInclude>
    <ClInclude Include="gameEngine\particle\ParticleManager.h">
      <Filter>gameEngine\particle</Filter>
    </ClInclude>
    <ClInclude Include="gameEngine\particle\ParticleMotion.h">
      <Filter>gameEngine\particle</Filter>
    </ClInclude>
    <ClInclude Include="gameEngine\skybox\Skybox.h">
      <Filter>gameEngine\skybox</Filter>
    </ClInclude>
    <ClInclude Include="gameEngine\utillity\Logger.h">
      <Filter>gameEngine\utillity</Filter>
    </ClInclude>
    <ClInclude Include="gameEngine\utillity\StringUtility.h">
      <Filter>gameEngine\utillity</Filter>
    </ClInclude>
    <ClInclude Include="application\scene\ClearScene.h">
      <Filter>application\scene</Filter>
    </ClInclude>
    <ClInclude Include="application\scene\GameOverScene.h">
      <Filter>application\scene</Filter>
    </ClInclude>
    <ClInclude Include="application\scene\GamePlayScene.h">
      <Filter>application\scene</Filter>
    </ClInclude>
    <ClInclude Include="application\scene\TitleScene.h">
      <Filter>application\scene</Filter>
    </ClInclude>
    <ClInclude Include="application\BaseObject\GameObject.h">
      <Filter>application\baseObject</Filter>
    </ClInclude>
    <ClInclude Include="application\objects\enemy\behaviorState\normalEnemyState\EnemyBehaviorAttack.h">
      <Filter>application\objects\enemy\behaviorState\normalEnemyState</Filter>
    </ClInclude>
    <ClInclude Include="application\objects\enemy\behaviorState\normalEnemyState\EnemyBehaviorDead.h">
      <Filter>application\objects\enemy\behaviorState\normalEnemyState</Filter>
    </ClInclude>
    <ClInclude Include="application\objects\enemy\behaviorState\normalEnemyState\EnemyBehaviorHitReact.h">
      <Filter>application\objects\enemy\behaviorState\normalEnemyState</Filter>
    </ClInclude>
    <ClInclude Include="application\objects\enemy\behaviorState\normalEnemyState\EnemyBehaviorMove.h">
      <Filter>application\objects\enemy\behaviorState\normalEnemyState</Filter>
    </ClInclude>
    <ClInclude Include="application\objects\enemy\behaviorState\normalEnemyState\EnemyBehaviorSpawn.h">
      <Filter>application\objects\enemy\behaviorState\normalEnemyState</Filter>
    </ClInclude>
    <ClInclude Include="application\objects\enemy\behaviorState\normalEnemyState\EnemyBehaviorState.h">
      <Filter>application\objects\enemy\behaviorState\normalEnemyState</Filter>
    </ClInclude>
    <ClInclude Include="application\Objects\Enemy\BehaviorState\TrapEnemyState\TrapEnemyBehaviorDead.h">
      <Filter>application\objects\enemy\behaviorState\trapEnemyState</Filter>
    </ClInclude>
    <ClInclude Include="application\Objects\Enemy\BehaviorState\TrapEnemyState\TrapEnemyBehaviorHitReact.h">
      <Filter>application\objects\enemy\behaviorState\trapEnemyState</Filter>
    </ClInclude>
    <ClInclude Include="application\Objects\Enemy\BehaviorState\TrapEnemyState\TrapEnemyBehaviorMove.h">
      <Filter>application\objects\enemy\behaviorState\trapEnemyState</Filter>
    </ClInclude>
    <ClInclude Include="application\Objects\Enemy\BehaviorState\TrapEnemyState\TrapEnemyBehaviorSetTrap.h">
      <Filter>application\objects\enemy\behaviorState\trapEnemyState</Filter>
    </ClInclude>
    <ClInclude Include="application\Objects\Enemy\BehaviorState\TrapEnemyState\TrapEnemyBehaviorSpawn.h">
      <Filter>application\objects\enemy\behaviorState\trapEnemyState</Filter>
    </ClInclude>
    <ClInclude Include="application\Objects\Enemy\BehaviorState\TrapEnemyState\TrapEnemyBehaviorState.h">
      <Filter>application\objects\enemy\behaviorState\trapEnemyState</Filter>
    </ClInclude>
    <ClInclude Include="application\Objects\Enemy\Bullet\EnemyBullet.h">
      <Filter>application\objects\enemy\bullet</Filter>
    </ClInclude>
    <ClInclude Include="application\Objects\Enemy\Bullet\TimeBomb.h">
      <Filter>application\objects\enemy\bullet</Filter>
    </ClInclude>
    <ClInclude Include="application\Objects\Enemy\Bullet\VignetteTrap.h">
      <Filter>application\objects\enemy\bullet</Filter>
    </ClInclude>
    <ClInclude Include="application\Objects\Enemy\WaveState\EnemyWaveStage1.h">
      <Filter>application\objects\enemy\waveState</Filter>
    </ClInclude>
    <ClInclude Include="application\Objects\Enemy\WaveState\EnemyWaveStage2.h">
      <Filter>application\objects\enemy\waveState</Filter>
    </ClInclude>
    <ClInclude Include="application\Objects\Enemy\WaveState\EnemyWaveState.h">
      <Filter>application\objects\enemy\waveState</Filter>
    </ClInclude>
    <ClInclude Include="application\Objects\Enemy\EnemyManager.h">
      <Filter>application\objects\enemy</Filter>
    </ClInclude>
    <ClInclude Include="application\Objects\Enemy\NormalEnemy.h">
      <Filter>application\objects\enemy</Filter>
    </ClInclude>
    <ClInclude Include="application\Objects\Enemy\TrapEnemy.h">
      <Filter>application\objects\enemy</Filter>
    </ClInclude>
    <ClInclude Include="application\Objects\Field\Barrie.h">
      <Filter>application\objects\field</Filter>
    </ClInclude>
    <ClInclude Include="application\Objects\Field\Field.h">
      <Filter>application\objects\field</Filter>
    </ClInclude>
    <ClInclude Include="application\Objects\Field\Goal.h">
      <Filter>application\objects\field</Filter>
    </ClInclude>
    <ClInclude Include="application\Objects\Field\Wall.h">
      <Filter>application\objects\field</Filter>
    </ClInclude>
    <ClInclude Include="application\Objects\Player\Player.h">
      <Filter>application\objects\player</Filter>
    </ClInclude>
    <ClInclude Include="application\Objects\Player\Bullet\PlayerBullet.h">
      <Filter>application\objects\player\bullet</Filter>
    </ClInclude>
    <ClInclude Include="gameEngine\Collider\Shape.h">
      <Filter>gameEngine\collider</Filter>
    </ClInclude>
    <ClInclude Include="gameEngine\imgui\ImGuiManager.h">
      <Filter>gameEngine\imgui</Filter>
    </ClInclude>
    <ClInclude Include="gameEngine\transition\BaseTransition.h">
      <Filter>gameEngine\transition</Filter>
    </ClInclude>
    <ClInclude Include="gameEngine\transition\BlockRiseTransition.h">
      <Filter>gameEngine\transition</Filter>
    </ClInclude>
    <ClInclude Include="gameEngine\transition\FadeTransition.h">
      <Filter>gameEngine\transition</Filter>
    </ClInclude>
    <ClInclude Include="gameEngine\transition\TransitionManager.h">
      <Filter>gameEngine\transition</Filter>
    </ClInclude>
    <ClInclude Include="application\objects\enemy\Corruptor.h" />
    <ClInclude Include="application\objects\enemy\behaviorState\corruptorState\CorruptorBehaviorSpawn.h" />
    <ClInclude Include="application\objects\enemy\behaviorState\corruptorState\CorruptorBehaviorState.h" />
    <ClInclude Include="application\objects\enemy\behaviorState\corruptorState\CorruptorBehaviorMove.h" />
    <ClInclude Include="application\objects\enemy\behaviorState\corruptorState\CorruptorBehaviorSelfDestruct.h" />
    <ClInclude Include="gameEngine\time\TimeManager.h" />
  </ItemGroup>
  <ItemGroup>
    <None Include="resources\shaders\BoxFilter.hlsli">
      <Filter>resources\shaders</Filter>
    </None>
    <None Include="resources\shaders\GaussianFilter.hlsli">
      <Filter>resources\shaders</Filter>
    </None>
    <None Include="resources\shaders\Grayscale.hlsli">
      <Filter>resources\shaders</Filter>
    </None>
    <None Include="resources\shaders\NoneEffect.hlsli">
      <Filter>resources\shaders</Filter>
    </None>
    <None Include="resources\shaders\Object3d.hlsli">
      <Filter>resources\shaders</Filter>
    </None>
    <None Include="resources\shaders\Particle.hlsli">
      <Filter>resources\shaders</Filter>
    </None>
    <None Include="resources\shaders\Skybox.hlsli">
      <Filter>resources\shaders</Filter>
    </None>
    <None Include="resources\shaders\Vignette.hlsli">
      <Filter>resources\shaders</Filter>
    </None>
    <None Include="resources\shaders\Sprite.hlsli">
      <Filter>resources\shaders</Filter>
    </None>
  </ItemGroup>
  <ItemGroup>
    <Filter Include="application">
      <UniqueIdentifier>{ef590b3b-cb33-4fed-a8f7-7af37ccb4c3e}</UniqueIdentifier>
    </Filter>
    <Filter Include="gameEngine">
      <UniqueIdentifier>{e8f26abb-a076-49b3-b226-592d0fb8eaa6}</UniqueIdentifier>
    </Filter>
    <Filter Include="resources">
      <UniqueIdentifier>{f8ec7cd1-d83f-4bc3-8436-96ac38767c45}</UniqueIdentifier>
    </Filter>
    <Filter Include="gameEngine\2d">
      <UniqueIdentifier>{858817fc-d3a2-43a2-96a6-8a5cc5127e7d}</UniqueIdentifier>
    </Filter>
    <Filter Include="gameEngine\3d">
      <UniqueIdentifier>{535fdfaa-af1b-43e9-815d-9140fe51e955}</UniqueIdentifier>
    </Filter>
    <Filter Include="gameEngine\audio">
      <UniqueIdentifier>{639dc61e-045d-40af-b616-66d5dfa410ea}</UniqueIdentifier>
    </Filter>
    <Filter Include="gameEngine\base">
      <UniqueIdentifier>{47d00355-a526-473a-a412-bc45b62f2e57}</UniqueIdentifier>
    </Filter>
    <Filter Include="gameEngine\baseScene">
      <UniqueIdentifier>{8d23d401-2c15-49c5-93f9-6c9ce71472d3}</UniqueIdentifier>
    </Filter>
    <Filter Include="gameEngine\collider">
      <UniqueIdentifier>{b0f484f1-2580-43c7-a1fa-17a2ad3513eb}</UniqueIdentifier>
    </Filter>
    <Filter Include="gameEngine\io">
      <UniqueIdentifier>{998521fe-413a-44b5-9814-e64cb0b30cac}</UniqueIdentifier>
    </Filter>
    <Filter Include="gameEngine\level_editor">
      <UniqueIdentifier>{51fafc39-dc76-4603-ae52-28436fe991cd}</UniqueIdentifier>
    </Filter>
    <Filter Include="gameEngine\math">
      <UniqueIdentifier>{abc557aa-9165-4b6a-ad1a-58d9cab1f3ba}</UniqueIdentifier>
    </Filter>
    <Filter Include="gameEngine\particle">
      <UniqueIdentifier>{9eb307b5-63a5-4958-abf8-961a2bbac95b}</UniqueIdentifier>
    </Filter>
    <Filter Include="gameEngine\skybox">
      <UniqueIdentifier>{e3767490-8f63-4d26-ab36-9a8fd021710d}</UniqueIdentifier>
    </Filter>
    <Filter Include="gameEngine\utillity">
      <UniqueIdentifier>{7b2a0775-4e3b-4aa1-9bd8-dc7f4e9542a2}</UniqueIdentifier>
    </Filter>
    <Filter Include="gameEngine\base\postEffect">
      <UniqueIdentifier>{d047a0b4-2592-4804-a67b-c6946decb4c3}</UniqueIdentifier>
    </Filter>
    <Filter Include="application\baseObject">
      <UniqueIdentifier>{d701b2f0-a9c7-423f-af28-9e421b84604d}</UniqueIdentifier>
    </Filter>
    <Filter Include="application\objects">
      <UniqueIdentifier>{cce7038c-1b3c-41d7-8453-7ffac9122e0e}</UniqueIdentifier>
    </Filter>
    <Filter Include="application\scene">
      <UniqueIdentifier>{a30a9f7d-f268-4c78-91bb-40810aa62912}</UniqueIdentifier>
    </Filter>
    <Filter Include="application\objects\player">
      <UniqueIdentifier>{b6be3ad1-8ffc-4692-b495-6b1eb0d359b6}</UniqueIdentifier>
    </Filter>
    <Filter Include="application\objects\field">
      <UniqueIdentifier>{248c4153-de9f-44cb-994a-87a6a31e7a81}</UniqueIdentifier>
    </Filter>
    <Filter Include="application\objects\enemy">
      <UniqueIdentifier>{79b0a79e-a371-47a7-a64b-c8b734479cad}</UniqueIdentifier>
    </Filter>
    <Filter Include="application\objects\enemy\behaviorState">
      <UniqueIdentifier>{6f25b304-a646-4a0f-a3dc-d095f154652d}</UniqueIdentifier>
    </Filter>
    <Filter Include="application\objects\enemy\bullet">
      <UniqueIdentifier>{708d4c96-0eb9-4581-819a-79a4e3c5bfca}</UniqueIdentifier>
    </Filter>
    <Filter Include="application\objects\enemy\waveState">
      <UniqueIdentifier>{33825ac3-6500-45e3-9deb-81674d423565}</UniqueIdentifier>
    </Filter>
    <Filter Include="application\objects\enemy\behaviorState\normalEnemyState">
      <UniqueIdentifier>{8dc25fa7-1cdb-4cb8-a685-4c7514ff30a9}</UniqueIdentifier>
    </Filter>
    <Filter Include="application\objects\enemy\behaviorState\trapEnemyState">
      <UniqueIdentifier>{8ed1cbc4-f16c-41bc-9739-aceabce19f60}</UniqueIdentifier>
    </Filter>
    <Filter Include="application\objects\player\bullet">
      <UniqueIdentifier>{55f66df7-2c6c-4fea-a28b-8074ab2a3f1d}</UniqueIdentifier>
    </Filter>
    <Filter Include="resources\shaders">
      <UniqueIdentifier>{6305970c-01dc-4a40-8e52-a54b508b7c3a}</UniqueIdentifier>
    </Filter>
    <Filter Include="externals">
      <UniqueIdentifier>{8e618062-0a59-4955-849b-aaec1f357d8c}</UniqueIdentifier>
    </Filter>
    <Filter Include="externals\assimp">
      <UniqueIdentifier>{2185a170-0eef-44d0-904f-6e52e2546777}</UniqueIdentifier>
    </Filter>
    <Filter Include="externals\DirectXTex">
      <UniqueIdentifier>{299312d7-b454-4148-b5dc-3d640b0a64c8}</UniqueIdentifier>
    </Filter>
    <Filter Include="externals\imgui">
      <UniqueIdentifier>{8dfe2143-947d-4c45-8a63-c47d400bd0b9}</UniqueIdentifier>
    </Filter>
    <Filter Include="externals\json">
      <UniqueIdentifier>{e46bb7c5-077a-4a82-81b7-8e11aa54c844}</UniqueIdentifier>
    </Filter>
    <Filter Include="gameEngine\imgui">
      <UniqueIdentifier>{cc07e6dd-95f2-4529-8dae-7dd151c7e501}</UniqueIdentifier>
    </Filter>
    <Filter Include="gameEngine\transition">
      <UniqueIdentifier>{5585ca46-951a-45d4-be99-d785e70caa30}</UniqueIdentifier>
    </Filter>
  </ItemGroup>
</Project>

============================================================
File Path: project/application/BaseObject/GameObject.cpp
============================================================
#include "GameObject.h"

#include <functional>
#include <sstream>

GameObject::GameObject()
{
    objectName_ = "unnamed-object";
    scale_ = { 1.0f, 1.0f, 1.0f };
    rotation_ = { 0.0f, 0.0f, 0.0f };
    position_ = { 0.0f, 0.0f, 0.0f };
    hp_ = 100.0f;
}

void GameObject::CorrectOverlap(const AABB& otherAABB, AABB& selfAABB, Vector3& position)
{
    Vector3 penetrationVector{};

    // xè»¸(å·¦å³)
    float overlapLeftX = otherAABB.max.x - selfAABB.min.x;
    float overlapRightX = selfAABB.max.x - otherAABB.min.x;
    float correctionX = (overlapLeftX < overlapRightX) ? overlapLeftX : -overlapRightX;

    // yè»¸(ä¸Šä¸‹)
    float overlapBelowY = otherAABB.max.y - selfAABB.min.y;
    float overlapAboveY = selfAABB.max.y - otherAABB.min.y;
    float correctionY = (overlapBelowY < overlapAboveY) ? overlapBelowY : -overlapAboveY;

    // zè»¸(å‰å¾Œ)
    float overlapBackZ = otherAABB.max.z - selfAABB.min.z;
    float overlapFrontZ = selfAABB.max.z - otherAABB.min.z;
    float correctionZ = (overlapBackZ < overlapFrontZ) ? overlapBackZ : -overlapFrontZ;

    // æœ€å°ã®é‡ãªã‚Šã‚’æŒã¤è»¸ã‚’é¸æŠž
    float absX = std::abs(correctionX);
    float absY = std::abs(correctionY);
    float absZ = std::abs(correctionZ);

    if (absX <= absY && absX <= absZ)
        penetrationVector.x = correctionX;
    else if (absY <= absZ)
        penetrationVector.y = correctionY;
    else
        penetrationVector.z = correctionZ;

    // ä½ç½®ã‚’ä¿®æ­£
    position += penetrationVector;
}

bool GameObject::IsAABBOverlap(const AABB& a, const AABB& b)
{
    return (a.min.x <= b.max.x && a.max.x >= b.min.x) &&
        (a.min.y <= b.max.y && a.max.y >= b.min.y) &&
        (a.min.z <= b.max.z && a.max.z >= b.min.z);
}

============================================================
File Path: project/application/BaseObject/GameObject.h
============================================================
#pragma once

#include <Vector3.h>
#include <string>

#include "../../gameEngine/Collider/Shape.h"

/// <summary>
/// ã‚²ãƒ¼ãƒ ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®åŸºåº•ã‚¯ãƒ©ã‚¹
/// </summary>
class GameObject
{
public:

    GameObject();
    virtual ~GameObject() {};

public: // ä»®æƒ³é–¢æ•°

	// åˆæœŸåŒ–
    virtual void Initialize() = 0;
	// æ›´æ–°
    virtual void Update() = 0;
	// æç”»
    virtual void Draw() = 0;
	// çµ‚äº†
    virtual void Finalize() = 0;

public: // ã‚²ãƒƒã‚¿ãƒ¼

	// ã‚¹ã‚±ãƒ¼ãƒ«å–å¾—
    virtual Vector3 GetScale() const { return scale_; };
	// å›žè»¢å–å¾—
    virtual Vector3 GetRotation() const { return rotation_; };
	// ä½ç½®å–å¾—
    virtual Vector3 GetPosition() const { return position_; };
	// HPå–å¾—
    virtual float   GetHP() const { return hp_; };
	// ãƒ‡ã‚¹ãƒ•ãƒ©ã‚°
    virtual bool IsDead() const { return isDead_; }
	// ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãŒã‚¢ã‚¯ãƒ†ã‚£ãƒ–ã‹ã©ã†ã‹(å›žé¿ä¸­ãªã©åˆ¤å®šã‚’ä»˜ã‘ãŸããªã„å ´åˆç­‰)
    virtual bool IsActive() const { return isActive_; }

public: // ã‚»ãƒƒã‚¿ãƒ¼

	/// <summary>
	/// ã‚¹ã‚±ãƒ¼ãƒ«è¨­å®š
	/// </summary>
	/// <param name="_scale">ã‚¹ã‚±ãƒ¼ãƒ«</param>
	virtual void SetScale(const Vector3& _scale) { scale_ = _scale; };
    
	/// <summary>
	/// å›žè»¢è¨­å®š
	/// </summary>
	/// <param name="_rotation">å›žè»¢</param>
	virtual void SetRotation(const Vector3& _rotation) { rotation_ = _rotation; };
    
	/// <summary>
	/// ä½ç½®è¨­å®š
	/// </summary>
	/// <param name="_position">ä½ç½®</param>
	virtual void SetPosition(const Vector3& _position) { position_ = _position; };
    
	/// <summary>
	/// HPè¨­å®š
	/// </summary>
	/// <param name="_hp">HP</param>
    virtual void SetHP(float _hp) { hp_ = _hp; };

	/// <summary>
	/// ãƒ‡ã‚¹ãƒ•ãƒ©ã‚°è¨­å®š
	/// </summary>
	/// <param name="_isDead">ãƒ‡ã‚¹ãƒ•ãƒ©ã‚°</param>
    virtual void SetIsDead(bool _isDead) { isDead_ = _isDead; };
	
	/// <summary>
	/// ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãŒã‚¢ã‚¯ãƒ†ã‚£ãƒ–ã‹ã©ã†ã‹è¨­å®š(å›žé¿ä¸­ãªã©åˆ¤å®šã‚’ä»˜ã‘ãŸããªã„å ´åˆç­‰)
	/// </summary>
	/// <param name="_isActive">ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ã‹ã©ã†ã‹</param>
    virtual void SetIsActive(bool _isActive) { isActive_ = _isActive; };


protected: // ãƒ¡ãƒ³ãƒãƒ¼

	/// <summary>
    /// è¡çªæ™‚ã®æŠ¼ã—å‡ºã—å‡¦ç†
	/// </summary>
	/// <param name="otherAABB">ç›¸æ‰‹ã®AABB</param>
	/// <param name="selfAABB">è‡ªåˆ†ã®AABB</param>
	/// <param name="position">è‡ªåˆ†ã®ä½ç½®</param>
    void CorrectOverlap(const AABB& otherAABB, AABB& selfAABB, Vector3& position);

	/// <summary>
	/// AABBã®é‡ãªã‚Šåˆ¤å®š
	/// </summary>
	/// <param name="a">AABB a</param>
	/// <param name="b">AABB b</param>
	/// <returns>é‡ãªã£ã¦ã„ã‚‹ã‹ã©ã†ã‹</returns>
    bool IsAABBOverlap(const AABB& a, const AABB& b);

    std::string objectName_;
    Vector3 scale_;
    Vector3 rotation_;
    Vector3 position_;
    float hp_;
    // ãƒ‡ã‚¹ãƒ•ãƒ©ã‚°
	bool isDead_ = false; 
    // ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãŒã‚¢ã‚¯ãƒ†ã‚£ãƒ–ã‹ã©ã†ã‹(å›žé¿ä¸­ãªã©åˆ¤å®šã‚’ä»˜ã‘ãŸããªã„å ´åˆç­‰)
	bool isActive_ = false;
};

============================================================
File Path: project/application/Objects/Enemy/BehaviorState/TrapEnemyState/TrapEnemyBehaviorDead.cpp
============================================================
#include "TrapEnemyBehaviorDead.h"

#include <Ease.h>

#include "../../TrapEnemy.h"

TrapEnemyBehaviorDead::TrapEnemyBehaviorDead(TrapEnemy* _pTrapEnemy) : TrapEnemyBehaviorState("Dead", _pTrapEnemy)
{
	motion_.isActive = true;
	motion_.count = 0;
	motion_.maxCount = 30; // ãƒ¢ãƒ¼ã‚·ãƒ§ãƒ³ã®ã‚«ã‚¦ãƒ³ãƒˆã‚’è¨­å®š
}

void TrapEnemyBehaviorDead::Initialize()
{
}

void TrapEnemyBehaviorDead::Update()
{
	// æ•µã®ãƒˆãƒ©ãƒ³ã‚¹ãƒ•ã‚©ãƒ¼ãƒ ã‚’motion_.transformã«ã‚»ãƒƒãƒˆ
	TransformUpdate(pTrapEnemy_);

	float t = float(motion_.count) / motion_.maxCount;

	if (motion_.count == 0)
	{
		motion_.transform.scale = Vector3(1.8f, 1.8f, 1.8f); // åˆå›žã ã‘ä¸€æ°—ã«è†¨ã‚‰ã‚€
	}

	// å¾ã€…ã«ç¸®ã‚€æ¼”å‡º
	float scale = Lerp(1.8f, 0.0f, Ease::InCubic(t));
	motion_.transform.scale = (Vector3(scale, scale, scale));

	motion_.transform.position.y += Ease::OutQuad(t) * 0.1f;

	motion_.transform.rotation.y += 0.1f;
	motion_.transform.rotation.x += 0.1f;

	pTrapEnemy_->SetObjectPosition(motion_.transform.position);
	pTrapEnemy_->SetObjectRotation(motion_.transform.rotation);
	pTrapEnemy_->SetObjectScale(motion_.transform.scale);


	// ãƒ¢ãƒ¼ã‚·ãƒ§ãƒ³ã‚«ã‚¦ãƒ³ãƒˆã‚’æ›´æ–°
	MotionCount(motion_);

	if (!motion_.isActive)
	{
		// æ­»äº¡ãƒ¢ãƒ¼ã‚·ãƒ§ãƒ³ãŒçµ‚äº†ã—ãŸã‚‰ã€æ•µã‚’å‰Šé™¤
		pTrapEnemy_->SetIsDead(true);

		// ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«
		ParticleEmitter::Emit("explosionGroup", motion_.transform.position, 6);
		ParticleEmitter::Emit("rupture", motion_.transform.position, 20);
	}
}

void TrapEnemyBehaviorDead::ResetMotion()
{
}


============================================================
File Path: project/application/Objects/Enemy/BehaviorState/TrapEnemyState/TrapEnemyBehaviorDead.h
============================================================
#pragma once

#include "TrapEnemyBehaviorState.h"

/// <summary>
/// ç½ è¨­ç½®åž‹æ•µã®æ­»äº¡çŠ¶æ…‹
/// </summary>
class TrapEnemyBehaviorDead : public TrapEnemyBehaviorState
{
public:

	/// <summary>
	/// ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿
	/// </summary>
	/// <param name="_pTrapEnemy">ç½ åž‹æ•µã®ãƒã‚¤ãƒ³ã‚¿</param>
	TrapEnemyBehaviorDead(TrapEnemy* _pTrapEnemy);

	// åˆæœŸåŒ–
	void Initialize() override;

	// æ›´æ–°
	void Update() override;

	// ãƒ¢ãƒ¼ã‚·ãƒ§ãƒ³ã®ãƒªã‚»ãƒƒãƒˆ
	void ResetMotion() override;


};



============================================================
File Path: project/application/Objects/Enemy/BehaviorState/TrapEnemyState/TrapEnemyBehaviorHitReact.cpp
============================================================
#include "TrapEnemyBehaviorHitReact.h"

#include <Ease.h>

#include "../../TrapEnemy.h"
#include "TrapEnemyBehaviorMove.h"
#include "TrapEnemyBehaviorDead.h"

TrapEnemyBehaviorHitReact::TrapEnemyBehaviorHitReact(TrapEnemy* _pTrapEnemy) : TrapEnemyBehaviorState("Hit", _pTrapEnemy)
{
	motion_.isActive = true;
	motion_.count = 0;
	motion_.maxCount = 30; // ç§»å‹•ãƒ¢ãƒ¼ã‚·ãƒ§ãƒ³ã®ã‚«ã‚¦ãƒ³ãƒˆã‚’è¨­å®š
}

void TrapEnemyBehaviorHitReact::Initialize()
{
}

void TrapEnemyBehaviorHitReact::Update()
{
	// æ•µã®ãƒˆãƒ©ãƒ³ã‚¹ãƒ•ã‚©ãƒ¼ãƒ ã‚’motion_.transformã«ã‚»ãƒƒãƒˆ
	TransformUpdate(pTrapEnemy_);

	Vector3 shakeOffset =
	{
	((motion_.count % 2 == 0) ? 1.0f : -1.0f) * 0.1f,
	0.0f, // Yè»¸ã¯æºã‚‰ã•ãªã„
	((motion_.count % 3 == 0) ? 1.0f : -1.0f) * 0.1f
	};

	Vector3 originPos = pTrapEnemy_->GetPosition();

	pTrapEnemy_->SetObjectPosition(originPos + shakeOffset);

	// ãƒ¢ãƒ¼ã‚·ãƒ§ãƒ³ã‚«ã‚¦ãƒ³ãƒˆã‚’æ›´æ–°
	MotionCount(motion_);

	if (!motion_.isActive)
	{
		if (pTrapEnemy_->GetHP() <= 0)
		{
			// HPãŒ0ä»¥ä¸‹ãªã‚‰ã€æ­»äº¡ãƒ¢ãƒ¼ã‚·ãƒ§ãƒ³ã«åˆ‡ã‚Šæ›¿ãˆ
			pTrapEnemy_->ChangeBehaviorState(std::make_unique<TrapEnemyBehaviorDead>(pTrapEnemy_));
			return;
		}
		else
		{
			// ç„¡æ•µçŠ¶æ…‹ã‚’è§£é™¤
			pTrapEnemy_->SetIsInvincible(false);

			// ãƒ’ãƒƒãƒˆãƒªã‚¢ã‚¯ã‚·ãƒ§ãƒ³ãƒ¢ãƒ¼ã‚·ãƒ§ãƒ³ãŒçµ‚äº†ã—ãŸã‚‰ã€ç§»å‹•ãƒ¢ãƒ¼ã‚·ãƒ§ãƒ³ã«åˆ‡ã‚Šæ›¿ãˆ
			pTrapEnemy_->ChangeBehaviorState(std::make_unique<TrapEnemyBehaviorMove>(pTrapEnemy_));
		}
	}

}

void TrapEnemyBehaviorHitReact::ResetMotion()
{
}


============================================================
File Path: project/application/Objects/Enemy/BehaviorState/TrapEnemyState/TrapEnemyBehaviorHitReact.h
============================================================
#pragma once

#include "TrapEnemyBehaviorState.h"

/// <summary>
/// ç½ åž‹æ•µã®è¢«å¼¾çŠ¶æ…‹
/// </summary>
class TrapEnemyBehaviorHitReact : public TrapEnemyBehaviorState
{
public:
	
	/// <summary>
	/// ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿
	/// </summary>
	/// <param name="_pTrapEnemy">ç½ åž‹æ•µã®ãƒã‚¤ãƒ³ã‚¿</param>
	TrapEnemyBehaviorHitReact(TrapEnemy* _pTrapEnemy);
	
	// åˆæœŸåŒ–
	void Initialize() override;
	
	// æ›´æ–°
	void Update() override;

	// ãƒ¢ãƒ¼ã‚·ãƒ§ãƒ³ã®ãƒªã‚»ãƒƒãƒˆ
	void ResetMotion() override;

};



============================================================
File Path: project/application/Objects/Enemy/BehaviorState/TrapEnemyState/TrapEnemyBehaviorMove.cpp
============================================================
#include "TrapEnemyBehaviorMove.h"

#include <Ease.h>

#include "../../TrapEnemy.h"
#include "TrapEnemyBehaviorSetTrap.h"
#include "TrapEnemyBehaviorHitReact.h"

TrapEnemyBehaviorMove::TrapEnemyBehaviorMove(TrapEnemy* _pTrapEnemy) : TrapEnemyBehaviorState("Move", _pTrapEnemy)
{
	motion_.isActive = true;
	motion_.count = 0;
	motion_.maxCount = 30; // ç§»å‹•ãƒ¢ãƒ¼ã‚·ãƒ§ãƒ³ã®ã‚«ã‚¦ãƒ³ãƒˆã‚’è¨­å®š
}

void TrapEnemyBehaviorMove::Initialize()
{
	trapCooldown_ = kMaxTrapCooldown;
}

void TrapEnemyBehaviorMove::Update()
{

	// æ•µã®ãƒˆãƒ©ãƒ³ã‚¹ãƒ•ã‚©ãƒ¼ãƒ ã‚’motion_.transformã«ã‚»ãƒƒãƒˆ
	TransformUpdate(pTrapEnemy_);

	// 0ã«ãªã£ãŸã‚‰å…ƒã«æˆ»ã™
	if (trapCooldown_ == 0)
	{
		trapCooldown_ = kMaxTrapCooldown;
	}

	// ã‚¯ãƒ¼ãƒ«ã‚¿ã‚¤ãƒ é€²è¡Œ
	trapCooldown_--;

	// ã‚¯ãƒ¼ãƒ«ã‚¿ã‚¤ãƒ ãŒå®Œäº†ã—ã¦ã„ã‚‹ã‹ã©ã†ã‹ã‚’ãƒã‚§ãƒƒã‚¯
	pTrapEnemy_->SetIsTrapCooldownComplete((trapCooldown_ <= 0));


	// å‹•ãå‰ã«åˆ‡ã‚Šæ›¿ãˆå‡¦ç†
	if (pTrapEnemy_->IsHit())
	{
		// ãƒ’ãƒƒãƒˆãƒ•ãƒ©ã‚°ã‚’ãƒªã‚»ãƒƒãƒˆ
		pTrapEnemy_->SetIsHit(false);

		// ç„¡æ•µåŒ–
		pTrapEnemy_->SetIsInvincible(true);

		// ãƒ’ãƒƒãƒˆã—ãŸã‚‰ã€ãƒ’ãƒƒãƒˆãƒªã‚¢ã‚¯ã‚·ãƒ§ãƒ³ãƒ¢ãƒ¼ã‚·ãƒ§ãƒ³ã«åˆ‡ã‚Šæ›¿ãˆ
		pTrapEnemy_->ChangeBehaviorState(std::make_unique<TrapEnemyBehaviorHitReact>(pTrapEnemy_));
		return;
	}
	else if (pTrapEnemy_->IsStopAndTrap() && pTrapEnemy_->IsTrapCooldownComplete())
	{
		// ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã¨ã®è·é›¢ãŒä¸€å®šä»¥ä¸‹ã®å ´åˆã€æ”»æ’ƒãƒ¢ãƒ¼ã‚·ãƒ§ãƒ³ã«åˆ‡ã‚Šæ›¿ãˆ
		pTrapEnemy_->ChangeBehaviorState(std::make_unique<TrapEnemyBehaviorSetTrap>(pTrapEnemy_));
		return;
	} 
	else
	{
		// ã‚¹ãƒ†ãƒ¼ãƒˆãŒåˆ‡ã‚Šæ›¿ã‚ã‚‰ãªã‹ã£ãŸã‚‰ã‚‚ã†ä¸€åº¦
		ResetMotion();
	}

	// ã‚¤ãƒ¼ã‚¸ãƒ³ã‚°é€²è¡Œåº¦ï¼ˆ0ã€œ1ï¼‰
	float t = float(motion_.count) / motion_.maxCount;

	// ãƒãƒ¨ãƒãƒ¨æ‹¡å¤§ç¸®å°ï¼ˆXãƒ»Yä¸¡æ–¹ï¼‰
	float scaleWaveX = 1.0f + std::sin(t * std::numbers::pi_v<float>) * 0.2f;
	float scaleWaveY = 1.0f + std::cos(t * std::numbers::pi_v<float>) * 0.2f;

	// ã‚¹ã‚±ãƒ¼ãƒ«ã‚’æ›´æ–°ï¼ˆXãƒ»Yä¸¡æ–¹ãƒãƒ¨ãƒãƒ¨ï¼‰
	motion_.transform.scale = Vector3(scaleWaveX, scaleWaveY, 1.0f);

	// ã‚¹ã‚±ãƒ¼ãƒ«ã‚’ã‚»ãƒƒãƒˆ
	pTrapEnemy_->SetScale(motion_.transform.scale);

	// ãƒ¢ãƒ¼ã‚·ãƒ§ãƒ³ã‚«ã‚¦ãƒ³ãƒˆã‚’æ›´æ–°
	MotionCount(motion_);

	// ç§»å‹•
	pTrapEnemy_->Move();

}

void TrapEnemyBehaviorMove::ResetMotion()
{
	motion_.isActive = true;
	motion_.count = 0;
	motion_.maxCount = 30; // ç§»å‹•ãƒ¢ãƒ¼ã‚·ãƒ§ãƒ³ã®ã‚«ã‚¦ãƒ³ãƒˆã‚’è¨­å®š
}


============================================================
File Path: project/application/Objects/Enemy/BehaviorState/TrapEnemyState/TrapEnemyBehaviorMove.h
============================================================
#pragma once

#include "TrapEnemyBehaviorState.h"

/// <summary>
/// ç½ è¨­ç½®åž‹æ•µã®ç§»å‹•çŠ¶æ…‹
/// </summary>
class TrapEnemyBehaviorMove : public TrapEnemyBehaviorState
{
public:

	/// <summary>
	/// ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿
	/// </summary>
	/// <param name="_pTrapEnemy">ç½ åž‹æ•µã®ãƒã‚¤ãƒ³ã‚¿</param>
	TrapEnemyBehaviorMove(TrapEnemy* _pTrapEnemy);
	
	// åˆæœŸåŒ–
	void Initialize() override;
	
	// æ›´æ–°
	void Update() override;
	
	// ãƒ¢ãƒ¼ã‚·ãƒ§ãƒ³ã®ãƒªã‚»ãƒƒãƒˆ
	void ResetMotion() override;


private:

	// ç½ è¨­ç½®ã®ã‚¯ãƒ¼ãƒ«ã‚¿ã‚¤ãƒ 	
	uint32_t trapCooldown_ = 0;
	// ã‚¯ãƒ¼ãƒ«ã‚¿ã‚¤ãƒ ã®æœ€å¤§å€¤
	const uint32_t kMaxTrapCooldown = 60 * 3;

};



============================================================
File Path: project/application/Objects/Enemy/BehaviorState/TrapEnemyState/TrapEnemyBehaviorSetTrap.cpp
============================================================
#include "TrapEnemyBehaviorSetTrap.h"

#include <Ease.h>

#include "../../TrapEnemy.h"
#include "TrapEnemyBehaviorMove.h"
#include "TrapEnemyBehaviorHitReact.h"
#include "TrapEnemyBehaviorDead.h"

TrapEnemyBehaviorSetTrap::TrapEnemyBehaviorSetTrap(TrapEnemy* _pTrapEnemy) : TrapEnemyBehaviorState("SetTrap", _pTrapEnemy)
{
	// ãƒ¢ãƒ¼ã‚·ãƒ§ãƒ³ã®åˆæœŸåŒ–
	motion_.count = 0;
	motion_.maxCount = 30; // æ”»æ’ƒãƒ¢ãƒ¼ã‚·ãƒ§ãƒ³ã®ã‚«ã‚¦ãƒ³ãƒˆã‚’è¨­å®š
	motion_.isActive = true;
}

void TrapEnemyBehaviorSetTrap::Initialize()
{
}

void TrapEnemyBehaviorSetTrap::Update()
{
    // æ•µã®ãƒˆãƒ©ãƒ³ã‚¹ãƒ•ã‚©ãƒ¼ãƒ ã‚’motion_.transformã«ã‚»ãƒƒãƒˆ
    TransformUpdate(pTrapEnemy_);

    const int expandTime = 15;

    if (motion_.isActive)
    {
        if (motion_.count < expandTime)
        {
            // ã‚°ã‚°ã£ã¨è†¨ã‚‰ã‚€
            float t = float(motion_.count) / expandTime;
            float scaleValue = 1.0f + Ease::OutBack(t) * 0.5f;

            // ãƒ—ãƒ«ãƒ—ãƒ«éœ‡ãˆã‚‹
            float shakeMag = 0.05f; // éœ‡ãˆã®å¤§ãã•
            float shakeX = std::sin(motion_.count * 0.5f) * shakeMag;
            float shakeY = std::cos(motion_.count * 0.7f) * shakeMag;

            motion_.transform.scale = Vector3(scaleValue, scaleValue, scaleValue);
            pTrapEnemy_->SetObjectScale(motion_.transform.scale);
            pTrapEnemy_->SetObjectPosition(motion_.transform.position + Vector3(shakeX, shakeY, 0.0f));
        }
        else if (motion_.count == expandTime)
        {
            // ãƒ•ãƒ©ã‚°ã‚’åˆ‡ã‚Šæ›¿ãˆã€ã‚·ãƒ¥ãƒƒã¨å…ƒã«æˆ»ã™
            isSetTrap_ = true;
            motion_.transform.scale = Vector3(1.0f, 1.0f, 1.0f);
            pTrapEnemy_->SetObjectScale(motion_.transform.scale);
            pTrapEnemy_->SetObjectPosition(motion_.transform.position); // ä½ç½®ã‚‚å…ƒã«æˆ»ã™
        }
        else
        {
            // é€šå¸¸ã‚µã‚¤ã‚º
            isSetTrap_ = false;
            motion_.transform.scale = Vector3(1.0f, 1.0f, 1.0f);
            pTrapEnemy_->SetObjectScale(motion_.transform.scale);
            pTrapEnemy_->SetObjectPosition(motion_.transform.position);
        }
    }

    if (pTrapEnemy_->GetHP() <= 0)
    {
        // HPãŒ0ä»¥ä¸‹ãªã‚‰ã€æ­»äº¡ãƒ¢ãƒ¼ã‚·ãƒ§ãƒ³ã«åˆ‡ã‚Šæ›¿ãˆ
        pTrapEnemy_->ChangeBehaviorState(std::make_unique<TrapEnemyBehaviorDead>(pTrapEnemy_));
        return;
    } 
    else if (pTrapEnemy_->IsHit())
    {
        // ãƒ’ãƒƒãƒˆãƒ•ãƒ©ã‚°ã‚’ãƒªã‚»ãƒƒãƒˆ
        pTrapEnemy_->SetIsHit(false);
        // ç„¡æ•µåŒ–
        pTrapEnemy_->SetIsInvincible(true);
        // ãƒ’ãƒƒãƒˆã—ãŸã‚‰ã€ãƒ’ãƒƒãƒˆãƒªã‚¢ã‚¯ã‚·ãƒ§ãƒ³ãƒ¢ãƒ¼ã‚·ãƒ§ãƒ³ã«åˆ‡ã‚Šæ›¿ãˆ
        pTrapEnemy_->ChangeBehaviorState(std::make_unique<TrapEnemyBehaviorHitReact>(pTrapEnemy_));
        return;
    } 
    else if (!motion_.isActive)
    {
        // 1è¨­ç½®å®Œäº†ã—ãŸã‚‰ç§»å‹•ãƒ¢ãƒ¼ã‚·ãƒ§ãƒ³ã«åˆ‡ã‚Šæ›¿ãˆ
        pTrapEnemy_->ChangeBehaviorState(std::make_unique<TrapEnemyBehaviorMove>(pTrapEnemy_));
        return;
    } 
   
    // ãƒ¢ãƒ¼ã‚·ãƒ§ãƒ³ã‚«ã‚¦ãƒ³ãƒˆã‚’æ›´æ–°
    MotionCount(motion_);

    if(isSetTrap_)
    {
        pTrapEnemy_->TrapInit();
        // ãƒ•ãƒ©ã‚°åè»¢
        pTrapEnemy_->ChangeIsNextTrapTimeBomb();
    }
   
}

void TrapEnemyBehaviorSetTrap::ResetMotion()
{
	// ãƒ¢ãƒ¼ã‚·ãƒ§ãƒ³ã®åˆæœŸåŒ–
	motion_.count = 0;
	motion_.maxCount = 30; // æ”»æ’ƒãƒ¢ãƒ¼ã‚·ãƒ§ãƒ³ã®ã‚«ã‚¦ãƒ³ãƒˆã‚’è¨­å®š
}


============================================================
File Path: project/application/Objects/Enemy/BehaviorState/TrapEnemyState/TrapEnemyBehaviorSetTrap.h
============================================================
#pragma once

#include "TrapEnemyBehaviorState.h"

/// <summary>
/// ç½ è¨­ç½®çŠ¶æ…‹
/// </summary>
class TrapEnemyBehaviorSetTrap : public TrapEnemyBehaviorState
{
public:

	/// <summary>
	/// ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿
	/// </summary>
	/// <param name="_pTrapEnemy">ç½ åž‹æ•µã®ãƒã‚¤ãƒ³ã‚¿</param>
	TrapEnemyBehaviorSetTrap(TrapEnemy* _pTrapEnemy);
	
	// åˆæœŸåŒ–
	void Initialize() override;
	
	// æ›´æ–°
	void Update() override;
	
	// ãƒ¢ãƒ¼ã‚·ãƒ§ãƒ³ã®ãƒªã‚»ãƒƒãƒˆ
	void ResetMotion() override;


private:

	// ç½ è¨­ç½®ãƒ•ãƒ©ã‚°
	bool isSetTrap_ = false;

};



============================================================
File Path: project/application/Objects/Enemy/BehaviorState/TrapEnemyState/TrapEnemyBehaviorSpawn.cpp
============================================================
#include "TrapEnemyBehaviorSpawn.h"

#include <Ease.h>

#include "../../TrapEnemy.h"
#include "TrapEnemyBehaviorMove.h"

TrapEnemyBehaviorSpawn::TrapEnemyBehaviorSpawn(TrapEnemy* _pTrapEnemy) : TrapEnemyBehaviorState("Spawn", _pTrapEnemy)
{
	// ãƒ¢ãƒ¼ã‚·ãƒ§ãƒ³ã®åˆæœŸåŒ–
	motion_.isActive = true;
	motion_.count = 0;
	motion_.maxCount = 30; // ã‚¹ãƒãƒ¼ãƒ³ãƒ¢ãƒ¼ã‚·ãƒ§ãƒ³ã®ã‚«ã‚¦ãƒ³ãƒˆã‚’è¨­å®š
}

void TrapEnemyBehaviorSpawn::Initialize()
{
}

void TrapEnemyBehaviorSpawn::Update()
{
	// æ•µã®ãƒˆãƒ©ãƒ³ã‚¹ãƒ•ã‚©ãƒ¼ãƒ ã‚’motion_.transformã«ã‚»ãƒƒãƒˆ
	TransformUpdate(pTrapEnemy_);

	// ã‚¤ãƒ¼ã‚¸ãƒ³ã‚°ã®é€²è¡Œåº¦
	float t = float(motion_.count) / motion_.maxCount;
	motion_.transform.scale.x = Ease::OutBack(t);
	motion_.transform.scale.y = Ease::OutBack(t);
	motion_.transform.scale.z = Ease::OutBack(t);
	Vector3 one(1.0f, 1.0f, 1.0f);

	pTrapEnemy_->SetObjectPosition(motion_.transform.position);
	pTrapEnemy_->SetObjectRotation(motion_.transform.rotation);
	pTrapEnemy_->SetObjectScale(one * motion_.transform.scale);

	// ãƒ¢ãƒ¼ã‚·ãƒ§ãƒ³ã‚«ã‚¦ãƒ³ãƒˆã‚’æ›´æ–°
	MotionCount(motion_);

	if (!motion_.isActive)
	{
		// ç„¡æ•µçŠ¶æ…‹ã‚’è§£é™¤
		pTrapEnemy_->SetIsInvincible(false);

		// ã‚¹ãƒãƒ¼ãƒ³ãƒ¢ãƒ¼ã‚·ãƒ§ãƒ³ãŒçµ‚äº†ã—ãŸã‚‰ã€æ¬¡ã®çŠ¶æ…‹ã«ç§»è¡Œ
		pTrapEnemy_->ChangeBehaviorState(std::make_unique<TrapEnemyBehaviorMove>(pTrapEnemy_));
	}
}

void TrapEnemyBehaviorSpawn::ResetMotion()
{
}


============================================================
File Path: project/application/Objects/Enemy/BehaviorState/TrapEnemyState/TrapEnemyBehaviorSpawn.h
============================================================
#pragma once

#include "TrapEnemyBehaviorState.h"

/// <summary>
/// ç½ è¨­ç½®åž‹æ•µã®å‡ºç¾çŠ¶æ…‹
/// </summary>
class TrapEnemyBehaviorSpawn : public TrapEnemyBehaviorState
{
public:

	/// <summary>
	/// ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿
	/// </summary>
	/// <param name="_pTrapEnemy">ç½ åž‹æ•µã®ãƒã‚¤ãƒ³ã‚¿</param>
	TrapEnemyBehaviorSpawn(TrapEnemy* _pTrapEnemy);
	
	// åˆæœŸåŒ–
	void Initialize() override;
	
	// æ›´æ–°
	void Update() override;
	
	// ãƒ¢ãƒ¼ã‚·ãƒ§ãƒ³ã®ãƒªã‚»ãƒƒãƒˆ
	void ResetMotion() override;

};



============================================================
File Path: project/application/Objects/Enemy/BehaviorState/TrapEnemyState/TrapEnemyBehaviorState.cpp
============================================================
#include "TrapEnemyBehaviorState.h"

#include "../../TrapEnemy.h"

TrapEnemyBehaviorState::~TrapEnemyBehaviorState()
{
}

void TrapEnemyBehaviorState::MotionCount(Motion& _motion)
{
	if (_motion.count < _motion.maxCount)
	{
		_motion.count++;
	} else
	{
		// ãƒ¢ãƒ¼ã‚·ãƒ§ãƒ³çµ‚äº† ã‚«ã‚¦ãƒ³ãƒˆãƒªã‚»ãƒƒãƒˆ
		_motion.isActive = false;
		_motion.count = 0;
	}
}

void TrapEnemyBehaviorState::TransformUpdate(TrapEnemy* _pEnemy)
{
	if (_pEnemy)
	{
		motion_.transform.position = _pEnemy->GetPosition();
		motion_.transform.rotation = _pEnemy->GetRotation();
		motion_.transform.scale = _pEnemy->GetScale();
	}
}


============================================================
File Path: project/application/Objects/Enemy/BehaviorState/TrapEnemyState/TrapEnemyBehaviorState.h
============================================================
#pragma once

#include <sstream>
#include <Vector3.h>

// å‰æ–¹å®£è¨€
class TrapEnemy;

/// <summary>
/// ç½ åž‹æ•µã®è¡Œå‹•ã‚¹ãƒ†ãƒ¼ãƒˆåŸºåº•ã‚¯ãƒ©ã‚¹
/// è¡Œå‹•ã‚¹ãƒ†ãƒ¼ãƒˆã¯ä»¥ä¸‹ã®5ã¤
/// ãƒ»å‡ºç¾(Spawn)
/// ãƒ»ç§»å‹•(Move)
/// ãƒ»ç½ è¨­ç½®(SetTrap)
/// ãƒ»è¢«å¼¾(HitReact)
/// ãƒ»æ­»äº¡(Dead)
/// </summary>
class TrapEnemyBehaviorState
{
public:
	
	/// <summary>
	/// ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿
	/// </summary>
	/// <param name="_name">ã‚¹ãƒ†ãƒ¼ãƒˆå</param>
	/// <param name="_trapEnemy">ç½ åž‹æ•µã®ãƒã‚¤ãƒ³ã‚¿</param>
	TrapEnemyBehaviorState(const std::string& _name, TrapEnemy* _trapEnemy) : stateName_(_name), pTrapEnemy_(_trapEnemy) {};
	
	virtual ~TrapEnemyBehaviorState();
	
	// åˆæœŸåŒ–
	virtual void Initialize() = 0;
	
	// æ›´æ–°
	virtual void Update() = 0;
	
	// ãƒ¢ãƒ¼ã‚·ãƒ§ãƒ³ã®ãƒªã‚»ãƒƒãƒˆ
	virtual void ResetMotion() = 0;

protected:

	struct Transform
	{
		Vector3 position = { 0.0f, 0.0f, 0.0f };
		Vector3 rotation = { 0.0f, 0.0f, 0.0f };
		Vector3 scale = { 1.0f, 1.0f, 1.0f };
	};

	struct Motion
	{
		// ãƒ¢ãƒ¼ã‚·ãƒ§ãƒ³ãŒã‚¢ã‚¯ãƒ†ã‚£ãƒ–ã‹ã©ã†ã‹
		bool isActive = false;
		// ã‚«ã‚¦ãƒ³ãƒˆ
		uint32_t count = 0;
		// Maxã‚«ã‚¦ãƒ³ãƒˆ
		uint32_t maxCount = 30;
		// ãƒˆãƒ©ãƒ³ã‚¹ãƒ•ã‚©ãƒ¼ãƒ 
		Transform transform;
	};

	// ãƒ¢ãƒ¼ã‚·ãƒ§ãƒ³ã®ã‚«ã‚¦ãƒ³ãƒˆ
	void MotionCount(Motion& _motion);

	// æ•µã®ãƒˆãƒ©ãƒ³ã‚¹ãƒ•ã‚©ãƒ¼ãƒ ã‚’motion_.transformã«ã‚»ãƒƒãƒˆ
	void TransformUpdate(TrapEnemy* _pEnemy);

	std::string stateName_;
	TrapEnemy* pTrapEnemy_ = nullptr;

	Motion motion_;

};



============================================================
File Path: project/application/Objects/Enemy/Bullet/EnemyBullet.cpp
============================================================
#include "EnemyBullet.h"
#include "TimeManager.h"

void EnemyBullet::Initialize()
{
	// --- 3Dã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ ---
	object_ = std::make_unique<Object3d>();
	object_->Initialize("enemyBullet.obj");

	object_->SetPosition(position_);
	object_->SetRotate(rotation_);
	scale_ = { 0.7f,0.7f,0.7f };
	object_->SetScale(scale_);

	object_->SetLighting(true);

	// å½“ãŸã‚Šåˆ¤å®š
	colliderManager_ = ColliderManager::GetInstance();
	objectName_ = "EnemyBullet";

	desc =
	{
		//ã“ã“ã«è¨­å®š
		.owner = this,
		.colliderID = objectName_,
		.shape = Shape::AABB,
		.shapeData = &aabb_,
		.attribute = colliderManager_->GetNewAttribute(objectName_),
		.onCollisionTrigger = std::bind(&EnemyBullet::OnCollisionTrigger, this, std::placeholders::_1),
	};
	collider_.MakeAABBDesc(desc);
	colliderManager_->RegisterCollider(&collider_);

}

void EnemyBullet::Finalize()
{
	colliderManager_->DeleteCollider(&collider_);
}

void EnemyBullet::Update()
{
	const float dt = TimeManager::Instance().GetDeltaTime();

	UpdateModel();

	rotation_ += { 0.1f * dt * kDefaultFrameRate, 0.1f * dt * kDefaultFrameRate, 0.0f };
	position_ += velocity_ * dt;

	aabb_.min = position_ - object_->GetScale();
	aabb_.max = position_ + object_->GetScale();
	collider_.SetPosition(position_);

	// æ®‹ã‚Šå¯¿å‘½ã«å¿œã˜ã¦ã‚¹ã‚±ãƒ¼ãƒ«ã‚’å°ã•ãã™ã‚‹
	float lifeRatio = std::clamp(deathRemainingSeconds_ / (kLifeTime / kDefaultFrameRate), 0.0f, 1.0f);
	scale_ = { 0.7f * lifeRatio, 0.7f * lifeRatio, 0.7f * lifeRatio };


	//æ™‚é–“çµŒéŽã§ãƒ‡ã‚¹
	deathRemainingSeconds_ -= dt;
	if (deathRemainingSeconds_ <= 0.0f)
	{
		isDead_ = true;
	}
}

void EnemyBullet::Draw()
{
	object_->Draw();
}

void EnemyBullet::Draw2D()
{
}

void EnemyBullet::ImGuiDraw()
{
#ifdef USE_IMGUI

	ImGui::Begin("EnemyBullet");

	ImGui::SliderFloat3("position", &position_.x, -30.0f, 30.0f);
	ImGui::SliderFloat3("rotation", &rotation_.x, -3.14f, 3.14f);
	ImGui::SliderFloat3("scale", &scale_.x, 0.0f, 10.0f);

	ImGui::End();

#endif // USE_IMGUI
}

void EnemyBullet::UpdateModel()
{
	object_->Update();

	object_->SetPosition(position_);
	object_->SetRotate(rotation_);
	object_->SetScale(scale_);
}

void EnemyBullet::OnCollisionTrigger(const Collider* _other)
{
	if (!_other->GetOwner()->IsActive() && 
		(_other->GetColliderID() == "Player" or
		_other->GetColliderID() == "PlayerBullet" or
		_other->GetColliderID() == "Wall" or
		_other->GetColliderID() == "TrapEnemy" or
		_other->GetColliderID() == "Barrie"))
	{
		ParticleEmitter::Emit("BltReaction", position_, 1);
		isDead_ = true;
	} 
}


============================================================
File Path: project/application/Objects/Enemy/Bullet/EnemyBullet.h
============================================================
#pragma once

#include "../../../baseObject/GameObject.h"
#include"../../../../gameEngine/collider/ColliderManager.h"
#include "../../../../gameEngine/particle/ParticleEmitter.h"

#include <Object3d.h>

/// <summary>
/// æ•µã®å¼¾ã‚¯ãƒ©ã‚¹
/// </summary>
class EnemyBullet : public GameObject
{
public:
	EnemyBullet() = default;
	~EnemyBullet() = default;

	// åˆæœŸåŒ–
	void Initialize() override;
	
	// çµ‚äº†
	void Finalize() override;
	
	// æ›´æ–°
	void Update() override;
	
	// æç”»
	void Draw() override;
	
	// ã‚¹ãƒ—ãƒ©ã‚¤ãƒˆæç”»
	void Draw2D();
	
	// ImGui
	void ImGuiDraw();

	// ãƒ¢ãƒ‡ãƒ«æ›´æ–°
	void UpdateModel();

private: // è¡çªåˆ¤å®š
	
	/// <summary>
	/// è¡çªæ™‚å‡¦ç†
	/// </summary>
	/// <param name="_other">è¡çªç›¸æ‰‹ã®ã‚³ãƒ©ã‚¤ãƒ€ãƒ¼</param>
	void OnCollisionTrigger(const Collider* _other);

public: // ã‚»ãƒƒã‚¿ãƒ¼

	/// <summary>
	/// é€Ÿåº¦è¨­å®š
	/// </summary>
	/// <param name="_velocity">é€Ÿåº¦ãƒ™ã‚¯ãƒˆãƒ«</param>
	/// <returns>è¨­å®šå¾Œã®é€Ÿåº¦ãƒ™ã‚¯ãƒˆãƒ«</returns>
	Vector3 SetVelocity(const Vector3 _velocity)
	{ 
		velocity_ = _velocity * kDefaultFrameRate;
		return velocity_;
	}

private: // ãƒ¡ãƒ³ãƒå¤‰æ•°

	// ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆãƒ•ãƒ¬ãƒ¼ãƒ ãƒ¬ãƒ¼ãƒˆ
	static constexpr float kDefaultFrameRate = 60.0f;

	// 3Dã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ
	std::unique_ptr<Object3d> object_ = nullptr;
	
	// å½“ãŸã‚Šåˆ¤å®šé–¢ä¿‚
	ColliderManager* colliderManager_ = nullptr;
	Collider collider_;
	AABB aabb_;
	Collider::ColliderDesc desc = {};
	
	// é€Ÿåº¦
	Vector3 velocity_{};
	
	// å¯¿å‘½
	static const uint32_t kLifeTime = 60 * 3;

	// ãƒ‡ã‚¹ã‚¿ã‚¤ãƒžãƒ¼
	float deathRemainingSeconds_ = kLifeTime / kDefaultFrameRate;

};



============================================================
File Path: project/application/Objects/Enemy/Bullet/TimeBomb.cpp
============================================================
#include "TimeBomb.h"

#include <numbers>

#include "TimeManager.h"

void TimeBomb::Initialize()
{
	// --- 3Dã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ ---
	object_ = std::make_unique<Object3d>();
	object_->Initialize("bomb.obj");

	object_->SetPosition(position_);
	object_->SetRotate(rotation_);
	scale_ = { 0.7f, 0.7f, 0.7f };
	object_->SetScale(scale_);
	// ãƒ©ã‚¤ãƒˆè¨­å®š
	//object_->SetDirectionalLightEnable(true);
	object_->SetLighting(true);

	// å½“ãŸã‚Šåˆ¤å®š
	colliderManager_ = ColliderManager::GetInstance();
	
	// è¨­ç½®åˆ¤å®šç”¨
	objectName_ = "SetTimeBomb";
	setDesc =
	{
		//ã“ã“ã«è¨­å®š
		.owner = this,
		.colliderID = objectName_,
		.shape = Shape::AABB,
		.shapeData = &setAABB_,
		.attribute = colliderManager_->GetNewAttribute(objectName_),
		.onCollision = std::bind(&TimeBomb::OnSetCollision, this, std::placeholders::_1),
		.onCollisionTrigger = std::bind(&TimeBomb::OnSetCollisionTrigger, this, std::placeholders::_1),
	};
	setCollider_.MakeAABBDesc(setDesc);
	colliderManager_->RegisterCollider(&setCollider_);
	
	// çˆ†ç™ºåˆ¤å®šç”¨
	explosionObjectName_ = "ExplosionTimeBomb";
	explosionDesc =
	{
		//ã“ã“ã«è¨­å®š
		.owner = this,
		.colliderID = explosionObjectName_,
		.shape = Shape::AABB,
		.shapeData = &explosionAABB_,
		.attribute = colliderManager_->GetNewAttribute(explosionObjectName_),
		.onCollisionTrigger = std::bind(&TimeBomb::OnExplosionTrigger, this, std::placeholders::_1),
	};
	explosionCollider_.MakeAABBDesc(explosionDesc);
	colliderManager_->RegisterCollider(&explosionCollider_);


	// æ¶ˆæ»…æ™‚ã®å‹•ä½œåˆæœŸåŒ–
	deathMotion_.isActive = false;
	deathMotion_.timer = 0.0f;
}

void TimeBomb::Finalize()
{
	colliderManager_->DeleteCollider(&setCollider_);
	colliderManager_->DeleteCollider(&explosionCollider_);
}

void TimeBomb::Update()
{
	// ãƒ‡ãƒ«ã‚¿ã‚¿ã‚¤ãƒ å–å¾—
	const float dt = TimeManager::Instance().GetDeltaTime();

	// ç€å¼¾ã—ã¦ã„ãªã‘ã‚Œã°åˆ¤å®šã‚’ä»˜ã‘ãªã„
	isActive_ = !isLaunchingTrap_;

	// ç‰©ç†æŒ™å‹•ï¼ˆæ”¾ç‰©ç·šé‹å‹•ï¼‰
	if (isLaunchingTrap_) 
	{
		// é‡åŠ›åŠ é€Ÿåº¦
		const float gravity = -9.8f;

		// é€Ÿåº¦ã«é‡åŠ›ã‚’åŠ ç®—
		velocity_.y += gravity * dt;

		// ä½ç½®ã‚’é€Ÿåº¦ã§æ›´æ–°
		position_ += velocity_ * dt;
	}

	if ((position_ - landingPosition_).Length() < 0.1f or position_.y <= 0.5f)
	{
		isLaunchingTrap_ = false;
	}
	else
	{
		// åœ°é¢ã«åŸ‹ã¾ã‚‰ãªã„ã‚ˆã†ã«ã™ã‚‹
		if (position_.y < 0.5f)
		{
			position_.y = 0.5f;
			velocity_.y = 0.0f; // Yæ–¹å‘ã®é€Ÿåº¦ã‚’ãƒªã‚»ãƒƒãƒˆ
		}
	}

	// å£ã¨ã®åå°„ã‚¯ãƒ¼ãƒ«ã‚¿ã‚¤ãƒ 
	if (wallCollisionCooldown_ > 0)
	{
		// ãƒ•ãƒ¬ãƒ¼ãƒ æ•°ã«å¤‰æ›
		int framesToDecrement = std::max(1, static_cast<int>(dt * 60.0f + 0.5f));

		// ã‚¯ãƒ¼ãƒ«ã‚¿ã‚¤ãƒ ã‚’ãƒ‡ã‚¯ãƒªãƒ¡ãƒ³ãƒˆ
		if (wallCollisionCooldown_ > 0)
		{
			if (framesToDecrement >= static_cast<int>(wallCollisionCooldown_)) wallCollisionCooldown_ = 0;
			else wallCollisionCooldown_ -= framesToDecrement;
		}
	}

	if (wallCollisionCooldown_ <= 0 && isWallCollision_)
	{
		// å£ã«è¡çªã—ãŸå ´åˆã®å‡¦ç†
		ReflectOnWallCollision();
		wallCollisionCooldown_ = 1;
		isWallCollision_ = false;
	}

	// æ¶ˆæ»…ãƒ¢ãƒ¼ã‚·ãƒ§ãƒ³æ›´æ–°
	DeadMotion();

	// ãƒ¢ãƒ‡ãƒ«æ›´æ–°
	UpdateModel();
	
	// å›žè»¢æ›´æ–°
	rotation_ += {0.1f * (dt * kDefaultFrameRate), 0.1f * (dt * kDefaultFrameRate), 0.0f};
	
	// è¨­ç½®åˆ¤å®šã®æ›´æ–°
	setAABB_.min = position_ - object_->GetScale();
	setAABB_.max = position_ + object_->GetScale();
	setCollider_.SetPosition(position_);
	// çˆ†ç™ºåˆ¤å®šã®æ›´æ–°
	explosionAABB_.min = position_ - object_->GetScale();
	explosionAABB_.max = position_ + object_->GetScale();
	explosionCollider_.SetPosition(position_);
	
}

void TimeBomb::Draw()
{
	if (!isExploded_)
	{
		object_->Draw();
	}
}

void TimeBomb::ImGuiDraw()
{
}

void TimeBomb::UpdateModel()
{
	object_->Update();

	object_->SetPosition(position_);
	object_->SetRotate(rotation_);
	object_->SetScale(scale_);
}

void TimeBomb::LaunchTrap()
{
	isLaunchingTrap_ = true;

	// é‡åŠ›åŠ é€Ÿåº¦
	const float gravity = -9.8f;

	// XYã®å·®åˆ†
	Vector3 diff = landingPosition_ - position_;

	// XZæ–¹å‘ã®åˆé€Ÿåº¦
	velocity_.x = diff.x / flightTime_;
	velocity_.z = diff.z / flightTime_;

	// Yæ–¹å‘ã®åˆé€Ÿåº¦ï¼ˆæ”¾ç‰©ç·šã®ãŸã‚ã«åŠ é€Ÿåº¦ã‚’è€ƒæ…®ï¼‰
	velocity_.y = (diff.y - 0.5f * gravity * flightTime_ * flightTime_) / flightTime_;
}

void TimeBomb::DeadMotion()
{
	// ãƒ•ãƒ©ã‚°ãŒç«‹ã£ã¦ã„ãªã‘ã‚Œã°å‡¦ç†ã—ãªã„
	if (!deathMotion_.isActive)
	{
		return;
	}

	// ãƒ‡ãƒ«ã‚¿ã‚¿ã‚¤ãƒ å–å¾—
	const float dt = TimeManager::Instance().GetDeltaTime();

	// ã‚¿ã‚¤ãƒžãƒ¼æ›´æ–°
	deathMotion_.timer += dt;
	deathMotion_.motionPos = position_;

	// æŒ¯å‹•å‡¦ç†
	float vibration = sinf(deathMotion_.timer * kVibrationFreq) * kVibrationAmp;

	// ä½ç½®ã«æŒ¯å‹•ã‚’åŠ ç®—
	position_.x = deathMotion_.motionPos.x + vibration;
	position_.z = deathMotion_.motionPos.z + vibration;

	// ã‚¹ã‚±ãƒ¼ãƒ«ã‚’å¾ã€…ã«ç¸®å°
	scale_ *= kShrinkFactor;

	// ä¸€å®šä»¥ä¸‹ã«ãªã£ãŸã‚‰æ¶ˆæ»…å‡¦ç†å®Œäº†
	if (scale_.x < kEndScale && scale_.y < kEndScale && scale_.z < kEndScale)
	{
		isDead_ = true;
	}

}

void TimeBomb::OnSetCollisionTrigger(const Collider* _other)
{
	// ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã€ãƒŽãƒ¼ãƒžãƒ«ã‚¨ãƒãƒŸãƒ¼ã€ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®å¼¾ã¨è¡çªã—ãŸå ´åˆ
	if (isActive_ && (_other->GetColliderID() == "Player" or 
		_other->GetColliderID() == "NormalEnemy"))
	{
		// çˆ†ç™ºçŠ¶æ…‹ã¸
		isExploded_ = true;
	}

	if (_other->GetColliderID() == "PlayerBullet")
	{
		deathMotion_.isActive = true;
	}

}

void TimeBomb::OnSetCollision(const Collider* _other)
{
	if (_other->GetColliderID() == "Wall" or
		_other->GetColliderID() == "Barrie")
	{
		collisionWallAABB_ = *_other->GetAABB();
		isWallCollision_ = true;
	}

	if (_other->GetColliderID() == "TrapEnemy" or
		_other->GetColliderID() == "VignetteTrap" or
		_other->GetColliderID() == "SetTimeBomb")
	{
		const AABB* otherAABB = _other->GetAABB();

		if (otherAABB && IsAABBOverlap(setAABB_, *otherAABB))
		{
			CorrectOverlap(*otherAABB, setAABB_, position_);
		}
	}

}

void TimeBomb::OnExplosionTrigger(const Collider* _other)
{
	if (isExploded_ &&
		(_other->GetColliderID() == "Player" or 
			_other->GetColliderID() == "NormalEnemy"))
	{
		isDead_ = true;
		// ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«èµ·å‹•
		ParticleEmitter::Emit("explosionGroup", position_, 6);
	}
}

void TimeBomb::Explode()
{
	// çˆ†ç™ºå‡¦ç†
	if (isExploded_)
	{
		// ãƒ‡ãƒ«ã‚¿ã‚¿ã‚¤ãƒ å–å¾—
		const float dt = TimeManager::Instance().GetDeltaTime();

		// scaleã‚’å¾ã€…ã«å¤§ããã—ã¦åˆ¤å®šã‚’åºƒã’ã‚‹
		elapsedTime += dt;

		// çµŒéŽå‰²åˆï¼ˆ0.0ã€œ1.0ï¼‰
		float t = std::clamp(elapsedTime / duration, 0.0f, 1.0f);

		// Lerpã§ã‚¹ã‚±ãƒ¼ãƒ«è£œé–“
		currentScale = Lerp(startScale, endScale, t);

		// ã‚¹ã‚±ãƒ¼ãƒ«ã‚’é©ç”¨
		SetScale(currentScale); // ã‚ãªãŸã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆç”¨é–¢æ•°

		// çˆ†ç™ºå¾Œã¯ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’å‰Šé™¤
		isDead_ = true;
	}
}

void TimeBomb::ReflectOnWallCollision()
{

	// é‡ãªã‚Šè£œæ­£ã¨åŒã˜ãã€è»¸ã”ã¨ã®é‡ãªã‚Šé‡ã‚’èª¿ã¹ã‚‹
	float overlapLeftX = collisionWallAABB_.max.x - setAABB_.min.x;
	float overlapRightX = setAABB_.max.x - collisionWallAABB_.min.x;
	float correctionX = (overlapLeftX < overlapRightX) ? overlapLeftX : -overlapRightX;

	float overlapBackZ = collisionWallAABB_.max.z - setAABB_.min.z;
	float overlapFrontZ = setAABB_.max.z - collisionWallAABB_.min.z;
	float correctionZ = (overlapBackZ < overlapFrontZ) ? overlapBackZ : -overlapFrontZ;

	float absX = std::abs(correctionX);
	float absZ = std::abs(correctionZ);

	// ç›®æ¨™åœ°ç‚¹ã‚’åè»¢
	if (absX <= absZ)
	{
		landingPosition_.x = position_.x + (position_.x - landingPosition_.x);
		// å£ã®å¤–å´ã«ååˆ†æŠ¼ã—å‡ºã™
		position_.x += (correctionX + (correctionX > 0 ? 0.5f : -0.5f));
	} else
	{
		landingPosition_.z = position_.z + (position_.z - landingPosition_.z);
		// å£ã®å¤–å´ã«ååˆ†æŠ¼ã—å‡ºã™
		position_.z += (correctionZ + (correctionZ > 0 ? 0.5f : -0.5f));
	}

	// ã“ã“ã§æ–°ã—ã„æ”¾ç‰©ç·šé‹å‹•ã‚’å†è¨ˆç®—
	LaunchTrap();
}

void TimeBomb::SetTrapLandingPosition(const Vector3& _playerPosition)
{
	// ãƒ©ãƒ³ãƒ€ãƒ ãªè§’åº¦ï¼ˆ0ã€œ2Ï€ï¼‰
	float angle = static_cast<float>(rand()) / RAND_MAX * std::numbers::pi_v<float> *2.0f;

	// ãƒ©ãƒ³ãƒ€ãƒ ãªåŠå¾„ï¼ˆ2.5ã€œ4.0ï¼‰
	float radius = 2.5f + static_cast<float>(rand()) / RAND_MAX * 1.5f;

	// ã‚ªãƒ•ã‚»ãƒƒãƒˆã‚’è¨ˆç®—ï¼ˆXZå¹³é¢ï¼‰
	Vector3 offset;
	offset.x = std::cos(angle) * radius;
	offset.z = std::sin(angle) * radius;
	offset.y = 0.0f;

	// ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®ä½ç½®ã«ã‚ªãƒ•ã‚»ãƒƒãƒˆã‚’åŠ ãˆã€Yåº§æ¨™ã‚’0.5ã«
	landingPosition_ = _playerPosition + offset;
	landingPosition_.y = 0.5f;
}


============================================================
File Path: project/application/Objects/Enemy/Bullet/TimeBomb.h
============================================================
#pragma once

#include "../../../baseObject/GameObject.h"
#include"../../../../gameEngine/collider/ColliderManager.h"
#include "../../../gameEngine/particle/ParticleEmitter.h"

#include <Object3d.h>

/// <summary>
/// æ™‚é™çˆ†å¼¾
/// </summary>
class TimeBomb : public GameObject
{
public:

	TimeBomb() = default;
	~TimeBomb() = default;

	// åˆæœŸåŒ–
	void Initialize() override;

	// çµ‚äº†
	void Finalize() override;

	// æ›´æ–°
	void Update() override;

	// æç”»
	void Draw() override;

	// ImGui
	void ImGuiDraw();

	// ãƒ¢ãƒ‡ãƒ«æ›´æ–°
	void UpdateModel();

	// æ”¾ç‰©ç·šä¸Šã«ç™ºå°„
	void LaunchTrap();

public: // å†…éƒ¨é–¢æ•°

	// æ¶ˆæ»…æ™‚ã®ãƒªã‚¢ã‚¯ã‚·ãƒ§ãƒ³
	void DeadMotion();

private:

	/// <summary>
	/// è¡çªå‡¦ç†
	/// </summary>
	/// <param name="_other">è¡çªç›¸æ‰‹ã®ã‚³ãƒ©ã‚¤ãƒ€ãƒ¼</param>
	void OnSetCollisionTrigger(const Collider* _other);
	
	/// <summary>
	/// è¡çªä¸­å‡¦ç†
	/// </summary>
	/// <param name="_other">è¡çªç›¸æ‰‹ã®ã‚³ãƒ©ã‚¤ãƒ€ãƒ¼</param>
	void OnSetCollision(const Collider* _other);
	
	/// <summary>
	/// è¡çªæ™‚å‡¦ç†
	/// </summary>
	/// <param name="_other">è¡çªç›¸æ‰‹ã®ã‚³ãƒ©ã‚¤ãƒ€ãƒ¼</param>
	void OnExplosionTrigger(const Collider* _other);


	// çˆ†ç™ºå‡¦ç†
	void Explode();

	// å£ã¨ã®åç™ºå‡¦ç†
	void ReflectOnWallCollision();

public: // ã‚²ãƒƒã‚¿ãƒ¼

public: // ã‚»ãƒƒã‚¿ãƒ¼

	/// <summary>
	/// é€Ÿåº¦è¨­å®š
	/// </summary>
	/// <param name="_velocity">é€Ÿåº¦ãƒ™ã‚¯ãƒˆãƒ«</param>
	/// <returns>è¨­å®šã—ãŸé€Ÿåº¦ãƒ™ã‚¯ãƒˆãƒ«</returns>
	Vector3 SetVelocity(const Vector3 _velocity) { return velocity_ = _velocity; }

	/// <summary>
	/// ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®å‘¨å›²ã®åº§æ¨™ã‚’è¨­å®š
	/// </summary>
	/// <param name="_playerPosition">ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®ä½ç½®</param>
	void SetTrapLandingPosition(const Vector3& _playerPosition);

private:

	// æ¶ˆæ»…æ™‚ã®å‹•ä½œæ§‹é€ ä½“
	struct DeathMotion
	{
		bool isActive = false;
		float timer = 0.0f;
		Vector3 motionPos = {};
	};

	// æ¶ˆæ»…ãƒ¢ãƒ¼ã‚·ãƒ§ãƒ³èª¿æ•´ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ãƒ¼
	static constexpr float kVibrationFreq = 200.0f;    // æŒ¯å‹•å‘¨æ³¢æ•°
	static constexpr float kVibrationAmp = 0.2f;     // æŒ¯å‹•å¹…(Â±px)

	static constexpr float kShrinkFactor = 0.92f;    // ç¸®å°çŽ‡(æŒ‡æ•°æ¸›è¡°)
	static constexpr float kEndScale = 0.05f;    // æ¶ˆæ»…åˆ¤å®šã‚¹ã‚±ãƒ¼ãƒ«
	// æ¶ˆæ»…æ™‚ã®å‹•ä½œ
	DeathMotion deathMotion_{};

	// ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã®ãƒ•ãƒ¬ãƒ¼ãƒ ãƒ¬ãƒ¼ãƒˆ
	const float kDefaultFrameRate = 60.0f;

	// 3Dã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ
	std::unique_ptr<Object3d> object_ = nullptr;

	// å½“ãŸã‚Šåˆ¤å®šé–¢ä¿‚
	ColliderManager* colliderManager_ = nullptr;
	// è¨­ç½®åˆ¤å®š
	Collider setCollider_;
	AABB setAABB_;
	Collider::ColliderDesc setDesc = {};
	// çˆ†ç™ºåˆ¤å®š
	std::string explosionObjectName_;
	Collider explosionCollider_;
	AABB explosionAABB_;
	Collider::ColliderDesc explosionDesc = {};


	// çˆ†ç™ºãƒ•ãƒ©ã‚°
	bool isExploded_ = false;
	// åˆæœŸã‚¹ã‚±ãƒ¼ãƒ«ã¨ç›®æ¨™ã‚¹ã‚±ãƒ¼ãƒ«
	Vector3 startScale = { 1.0f, 1.0f, 1.0f };
	Vector3 endScale = { 2.0f, 2.0f, 2.0f };
	// çµŒéŽæ™‚é–“ã¨ã‚¹ã‚±ãƒ¼ãƒ«
	float elapsedTime = 0.0f;
	float duration = 1.0f; // 1ç§’é–“
	Vector3 currentScale;

	// ç›¸æ‰‹ã®HP
	float anyHP_ = 0.0f;

	// å£ã¨ã®è¡çªãƒ•ãƒ©ã‚°
	bool isWallCollision_ = false;
	// è¡çªã—ãŸå£ã®AABB
	AABB collisionWallAABB_;
	// åå°„ã®ã‚¯ãƒ¼ãƒ«ã‚¿ã‚¤ãƒ 
	uint32_t wallCollisionCooldown_ = 0;

	// ç€å¼¾åœ°ç‚¹
	Vector3 landingPosition_{};
	// é€Ÿåº¦
	Vector3 velocity_{};
	// ç™ºå°„ä¸­ãƒ•ãƒ©ã‚°
	bool isLaunchingTrap_ = false; 
	// ç€å¼¾ã¾ã§ã®æ™‚é–“
	float flightTime_ = 1.0f;


};



============================================================
File Path: project/application/Objects/Enemy/Bullet/VignetteTrap.cpp
============================================================
#include "VignetteTrap.h"

#include <numbers>

#include "TimeManager.h"

void VignetteTrap::Initialize()
{
	// --- 3Dã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ ---
	object_ = std::make_unique<Object3d>();
	object_->Initialize("vignette.obj");

	object_->SetPosition(position_);
	object_->SetRotate(rotation_);
	scale_ = { 0.7f,0.7f,0.7f };
	object_->SetScale(scale_);
	// ãƒ©ã‚¤ãƒˆè¨­å®š
	object_->SetLighting(true);

	// å½“ãŸã‚Šåˆ¤å®š
	colliderManager_ = ColliderManager::GetInstance();
	objectName_ = "VignetteTrap";

	desc =
	{
		//ã“ã“ã«è¨­å®š
		.owner = this,
		.colliderID = objectName_,
		.shape = Shape::AABB,
		.shapeData = &aabb_,
		.attribute = colliderManager_->GetNewAttribute(objectName_),
		.onCollision = std::bind(&VignetteTrap::OnCollision, this, std::placeholders::_1),
		.onCollisionTrigger = std::bind(&VignetteTrap::OnCollisionTrigger, this, std::placeholders::_1),
	};
	collider_.MakeAABBDesc(desc);
	colliderManager_->RegisterCollider(&collider_);


	// æ¶ˆæ»…æ™‚ã®å‹•ä½œåˆæœŸåŒ–
	deathMotion_.isActive = false;
	deathMotion_.timer = 0.0f;

}

void VignetteTrap::Finalize()
{
	colliderManager_->DeleteCollider(&collider_);
}

void VignetteTrap::Update()
{
	// ãƒ‡ãƒ«ã‚¿ã‚¤ãƒ å–å¾—
	const float dt = TimeManager::Instance().GetDeltaTime();

	// ç€å¼¾ã—ã¦ã„ãªã‘ã‚Œã°åˆ¤å®šã‚’ä»˜ã‘ãªã„
	isActive_ = !isLaunchingTrap_;

	// ç‰©ç†æŒ™å‹•ï¼ˆæ”¾ç‰©ç·šé‹å‹•ï¼‰
	if (isLaunchingTrap_)
	{
		// é‡åŠ›åŠ é€Ÿåº¦
		const float gravity = -9.8f;

		// é€Ÿåº¦ã«é‡åŠ›ã‚’åŠ ç®—
		velocity_.y += gravity * dt;
		// ä½ç½®ã‚’é€Ÿåº¦ã§æ›´æ–°
		position_ += velocity_ * dt;
	}
	else
	{
		// åœ°é¢ã«åŸ‹ã¾ã‚‰ãªã„ã‚ˆã†ã«ã™ã‚‹
		if (position_.y < 0.5f)
		{
			position_.y = 0.5f;
			velocity_.y = 0.0f; // Yæ–¹å‘ã®é€Ÿåº¦ã‚’ãƒªã‚»ãƒƒãƒˆ
		}
	}

	if ((position_ - landingPosition_).Length() < 0.1f or position_.y <= 0.5f)
	{
		isLaunchingTrap_ = false;
		velocity_ = { 0.0f, 0.0f, 0.0f }; // ç€å¼¾æ™‚ã«é€Ÿåº¦ã‚’ãƒªã‚»ãƒƒãƒˆ
	}

	// å£ã¨ã®åå°„ã‚¯ãƒ¼ãƒ«ã‚¿ã‚¤ãƒ 
	if (wallCollisionCooldown_ > 0)
	{
		int framesToDecrement = std::max(1, static_cast<int>(dt * 60.0f + 0.5f));

		if (framesToDecrement >= static_cast<int>(wallCollisionCooldown_))
		{
			wallCollisionCooldown_ = 0;
		}
		else
		{
			wallCollisionCooldown_ -= framesToDecrement;
		}
	}

	if (wallCollisionCooldown_ <= 0 && isWallCollision_)
	{
		// å£ã«è¡çªã—ãŸå ´åˆã®å‡¦ç†
		ReflectOnWallCollision();
		wallCollisionCooldown_ = 1;
		isWallCollision_ = false;
	}

	// æ¶ˆæ»…ãƒ¢ãƒ¼ã‚·ãƒ§ãƒ³æ›´æ–°
	DeadMotion();

	UpdateModel();

	rotation_ += {0.1f * dt * kDefaultFrameRate, 0.1f * dt * kDefaultFrameRate, 0.0f};

	aabb_.min = position_ - object_->GetScale();
	aabb_.max = position_ + object_->GetScale();
	collider_.SetPosition(position_);
}

void VignetteTrap::Draw()
{
	object_->Draw();
}

void VignetteTrap::ImGuiDraw()
{
}

void VignetteTrap::UpdateModel()
{
	object_->Update();

	object_->SetPosition(position_);
	object_->SetRotate(rotation_);
	object_->SetScale(scale_);
}

void VignetteTrap::LaunchTrap()
{
	isLaunchingTrap_ = true;

	// é‡åŠ›åŠ é€Ÿåº¦
	const float gravity = -9.8f;

	// XYã®å·®åˆ†
	Vector3 diff = landingPosition_ - position_;

	// XZæ–¹å‘ã®åˆé€Ÿåº¦
	velocity_.x = diff.x / flightTime_;
	velocity_.z = diff.z / flightTime_;

	// Yæ–¹å‘ã®åˆé€Ÿåº¦
	velocity_.y = (diff.y - 0.5f * gravity * flightTime_ * flightTime_) / flightTime_;
}

void VignetteTrap::DeadMotion()
{
	// ãƒ•ãƒ©ã‚°ãŒç«‹ã£ã¦ã„ãªã‘ã‚Œã°å‡¦ç†ã—ãªã„
	if (!deathMotion_.isActive)
	{
		return;
	}

	// ãƒ‡ãƒ«ã‚¿ã‚¿ã‚¤ãƒ å–å¾—
	const float dt = TimeManager::Instance().GetDeltaTime();

	// ã‚¿ã‚¤ãƒžãƒ¼æ›´æ–°
	deathMotion_.timer += dt;
	deathMotion_.motionPos = position_;

	// æŒ¯å‹•å‡¦ç†
	float vibration = sinf(deathMotion_.timer * kVibrationFreq) * kVibrationAmp;

	// ä½ç½®ã«æŒ¯å‹•ã‚’åŠ ç®—
	position_.x = deathMotion_.motionPos.x + vibration;
	position_.z = deathMotion_.motionPos.z + vibration;

	// ã‚¹ã‚±ãƒ¼ãƒ«ã‚’å¾ã€…ã«ç¸®å°
	scale_ *= kShrinkFactor;

	// ä¸€å®šä»¥ä¸‹ã«ãªã£ãŸã‚‰æ¶ˆæ»…å‡¦ç†å®Œäº†
	if (scale_.x < kEndScale && scale_.y < kEndScale && scale_.z < kEndScale)
	{
		isDead_ = true;
	}
}

void VignetteTrap::OnCollisionTrigger(const Collider* _other)
{
	if (!deathMotion_.isActive && isActive_ &&
		(_other->GetColliderID() == "Player" or 
		_other->GetColliderID() == "PlayerBullet" or
		_other->GetColliderID() == "NormalEnemy"))
	{
		// æ­»äº¡
		deathMotion_.isActive = true;
	}
}

void VignetteTrap::OnCollision(const Collider* _other)
{
	if (_other->GetColliderID() == "Wall" or 
		_other->GetColliderID() == "Barrie")
	{
		// åå°„å‡¦ç†ç”¨ã®AABBã‚’å–å¾—
		collisionWallAABB_ = *_other->GetAABB();
		isWallCollision_ = true;
	}

	if (_other->GetColliderID() == "TrapEnemy" or
		_other->GetColliderID() == "VignetteTrap" or
		_other->GetColliderID() == "SetTimeBomb")
	{
		const AABB* otherAABB = _other->GetAABB();

		if (otherAABB)
		{
			CorrectOverlap(*otherAABB, aabb_, position_);
		}
	}
}

void VignetteTrap::ReflectOnWallCollision()
{
	// é‡ãªã‚Šè£œæ­£ã¨åŒã˜ãã€è»¸ã”ã¨ã®é‡ãªã‚Šé‡ã‚’èª¿ã¹ã‚‹
	float overlapLeftX = collisionWallAABB_.max.x - aabb_.min.x;
	float overlapRightX = aabb_.max.x - collisionWallAABB_.min.x;
	float correctionX = (overlapLeftX < overlapRightX) ? overlapLeftX : -overlapRightX;

	float overlapBackZ = collisionWallAABB_.max.z - aabb_.min.z;
	float overlapFrontZ = aabb_.max.z - collisionWallAABB_.min.z;
	float correctionZ = (overlapBackZ < overlapFrontZ) ? overlapBackZ : -overlapFrontZ;

	float absX = std::abs(correctionX);
	float absZ = std::abs(correctionZ);

	// ç›®æ¨™åœ°ç‚¹ã‚’åè»¢
	if (absX <= absZ)
	{
		landingPosition_.x = position_.x + (position_.x - landingPosition_.x);
		// å£ã®å¤–å´ã«ååˆ†æŠ¼ã—å‡ºã™
		position_.x += (correctionX + (correctionX > 0 ? 0.5f : -0.5f));
	} 
	else
	{
		landingPosition_.z = position_.z + (position_.z - landingPosition_.z);
		// å£ã®å¤–å´ã«ååˆ†æŠ¼ã—å‡ºã™
		position_.z += (correctionZ + (correctionZ > 0 ? 0.5f : -0.5f));
	}

	// ã“ã“ã§æ–°ã—ã„æ”¾ç‰©ç·šé‹å‹•ã‚’å†è¨ˆç®—
	LaunchTrap();
}

void VignetteTrap::SetTrapLandingPosition(const Vector3& _playerPosition)
{
	// ãƒ©ãƒ³ãƒ€ãƒ ãªè§’åº¦ï¼ˆ0ã€œ2Ï€ï¼‰
	float angle = static_cast<float>(rand()) / RAND_MAX * std::numbers::pi_v<float> *2.0f;

	// ãƒ©ãƒ³ãƒ€ãƒ ãªåŠå¾„ï¼ˆ2.5ã€œ4.0ï¼‰
	float radius = 2.5f + static_cast<float>(rand()) / RAND_MAX * 1.5f;

	// ã‚ªãƒ•ã‚»ãƒƒãƒˆã‚’è¨ˆç®—ï¼ˆXZå¹³é¢ï¼‰
	Vector3 offset;
	offset.x = std::cos(angle) * radius;
	offset.z = std::sin(angle) * radius;
	offset.y = 0.0f;

	// ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®ä½ç½®ã«ã‚ªãƒ•ã‚»ãƒƒãƒˆã‚’åŠ ãˆã€Yåº§æ¨™ã‚’0.5ã«
	landingPosition_ = _playerPosition + offset;
	landingPosition_.y = 0.5f;
}


============================================================
File Path: project/application/Objects/Enemy/Bullet/VignetteTrap.h
============================================================
#pragma once

#include "../../../baseObject/GameObject.h"
#include"../../../../gameEngine/collider/ColliderManager.h"

#include <Object3d.h>

/// <summary>
/// ãƒ´ã‚£ãƒãƒƒãƒˆãƒˆãƒ©ãƒƒãƒ—
/// ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®å‘¨å›²ã«æ”¾ç‰©ç·šã‚’æã„ã¦é£›ã‚“ã§ã„ããƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã«è¡çªã™ã‚‹ã¨çˆ†ç™ºã™ã‚‹ç½ 
/// </summary>
class VignetteTrap : public GameObject
{
public:

	VignetteTrap() = default;
	~VignetteTrap() = default;

	// åˆæœŸåŒ–
	void Initialize() override;
	
	// çµ‚äº†
	void Finalize() override;
	
	// æ›´æ–°
	void Update() override;
	
	// æç”»
	void Draw() override;
	
	// ImGui
	void ImGuiDraw();

	// ãƒ¢ãƒ‡ãƒ«æ›´æ–°
	void UpdateModel();

	// æ”¾ç‰©ç·šä¸Šã«ç™ºå°„
	void LaunchTrap();

public: // å†…éƒ¨é–¢æ•°

	// æ¶ˆæ»…æ™‚ã®ãƒªã‚¢ã‚¯ã‚·ãƒ§ãƒ³
	void DeadMotion();

private: // è¡çªåˆ¤å®š

	/// <summary>
	/// è¡çªæ™‚å‡¦ç†
	/// </summary>
	/// <param name="_other>è¡çªç›¸æ‰‹ã®ã‚³ãƒ©ã‚¤ãƒ€ãƒ¼</param>
	void OnCollisionTrigger(const Collider* _other);

	/// <summary>
	/// è¡çªä¸­å‡¦ç†
	/// </summary>
	/// <param name="_other">è¡çªç›¸æ‰‹ã®ã‚³ãƒ©ã‚¤ãƒ€ãƒ¼</param>
	void OnCollision(const Collider* _other);

	// å£ã¨ã®åç™ºå‡¦ç†
	void ReflectOnWallCollision();

public: // ã‚²ãƒƒã‚¿ãƒ¼


public: // ã‚»ãƒƒã‚¿ãƒ¼

	/// <summary>
	/// é€Ÿåº¦è¨­å®š
	/// </summary>
	/// <param name="_velocity">é€Ÿåº¦ãƒ™ã‚¯ãƒˆãƒ«</param>
	/// <returns></returns>
	Vector3 SetVelocity(const Vector3 _velocity) { return velocity_ = _velocity; }

	// ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®å‘¨å›²ã®åº§æ¨™ã‚’è¨­å®š
	void SetTrapLandingPosition(const Vector3& _playerPosition);

private:

	// æ¶ˆæ»…æ™‚ã®å‹•ä½œæ§‹é€ ä½“
	struct DeathMotion
	{
		bool isActive = false;
		float timer = 0.0f;
		Vector3 motionPos = {};
	};

	// æ¶ˆæ»…ãƒ¢ãƒ¼ã‚·ãƒ§ãƒ³èª¿æ•´ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ãƒ¼
	static constexpr float kVibrationFreq = 200.0f;    // æŒ¯å‹•å‘¨æ³¢æ•°
	static constexpr float kVibrationAmp = 0.2f;     // æŒ¯å‹•å¹…(Â±px)

	static constexpr float kShrinkFactor = 0.92f;    // ç¸®å°çŽ‡(æŒ‡æ•°æ¸›è¡°)
	static constexpr float kEndScale = 0.05f;    // æ¶ˆæ»…åˆ¤å®šã‚¹ã‚±ãƒ¼ãƒ«
	// æ¶ˆæ»…æ™‚ã®å‹•ä½œ
	DeathMotion deathMotion_{};

	// ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã®ãƒ•ãƒ¬ãƒ¼ãƒ ãƒ¬ãƒ¼ãƒˆ
	const float kDefaultFrameRate = 60.0f;

	// 3Dã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ
	std::unique_ptr<Object3d> object_ = nullptr;

	// å½“ãŸã‚Šåˆ¤å®šé–¢ä¿‚
	ColliderManager* colliderManager_ = nullptr;
	Collider collider_;
	AABB aabb_;
	Collider::ColliderDesc desc = {};
	
	// å£ã¨ã®è¡çªãƒ•ãƒ©ã‚°
	bool isWallCollision_ = false;
	// è¡çªã—ãŸå£ã®AABB
	AABB collisionWallAABB_;
	// åå°„ã®ã‚¯ãƒ¼ãƒ«ã‚¿ã‚¤ãƒ 
	uint32_t wallCollisionCooldown_ = 0;

	// ç€å¼¾åœ°ç‚¹
	Vector3 landingPosition_{};
	// é€Ÿåº¦
	Vector3 velocity_{};
	// ç™ºå°„ä¸­ãƒ•ãƒ©ã‚°
	bool isLaunchingTrap_ = false;
	// ç€å¼¾ã¾ã§ã®æ™‚é–“
	float flightTime_ = 1.0f;
	
	
};



============================================================
File Path: project/application/Objects/Enemy/EnemyManager.cpp
============================================================
#include "EnemyManager.h"

#include "waveState/EnemyWaveStage1.h"
#include "waveState/EnemyWaveStage2.h"

#include "TimeManager.h"

void EnemyManager::Initialize()
{
	// ã‚¨ãƒ‡ã‚£ã‚¿èª­ã¿è¾¼ã¿
	auto levelData = std::make_shared<LevelData>();
	levelData = LevelDataLoader::LoadLevelData("enemySpawn");
	SetLevelData(levelData);

	// ã‚¦ã‚§ãƒ¼ãƒ–ã‚¹ãƒ†ãƒ¼ãƒˆ
	ChangeState(std::make_unique<EnemyWaveStage1>(this));
}

void EnemyManager::Finalize()
{
	for (auto& enemy : pTrapEnemies_)
	{
		enemy->Finalize();
	}

	for (auto& enemy : pNormalEnemies_)
	{
		enemy->Finalize();
	}

	for(auto& corruptor : pCorruptors_)
	{
		corruptor->Finalize();
	}
}

void EnemyManager::Update()
{
	// ãƒ‡ãƒ«ã‚¿ã‚¿ã‚¤ãƒ å–å¾—
	const float dt = TimeManager::Instance().GetDeltaTime();
	// ã‚¢ãƒƒãƒ—ãƒ‡ãƒ¼ãƒˆã™ã‚‹ãƒ•ãƒ¬ãƒ¼ãƒ æ•°è¨ˆç®—
	const int framesThisUpdate = std::max(1, static_cast<int>(dt * 60.0f + 0.5f));

	// ãƒŽãƒ¼ãƒžãƒ«ã‚¨ãƒãƒŸãƒ¼ã®æ›´æ–°
	for (auto& enemy : pNormalEnemies_)
	{
		enemy->SetPlayerPosition(playerPosition_);
		enemy->Update();
		toPlayerDistance_.push_back(enemy->GetToPlayer());
	}

	// isDeat ãŒãŸã£ãŸã‚‰å‰Šé™¤
	pNormalEnemies_.erase(
		std::remove_if(
			pNormalEnemies_.begin(),
			pNormalEnemies_.end(),
			[this](std::unique_ptr<NormalEnemy>& enemy)
			{
				if (enemy->IsDead())
				{
					enemy->Finalize();

					// æ•µã®ã‚«ã‚¦ãƒ³ãƒˆã‚’æ¸›ã‚‰ã™
					enemyCount_--;

					return true;
				}
				return false;
			}),
		pNormalEnemies_.end()
	);

	// ãƒˆãƒ©ãƒƒãƒ—ã‚¨ãƒãƒŸãƒ¼ã®æ›´æ–°
	for (auto& enemy : pTrapEnemies_)
	{
		enemy->SetPlayerPosition(playerPosition_);
		enemy->Update();
	}

	// isDead ãŒãŸã£ãŸã‚‰å‰Šé™¤
	pTrapEnemies_.erase(
		std::remove_if(
			pTrapEnemies_.begin(),
			pTrapEnemies_.end(),
			[this](std::unique_ptr<TrapEnemy>& enemy)
			{
				if (enemy->IsDead())
				{
					// Finalize å‰ã«æ®‹ã£ã¦ã„ã‚‹ç½ ã®ä½ç½®ã‚’å–å¾—
					std::vector<Vector3> remainingTraps = enemy->GetRemainingTimeBombPositions();

					// å‡ºç¾ä½ç½®ã«Corruptorã‚’ç”Ÿæˆ
					for (const auto& trapPos : remainingTraps)
					{
						CorruptorInit(trapPos);
					}

					enemy->Finalize();
					// æ•µã®ã‚«ã‚¦ãƒ³ãƒˆã‚’æ¸›ã‚‰ã™
					enemyCount_--;
					return true;
				}
				return false;
			}),
		pTrapEnemies_.end()
	);

	// ã‚³ãƒ©ãƒ—ã‚¿ãƒ¼ã®æ›´æ–°
	for(auto& corruptor : pCorruptors_)
	{
		corruptor->SetPlayerPosition(playerPosition_);
		corruptor->Update();
	}

	// isDead ãŒãŸã£ãŸã‚‰å‰Šé™¤
	pCorruptors_.erase(
		std::remove_if(
			pCorruptors_.begin(),
			pCorruptors_.end(),
			[this](std::unique_ptr<Corruptor>& corruptor)
			{
				if (corruptor->IsDead())
				{
					corruptor->Finalize();
					// æ•µã®ã‚«ã‚¦ãƒ³ãƒˆã‚’æ¸›ã‚‰ã™
					enemyCount_--;
					return true;
				}
				return false;
			}),
		pCorruptors_.end()
	);

	// ã‚¦ã‚§ãƒ¼ãƒ–ã‚¹ãƒ†ãƒ¼ãƒˆã®æ›´æ–°
	pState_->Update();
	
	// æ•µãŒå…¨ã¦å€’ã•ã‚ŒãŸã‚‰ã‚¦ã‚§ãƒ¼ãƒ–ãƒã‚§ãƒ³ã‚¸é–‹å§‹
	if (enemyCount_ == 0)
	{
		if (waveChangeInterval_ > 0)
		{
			isWaveChange_ = false;
			waveChangeInterval_ = std::max(0, waveChangeInterval_ - framesThisUpdate);
		} 
		else
		{
			// ã‚¹ãƒ†ãƒ¼ãƒˆé·ç§»
			isWaveChange_ = true;
			waveChangeInterval_ = 120;
		}
	}
}

void EnemyManager::Draw()
{
	for (auto& enemy : pNormalEnemies_)
	{
		enemy->Draw();
	}

	for (auto& enemy : pTrapEnemies_)
	{
		enemy->Draw();
	}

	for(auto& corruptor : pCorruptors_)
	{
		corruptor->Draw();
	}

}

void EnemyManager::ImGuiDraw()
{
#ifdef USE_IMGUI

	for (auto& enemy : pNormalEnemies_)
	{
		enemy->ImGuiDraw();
	}

	for (auto& enemy : pTrapEnemies_)
	{
		enemy->ImGuiDraw();
	}

#endif // USE_IMGUI
}

void EnemyManager::TitleEnemyInit()
{
	NormalEnemyInit({ 2.0f,0.5f,-5.0f });
	TrapEnemyInit({ -2.0f,0.5f,2.0f });
	NormalEnemyInit({ -5.0f,0.5f,-2.0f });
	TrapEnemyInit({ 5.0f,0.5f,5.0f });
}

void EnemyManager::TitleEnemyUpdate()
{
	// ãƒŽãƒ¼ãƒžãƒ«ã‚¨ãƒãƒŸãƒ¼ã®æ›´æ–°
	for (auto& enemy : pNormalEnemies_)
	{
		enemy->SetPlayerPosition(playerPosition_);
		enemy->Update();
		toPlayerDistance_.push_back(enemy->GetToPlayer());
	}

	// isDeat ãŒãŸã£ãŸã‚‰å‰Šé™¤
	pNormalEnemies_.erase(
		std::remove_if(
			pNormalEnemies_.begin(),
			pNormalEnemies_.end(),
			[this](std::unique_ptr<NormalEnemy>& enemy)
			{
				if (enemy->IsDead())
				{
					enemy->Finalize();

					// æ•µã®ã‚«ã‚¦ãƒ³ãƒˆã‚’æ¸›ã‚‰ã™
					enemyCount_--;

					return true;
				}
				return false;
			}),
		pNormalEnemies_.end()
	);

	// ãƒˆãƒ©ãƒƒãƒ—ã‚¨ãƒãƒŸãƒ¼ã®æ›´æ–°
	for (auto& enemy : pTrapEnemies_)
	{
		enemy->SetPlayerPosition(playerPosition_);
		enemy->Update();
	}

	// isDead ãŒãŸã£ãŸã‚‰å‰Šé™¤
	pTrapEnemies_.erase(
		std::remove_if(
			pTrapEnemies_.begin(),
			pTrapEnemies_.end(),
			[this](std::unique_ptr<TrapEnemy>& enemy)
			{
				if (enemy->IsDead())
				{
					enemy->Finalize();
					// æ•µã®ã‚«ã‚¦ãƒ³ãƒˆã‚’æ¸›ã‚‰ã™
					enemyCount_--;
					return true;
				}
				return false;
			}),
		pTrapEnemies_.end()
	);

	// æ•µãŒå…¨ã¦å€’ã•ã‚ŒãŸã‚‰ã‚‚ã†ä¸€åº¦å‡ºç¾
	if (enemyCount_ == 0)
	{
		TitleEnemyInit();
	}
}

void EnemyManager::GameOverEnemyInit()
{
	NormalEnemyInit({ -20.0f,0.5f,0.0f });
}

void EnemyManager::GameOverEnemyUpdate()
{
	// ãƒŽãƒ¼ãƒžãƒ«ã‚¨ãƒãƒŸãƒ¼ã®æ›´æ–°
	for (auto& enemy : pNormalEnemies_)
	{
		enemy->SetPlayerPosition(playerPosition_);
		enemy->Update();
		toPlayerDistance_.push_back(enemy->GetToPlayer());
	}

	// isDeat ãŒãŸã£ãŸã‚‰å‰Šé™¤
	pNormalEnemies_.erase(
		std::remove_if(
			pNormalEnemies_.begin(),
			pNormalEnemies_.end(),
			[this](std::unique_ptr<NormalEnemy>& enemy)
			{
				if (enemy->IsDead())
				{
					enemy->Finalize();

					// æ•µã®ã‚«ã‚¦ãƒ³ãƒˆã‚’æ¸›ã‚‰ã™
					enemyCount_--;

					return true;
				}
				return false;
			}),
		pNormalEnemies_.end()
	);

	// æ•µãŒå…¨ã¦å€’ã•ã‚ŒãŸã‚‰ã‚‚ã†ä¸€åº¦å‡ºç¾
	if (enemyCount_ == 0)
	{
		GameOverEnemyInit();
	}
}

void EnemyManager::NormalEnemyInit(const Vector3& pos)
{
	// ãƒŽãƒ¼ãƒžãƒ«ã‚¨ãƒãƒŸãƒ¼
	std::unique_ptr<NormalEnemy> enemy = std::make_unique<NormalEnemy>();
	enemy->SetPosition(pos);
	enemy->Initialize();
	enemy->SetPlayerPosition(playerPosition_);
	enemy->Update();

	// æ•µã‚’ç™»éŒ²
	pNormalEnemies_.push_back(std::move(enemy));

	// æ•µã®ã‚«ã‚¦ãƒ³ãƒˆã‚’å¢—ã‚„ã™
	enemyCount_++;
}

void EnemyManager::TrapEnemyInit(const Vector3& pos)
{
	// ãƒˆãƒ©ãƒƒãƒ—ã‚¨ãƒãƒŸãƒ¼
	std::unique_ptr<TrapEnemy> trapEnemy = std::make_unique<TrapEnemy>();
	trapEnemy->SetPosition(pos);
	trapEnemy->Initialize();
	trapEnemy->SetPlayerPosition(playerPosition_);
	trapEnemy->Update();

	// æ•µã‚’ç™»éŒ²
	pTrapEnemies_.push_back(std::move(trapEnemy));

	// æ•µã®ã‚«ã‚¦ãƒ³ãƒˆã‚’å¢—ã‚„ã™
	enemyCount_++;
}

void EnemyManager::CorruptorInit(const Vector3& pos)
{
	// ã‚³ãƒ©ãƒ—ã‚¿ãƒ¼
	std::unique_ptr<Corruptor> corruptor = std::make_unique<Corruptor>();
	corruptor->SetPosition(pos);
	corruptor->Initialize();
	corruptor->SetPlayerPosition(playerPosition_);
	corruptor->Update();

	// æ•µã‚’ç™»éŒ²
	pCorruptors_.push_back(std::move(corruptor));
	
	// æ•µã®ã‚«ã‚¦ãƒ³ãƒˆã‚’å¢—ã‚„ã™
	enemyCount_++;
}

void EnemyManager::ChangeState(std::unique_ptr<EnemyWaveState> _pState)
{
	pState_ = std::move(_pState);
	pState_->Initialize();
}


============================================================
File Path: project/application/Objects/Enemy/EnemyManager.h
============================================================
#pragma once

#include <vector>
#include <Framework.h>

#include "NormalEnemy.h"
#include "TrapEnemy.h"
#include "Corruptor.h"
#include "waveState/EnemyWaveState.h"
#include "../../../gameEngine/level_editor/LevelDataLoader.h"

/// <summary>
/// æ•µãƒžãƒãƒ¼ã‚¸ãƒ£ãƒ¼
/// </summary>
class EnemyManager
{
public:

	EnemyManager() = default;
	~EnemyManager() = default;

	// åˆæœŸåŒ–
	void Initialize();

	// çµ‚äº†
	void Finalize();

	// æ›´æ–°
	void Update();

	// æç”»
	void Draw();

	// ImGui
	void ImGuiDraw();

	// ã‚¿ã‚¤ãƒˆãƒ«ã‚·ãƒ¼ãƒ³ç”¨ã®æ•µåˆæœŸåŒ–
	void TitleEnemyInit();

	// ã‚¿ã‚¤ãƒˆãƒ«ã‚·ãƒ¼ãƒ³ç”¨ã®æ•µæ›´æ–°
	void TitleEnemyUpdate();

	// ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼ã‚·ãƒ¼ãƒ³ç”¨ã®æ•µåˆæœŸåŒ–
	void GameOverEnemyInit();

	// ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼ã‚·ãƒ¼ãƒ³ç”¨ã®æ•µæ›´æ–°
	void GameOverEnemyUpdate();

	// æ•µã®åˆæœŸåŒ–
	/// <summary>
	/// é€šå¸¸æ•µã®åˆæœŸåŒ–
	/// </summary>
	/// <param name="pos">å‡ºç¾ä½ç½®</param>
	void NormalEnemyInit(const Vector3& pos);
	/// <summary>
	/// ãƒˆãƒ©ãƒƒãƒ—æ•µã®åˆæœŸåŒ–
	/// </summary>
	/// <param name="pos">å‡ºç¾ä½ç½®</param>
	void TrapEnemyInit(const Vector3& pos);
	/// <summary>
	/// ã‚³ãƒ©ãƒ—ã‚¿ãƒ¼ã®åˆæœŸåŒ–
	/// </summary>
	/// <param name="pos">å‡ºç¾ä½ç½®</param>
	void CorruptorInit(const Vector3& pos);

	/// <summary>
	/// æ•µã®ã‚¦ã‚§ãƒ¼ãƒ–ã‚¹ãƒ†ãƒ¼ãƒˆåˆ‡ã‚Šæ›¿ãˆ
	/// </summary>
	/// <param name="_pState">æ–°ã—ã„ã‚¹ãƒ†ãƒ¼ãƒˆ</param>
	void ChangeState(std::unique_ptr<EnemyWaveState>_pState);

public: // ã‚²ãƒƒã‚¿ãƒ¼

	// ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã¨ã®è·é›¢ã®ã‚²ãƒƒã‚¿ãƒ¼
	const std::vector<Vector3>& GetToPlayerDistance() const { return toPlayerDistance_; }

	// æ•µã®ã‚¦ã‚§ãƒ¼ãƒ–åˆ‡ã‚Šæ›¿ãˆãƒ•ãƒ©ã‚°
	bool IsWaveChange() const { return isWaveChange_; }

	// å…¨ã¦ã®ã‚¦ã‚§ãƒ¼ãƒ–ã®æ•µã‚’å€’ã—ãŸã‹ã©ã†ã‹ã®ãƒ•ãƒ©ã‚°
	bool IsAllEnemyDefeated() const { return isAllEnemyDefeated_; }

	// ãƒ¬ãƒ™ãƒ«ã‚¨ãƒ‡ã‚£ã‚¿
	std::shared_ptr<LevelData> GetLevelData() const { return levelData_; }

public: // ã‚»ãƒƒã‚¿ãƒ¼

	/// <summary>
	/// ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®ä½ç½®ã‚’ã‚»ãƒƒãƒˆ
	/// </summary>
	/// <param name="playerPosition">ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®ä½ç½®ãƒ™ã‚¯ãƒˆãƒ«</param>
	void SetPlayerPosition(const Vector3& playerPosition) { playerPosition_ = playerPosition; }

	/// <summary>
	/// å…¨ã¦ã®ã‚¦ã‚§ãƒ¼ãƒ–ã®æ•µã‚’å€’ã—ãŸã‚‰ç«‹ã¦ã‚‹ãƒ•ãƒ©ã‚°ã‚»ãƒƒãƒˆ
	/// </summary>
	/// <param name="isDefeated">ãƒ•ãƒ©ã‚°</param>
	void SetAllEnemyDefeated(bool isDefeated) { isAllEnemyDefeated_ = isDefeated; }

	/// <summary>
	/// ã‚¨ãƒ‡ã‚£ã‚¿ã‚»ãƒƒãƒˆ
	/// </summary>
	/// <param name="_levelData">ãƒ¬ãƒ™ãƒ«ãƒ‡ãƒ¼ã‚¿ãƒ­ãƒ¼ãƒ€ãƒ¼</param>
	void SetLevelData(std::shared_ptr<LevelData> _levelData) { levelData_ = _levelData; }

private:

	// ã‚¨ãƒãƒŸãƒ¼
	std::vector<std::unique_ptr<NormalEnemy>> pNormalEnemies_;
	// ãƒˆãƒ©ãƒƒãƒ—ã‚¨ãƒãƒŸãƒ¼
	std::vector<std::unique_ptr<TrapEnemy>> pTrapEnemies_;
	// ã‚³ãƒ©ãƒ—ã‚¿ãƒ¼
	std::vector<std::unique_ptr<Corruptor>> pCorruptors_;

	// æ•µã®æ•°
	uint32_t enemyCount_ = 0;

	// æ•µã®ã‚¦ã‚§ãƒ¼ãƒ–ã‚¹ãƒ†ãƒ¼ãƒˆ
	std::unique_ptr<EnemyWaveState> pState_ = nullptr;
	// æ•µã®ã‚¦ã‚§ãƒ¼ãƒ–åˆ‡ã‚Šæ›¿ãˆ
	bool isWaveChange_ = false;
	// æ•µã®ã‚¦ã‚§ãƒ¼ãƒ–åˆ‡ã‚Šæ›¿ãˆã‚¤ãƒ³ã‚¿ãƒ¼ãƒãƒ«
	int32_t waveChangeInterval_ = 250;

	// ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®ä½ç½®
	Vector3 playerPosition_{};
	// ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã¨ã®è·é›¢
	std::vector<Vector3> toPlayerDistance_;

	// å…¨ã¦ã®ã‚¦ã‚§ãƒ¼ãƒ–ã®æ•µã‚’å€’ã—ãŸã‚‰ç«‹ã¦ã‚‹ãƒ•ãƒ©ã‚°
	bool isAllEnemyDefeated_ = false;

	// ãƒ¬ãƒ™ãƒ«ãƒ‡ãƒ¼ã‚¿ãƒ­ãƒ¼ãƒ€ãƒ¼
	std::shared_ptr<LevelData> levelData_ = nullptr;

};



============================================================
File Path: project/application/Objects/Enemy/NormalEnemy.cpp
============================================================
#include "NormalEnemy.h"

#include <Ease.h>

// BehaviorState
#include "behaviorState/normalEnemyState/EnemyBehaviorSpawn.h"
#include "behaviorState/normalEnemyState/EnemyBehaviorMove.h"
#include "behaviorState/normalEnemyState/EnemyBehaviorAttack.h"
#include "behaviorState/normalEnemyState/EnemyBehaviorHitReact.h"
#include "behaviorState/normalEnemyState/EnemyBehaviorDead.h"

#include "TimeManager.h"

void NormalEnemy::Initialize()
{
    // --- 3Dã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ ---
    object_ = std::make_unique<Object3d>();
    object_->Initialize("normalEnemy.obj");

    moveVelocity_ = { 0.1f,0.1f,0.0f };

    object_->SetPosition(position_);
    object_->SetRotate(rotation_);
    // ä»®ç½®ã
    scale_ = { 1.0f,1.0f,1.0f };
	object_->SetScale(scale_);
    // ãƒ©ã‚¤ãƒˆè¨­å®š
    //object_->SetDirectionalLightEnable(true);
    object_->SetLighting(true);

    colliderManager_ = ColliderManager::GetInstance();

    objectName_ = "NormalEnemy";

    desc =
    {
        //ã“ã“ã«è¨­å®š
        .owner = this,
        .colliderID = objectName_,
        .shape = Shape::AABB,
        .shapeData = &aabb_,
        .attribute = colliderManager_->GetNewAttribute(objectName_),
        .onCollision = std::bind(&NormalEnemy::OnCollision, this, std::placeholders::_1),
        .onCollisionTrigger = std::bind(&NormalEnemy::OnCollisionTrigger, this, std::placeholders::_1),
    };
    collider_.MakeAABBDesc(desc);
    colliderManager_->RegisterCollider(&collider_);

    // ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹
    hp_ = 3;
    isDead_ = false;

    // è¡Œå‹•ã‚¹ãƒ†ãƒ¼ãƒˆ
    ChangeBehaviorState(std::make_unique<EnemyBehaviorSpawn>(this));

	// å‡ºç¾æ™‚ã¯ç„¡æ•µçŠ¶æ…‹
    isInvincible_ = true;


	// ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«
	ParticleEmitter::Emit("laserGroup", position_, 2);
}

void NormalEnemy::Finalize()
{
	for (auto& bullet : pBullets_)
	{
		bullet->SetIsDead(true);
		bullet->Finalize();
	}

    pBullets_.erase(
        std::remove_if(pBullets_.begin(), pBullets_.end(), [](std::unique_ptr<EnemyBullet>& bullet)
            {
                if (bullet->IsDead())
                {
                    bullet->Finalize();
                    return true;
                }
                return false;
            }),
        pBullets_.end()
    );

    colliderManager_->DeleteCollider(&collider_);
}

void NormalEnemy::Update()
{
	// å„è¡Œå‹•ã‚¹ãƒ†ãƒ¼ãƒˆã®æ›´æ–°
	pBehaviorState_->Update();

    object_->Update();

    // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã¨ã®è·é›¢ã‚’è¨ˆç®—
    float distanceToPlayer = position_.Distance(playerPosition_);

    if (distanceToPlayer <= kStopChasingDistance)
    {
        isFarFromPlayer_ = true;
	}
    else
	{
		isFarFromPlayer_ = false;
	}

	// æ•µã®å¼¾ã®å‰Šé™¤
    pBullets_.erase(
        std::remove_if(pBullets_.begin(), pBullets_.end(), [](std::unique_ptr<EnemyBullet>& bullet)
            {
                if (bullet->IsDead())
                {
                    bullet->Finalize();
                    return true;
                }
                return false;
            }),
        pBullets_.end()
    );

    // å¼¾ã®æ›´æ–°
    for (auto& bullet : pBullets_)
    {
        bullet->Update();
    }

	// aabbã®æ›´æ–°
    aabb_.min = position_ - object_->GetScale();
    aabb_.max = position_ + object_->GetScale();
    aabb_.max.y += 1.0f;
    collider_.SetPosition(position_);

	// æš—é—‡å‡¦ç†(ã‚¨ãƒãƒŸãƒ¼ã¯å‹•ã‹ãªãã•ã›ã‚‹)
    HitVignetteTrap();
}

void NormalEnemy::Draw()
{
    object_->Draw();

	// å¼¾æç”»
	for (auto& bullet : pBullets_)
	{
		bullet->Draw();
	}
}

void NormalEnemy::Draw2D()
{
}

void NormalEnemy::ImGuiDraw()
{
#ifdef USE_IMGUI

	ImGui::Begin("Enemy");

	ImGui::SliderFloat3("position", &position_.x, -30.0f, 30.0f);
	ImGui::SliderFloat3("rotation", &rotation_.x, -3.14f, 3.14f);
	ImGui::SliderFloat3("scale", &scale_.x, 0.0f, 10.0f);

    // ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®ãƒˆãƒ©ãƒ³ã‚¹ãƒ•ã‚©ãƒ¼ãƒ   
    Vector3 objPos = object_->GetPosition();
    Vector3 objRot = object_->GetRotate();
    Vector3 objScale = object_->GetScale();

    if (ImGui::SliderFloat3("object position", &objPos.x, -30.0f, 30.0f)) {
        object_->SetPosition(objPos);
    }
    if (ImGui::SliderFloat3("object rotation", &objRot.x, -3.14f, 3.14f)) {
        object_->SetRotate(objRot);
    }
    if (ImGui::SliderFloat3("object scale", &objScale.x, 0.0f, 10.0f)) {
        object_->SetScale(objScale);
    }

    ImGui::End();

	for (auto& bullet : pBullets_)
	{
		bullet->ImGuiDraw();
	}

#endif // USE_IMGUI
}

void NormalEnemy::Move()
{

	const float dt = TimeManager::Instance().GetDeltaTime();

    if (isFarFromPlayer_)
    {
        // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã¨ã®è·é›¢ãŒä¸€å®šä»¥ä¸‹ã®å ´åˆã€è¿½å°¾ã‚’åœæ­¢(0ã«ã™ã‚‹ã¨ã¾ãšã‹ã£ãŸ)
        moveVelocity_ = { 0.000001f, 0.0f, 0.0f };        
        return;
    }
    else
    {
        // æ•µå¼¾ã‹ã‚‰è‡ªã‚­ãƒ£ãƒ©ã¸ã®ãƒ™ã‚¯ãƒˆãƒ«ã‚’è¨ˆç®—
        toPlayer_ = playerPosition_ - position_;

        // ãƒ™ã‚¯ãƒˆãƒ«ã‚’æ­£è¦åŒ–ã™ã‚‹
        toPlayer_ = Normalize(toPlayer_);
        moveVelocity_ = Normalize(moveVelocity_);

        // çƒé¢ç·šå½¢è£œé–“ã«ã‚ˆã‚Šã€ä»Šã®é€Ÿåº¦ã¨è‡ªã‚­ãƒ£ãƒ©ã¸ã®ãƒ™ã‚¯ãƒˆãƒ«ã‚’å†…æŒ¿ã—ã€æ–°ãŸãªé€Ÿåº¦ã¨ã™ã‚‹
        moveVelocity_ = 1.0f * (Slerp(moveVelocity_, toPlayer_, 0.1f));

        // é€²è¡Œæ–¹å‘ã«è¦‹ãŸç›®ã®å›žè»¢ã‚’åˆã‚ã›ã‚‹
        // Yè»¸å‘¨ã‚Šè§’åº¦(Î¸y)
        rotation_.y = std::atan2(moveVelocity_.x, moveVelocity_.z);
        rotation_.x = 0.0f;

        moveVelocity_ /= 20.0f;

        moveVelocity_.y = 0.0f;
        position_ += moveVelocity_ * (dt * kDefaultFrameRate);

		SetPosition(position_);
		SetRotation(rotation_);
		SetScale(scale_);

		ObjectTransformSet(position_, rotation_, scale_);

		ParticleEmitter::Emit("enemyWalk", position_, 1);
    }
}

void NormalEnemy::Attack()
{
    // å¼¾ã®æ•°ã¨é–“éš”è§’åº¦
    const int bulletCount = 24;
    const float angleStep = 360.0f / bulletCount;

    for (int i = 0; i < bulletCount; ++i)
    {
        // å¼¾ã®è§’åº¦ã‚’è¨ˆç®— (ãƒ©ã‚¸ã‚¢ãƒ³ã«å¤‰æ›)
        float angle = DirectX::XMConvertToRadians(i * angleStep);

        // å¼¾ã®æ–¹å‘ã‚’è¨ˆç®—
        Vector3 bulletDirection =
        {
            std::cos(angle), // Xæˆåˆ†
            0.0f,            // Yæˆåˆ†
            std::sin(angle)  // Zæˆåˆ†
        };

        // å¼¾ã‚’ç”Ÿæˆ
        auto bullet = std::make_unique<EnemyBullet>();
        bullet->Initialize();
        bullet->SetPosition({ position_.x,position_.y + 0.5f,position_.z }); // æ•µã®ä½ç½®ã‚ˆã‚Šå°‘ã—ä¸Šã‚’åˆæœŸä½ç½®ã«è¨­å®š
        bullet->SetVelocity(bulletDirection * 0.2f);
        bullet->UpdateModel();

        // å¼¾ã‚’ãƒªã‚¹ãƒˆã«è¿½åŠ 
        pBullets_.push_back(std::move(bullet));
    }
}
    

void NormalEnemy::ChangeBehaviorState(std::unique_ptr<EnemyBehaviorState> _pState)
{
    pBehaviorState_ = std::move(_pState);
    pBehaviorState_->Initialize();
}

void NormalEnemy::ObjectTransformSet(const Vector3& _position, const Vector3& _rotation, const Vector3& _scale)
{
    object_->SetPosition(_position);
    object_->SetRotate(_rotation);
    object_->SetScale(_scale);
}

void NormalEnemy::OnCollisionTrigger(const Collider* _other)
{
	if (_other->GetColliderID() == "PlayerBullet" && !isInvincible_)
	{
		// ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®å¼¾ã¨è¡çªã—ãŸå ´åˆ
		if (hp_ > 0)
		{
            // HPæ¸›å°‘
			hp_--;

			isHit_ = true;
		}
	}

    if (!isInvincible_ && _other->GetColliderID() == "ExplosionTimeBomb")
    {
        if (_other->GetOwner()->IsActive())
        {
            // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®HPã‚’æ¸›å°‘
            if (hp_ > 0)
            {
                hp_ -= 1.5f;
                isHit_ = true;
            }
        }
    }

    if (_other->GetColliderID() == "VignetteTrap")
    {
        if (_other->GetOwner()->IsActive())
        {
            // VignetteTrapã«å½“ãŸã£ãŸå ´åˆ
            isHitVignetteTrap_ = true;
        }
    }
}

void NormalEnemy::OnCollision(const Collider* _other)
{
    if (_other->GetColliderID() == "NormalEnemy" or 
        _other->GetColliderID() == "TrapEnemy")
    {
        
        // æ•µã®ä½ç½®
        Vector3 enemyPosition = _other->GetOwner()->GetPosition();

        // æ•µåŒå£«ãŒé‡ãªã‚‰ãªã„ã‚ˆã†ã«ã™ã‚‹
        Vector3 direction = position_ - enemyPosition;
        direction.Normalize();
        float distance = 2.5f; // æ•µåŒå£«ã®é–“ã®è·é›¢ã‚’èª¿æ•´ã™ã‚‹ãŸã‚ã®å€¤

        // äº’ã„ã«é‡ãªã‚‰ãªã„ã‚ˆã†ã«å°‘ã—ãšã¤ä½ç½®ã‚’èª¿æ•´
        if ((position_ - enemyPosition).Length() < distance) 
        {
            position_ += direction * 0.1f; // å¾®èª¿æ•´ã®ãŸã‚ã®å€¤
        }
    }

    if (_other->GetColliderID() == "Wall" or 
        _other->GetColliderID() == "Barrie" or
        _other->GetColliderID() == "Player")
    {
        // ç›¸æ‰‹ã®AABBã‚’å–å¾—
        const AABB* otherAABB = _other->GetAABB();
        
        if (otherAABB)
        {
            // è‡ªåˆ†ã®AABBã¨ä½ç½®ã‚’æ¸¡ã—ã¦è£œæ­£
            CorrectOverlap(*otherAABB, aabb_, position_);
        }
    }
}

void NormalEnemy::HitVignetteTrap()
{
    // æš—é—‡ãƒˆãƒ©ãƒƒãƒ—ã«å½“ãŸã£ãŸã‚‰
    if (isHitVignetteTrap_)
    {
        // ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã‚’ç”Ÿæˆ
        ParticleEmitter::Emit("vignetteGroup", { position_.x, position_.y + 1.0f,position_.z }, 3);

        // ã‚¿ã‚¤ãƒžãƒ¼æ›´æ–°
        if (vignetteTime_ > 0)
        {
            vignetteTime_--;
        } 
        else
        {
            // çµ‚äº†
            isHitVignetteTrap_ = false;
            // ã‚¿ã‚¤ãƒžãƒ¼ã‚’ãƒªã‚»ãƒƒãƒˆ
            vignetteTime_ = kMaxVignetteTime;


        }
    }
    
}


============================================================
File Path: project/application/Objects/Enemy/NormalEnemy.h
============================================================
#pragma once

#include "../../baseObject/GameObject.h"
#include "bullet/EnemyBullet.h"
#include "behaviorState/normalEnemyState/EnemyBehaviorState.h"
#include"../../../gameEngine/collider/ColliderManager.h"
#include "../../../gameEngine/particle/ParticleEmitter.h"

#include <Object3d.h>
#include <Sprite.h>
#include <Framework.h>

/// <summary>
/// é€šå¸¸æ•µ
/// è¡Œå‹•ã‚¹ãƒ†ãƒ¼ãƒˆã‚’æŒã¤
/// </summary>
class NormalEnemy : public GameObject
{
public:

	NormalEnemy() = default;
	~NormalEnemy() = default;

	// åˆæœŸåŒ–
	void Initialize() override;
	
	// çµ‚äº†
	void Finalize() override;
	
	// æ›´æ–°
	void Update() override;
	
	// æç”»
	void Draw() override;

	// ã‚¹ãƒ—ãƒ©ã‚¤ãƒˆæç”»
	void Draw2D();

	// ImGui
	void ImGuiDraw();

	// ç§»å‹•
	void Move();

	// æ”»æ’ƒ
	void Attack();

	/// <summary>
	/// è¡Œå‹•ã‚¹ãƒ†ãƒ¼ãƒˆåˆ‡ã‚Šæ›¿ãˆ
	/// </summary>
	/// <param name="_pState">æ–°ã—ã„ã‚¹ãƒ†ãƒ¼ãƒˆãƒã‚¤ãƒ³ã‚¿</param>
	void ChangeBehaviorState(std::unique_ptr<EnemyBehaviorState> _pState);

private: // è¡çªåˆ¤å®š

	/// <summary>
	/// è¡çªæ™‚ã®å‡¦ç†
	/// </summary>
	/// <param name="_other">è¡çªç›¸æ‰‹ã®ã‚³ãƒ©ã‚¤ãƒ€ãƒ¼</param>
	void OnCollisionTrigger(const Collider* _other);

	/// <summary>
	/// è¡çªä¸­ã®å‡¦ç†
	/// </summary>
	/// <param name="_other">è¡çªç›¸æ‰‹ã®ã‚³ãƒ©ã‚¤ãƒ€ãƒ¼</param>
	void OnCollision(const Collider* _other);

	// æš—é—‡ãƒˆãƒ©ãƒƒãƒ—ã«è¡çªã—ãŸã¨ãã®å‡¦ç†
	void HitVignetteTrap();

public: // ã‚²ãƒƒã‚¿ãƒ¼

	// ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã¨ã®è·é›¢
	Vector3 GetToPlayer() const { return toPlayer_; }

	// è¢«å¼¾ãƒ•ãƒ©ã‚°
	bool IsHit() const { return isHit_; }

	// ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã¨ã®è·é›¢ãŒä¸€å®šä»¥ä¸Šã‹ã©ã†ã‹
	bool IsFarFromPlayer() const { return isFarFromPlayer_; }

	// æš—é—‡ãƒ•ãƒ©ã‚°
	bool IsHitVignetteTrap() const { return isHitVignetteTrap_; }

public: // ã‚»ãƒƒã‚¿ãƒ¼

	// ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®ä½ç½®ã‚’ã‚»ãƒƒãƒˆ
	void SetPlayerPosition(Vector3 _playerPosition) { playerPosition_ = _playerPosition; }

	// ç„¡æ•µãƒ•ãƒ©ã‚°ã‚’ã‚»ãƒƒãƒˆ
	void SetIsInvincible(bool _isInvincible) { isInvincible_ = _isInvincible; }

	// è¢«å¼¾ãƒ•ãƒ©ã‚°ã‚’ã‚»ãƒƒãƒˆ
	void SetIsHit(bool _isHit) { isHit_ = _isHit; }

	/// <summary>
	/// objectã®transformã‚’ã‚»ãƒƒãƒˆ
	/// </summary>
	/// <param name="_position">ä½ç½®</param>
	/// <param name="_rotation">å›žè»¢</param>
	/// <param name="_scale">ã‚¹ã‚±ãƒ¼ãƒ«</param>
	void ObjectTransformSet(const Vector3& _position, const Vector3& _rotation, const Vector3& _scale);

	/// ä»¥ä¸‹1ã¤ã¥ã¤ã‚»ãƒƒãƒˆ ///
	
	// ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®positionã‚’ã‚»ãƒƒãƒˆ
	void SetObjectPosition(const Vector3& _position) { object_->SetPosition(_position); }
	// ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®rotationã‚’ã‚»ãƒƒãƒˆ
	void SetObjectRotation(const Vector3& _rotation) { object_->SetRotate(_rotation); }
	// ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®scaleã‚’ã‚»ãƒƒãƒˆ
	void SetObjectScale(const Vector3& _scale) { object_->SetScale(_scale); }


private:

	static constexpr float kDefaultFrameRate = 60.0f;

	// 3Dã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ
	std::unique_ptr<Object3d> object_ = nullptr;

	// å½“ãŸã‚Šåˆ¤å®šé–¢ä¿‚
	ColliderManager* colliderManager_ = nullptr;
	Collider collider_;
	AABB aabb_;
	Collider::ColliderDesc desc = {};

	// ç§»å‹•é€Ÿåº¦
	Vector3 moveVelocity_{};
	float moveSpeed_ = 0.05f;

	// ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®ä½ç½®
	Vector3 playerPosition_{};
	Vector3 toPlayer_{};
	// è¿½å°¾åœæ­¢è·é›¢
	const float kStopChasingDistance = 15.0f;

	// å¼¾
	std::vector<std::unique_ptr<EnemyBullet>> pBullets_ = {};

	// è¡Œå‹•ã‚¹ãƒ†ãƒ¼ãƒˆ
	std::unique_ptr<EnemyBehaviorState> pBehaviorState_ = nullptr;

	// ç„¡æ•µãƒ•ãƒ©ã‚°(å‡ºç¾æ™‚ç­‰æ”»æ’ƒã‚’å—ã‘ãªãã•ã›ã‚‹)
	bool isInvincible_ = true;

	// è¢«å¼¾ãƒ•ãƒ©ã‚°
	bool isHit_ = false;

	// ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã¨ã®è·é›¢ãŒä¸€å®šä»¥ä¸Šã‹ã©ã†ã‹
	bool isFarFromPlayer_ = false;

	// æš—é—‡ãƒˆãƒ©ãƒƒãƒ—ã«å½“ãŸã£ãŸã‹ã©ã†ã‹
	bool isHitVignetteTrap_ = false;
	// æš—é—‡åŠ¹æžœæœ€å¤§æ™‚é–“
	const uint32_t kMaxVignetteTime = 60 * 3;
	// æš—é—‡ã‚¿ã‚¤ãƒžãƒ¼
	uint32_t vignetteTime_ = kMaxVignetteTime;


};



============================================================
File Path: project/application/Objects/Enemy/TrapEnemy.cpp
============================================================
#include "TrapEnemy.h"

// BehaviorState
#include "behaviorState/trapEnemyState/TrapEnemyBehaviorSpawn.h"
#include "behaviorState/trapEnemyState/TrapEnemyBehaviorMove.h"
#include "behaviorState/trapEnemyState/TrapEnemyBehaviorSetTrap.h"
#include "behaviorState/trapEnemyState/TrapEnemyBehaviorHitReact.h"
#include "behaviorState/trapEnemyState/TrapEnemyBehaviorDead.h"

#include "TimeManager.h"

void TrapEnemy::Initialize()
{
    // --- 3Dã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ ---
    object_ = std::make_unique<Object3d>();
    object_->Initialize("trapEnemy.obj");

    moveVelocity_ = { 0.1f,0.1f,0.0f };

    object_->SetPosition(position_);
    object_->SetRotate(rotation_);
    scale_ = { 1.0f,1.0f,1.0f };
    object_->SetScale(scale_);
    // ãƒ©ã‚¤ãƒˆè¨­å®š
    //object_->SetDirectionalLightEnable(true);
    object_->SetLighting(true);

    colliderManager_ = ColliderManager::GetInstance();

    objectName_ = "TrapEnemy";

    desc =
    {
        //ã“ã“ã«è¨­å®š
        .owner = this,
        .colliderID = objectName_,
        .shape = Shape::AABB,
        .shapeData = &aabb_,
        .attribute = colliderManager_->GetNewAttribute(objectName_),
        .onCollision = std::bind(&TrapEnemy::OnCollision, this, std::placeholders::_1),
        .onCollisionTrigger = std::bind(&TrapEnemy::OnCollisionTrigger, this, std::placeholders::_1),
    };
    collider_.MakeAABBDesc(desc);
    colliderManager_->RegisterCollider(&collider_);

    // ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹
    hp_ = 3;
    isDead_ = false;

    // è¡Œå‹•ã‚¹ãƒ†ãƒ¼ãƒˆ
    ChangeBehaviorState(std::make_unique<TrapEnemyBehaviorSpawn>(this));

    // å‡ºç¾æ™‚ã¯ç„¡æ•µçŠ¶æ…‹
    isInvincible_ = true;
    
	// ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«
    ParticleEmitter::Emit("laserGroup", position_, 2);
}

void TrapEnemy::Finalize()
{
    colliderManager_->DeleteCollider(&collider_);

    // ç½ 
	for (auto& trap : pTimeBomb_)
	{
		trap->SetIsDead(true);
		trap->Finalize();
	}

	pTimeBomb_.erase(
		std::remove_if(pTimeBomb_.begin(), pTimeBomb_.end(), [](std::unique_ptr<TimeBomb>& trap)
			{
				if (trap->IsDead())
				{
                    ParticleEmitter::Emit("BltReaction", trap->GetPosition(), 1);
					trap->Finalize();
					return true;
				}
				return false;
			}),
		pTimeBomb_.end()
	);

    for (auto& trap : pVignetteTrap_)
    {
		trap->SetIsDead(true);
		trap->Finalize();
    }

	pVignetteTrap_.erase(
		std::remove_if(pVignetteTrap_.begin(), pVignetteTrap_.end(), [](std::unique_ptr<VignetteTrap>& trap)
			{
				if (trap->IsDead())
				{
                    ParticleEmitter::Emit("BltReaction", trap->GetPosition(), 1);
					trap->Finalize();
					return true;
				}
				return false;
			}),
		pVignetteTrap_.end()
	);

}

void TrapEnemy::Update()
{
    // ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ãƒ•ãƒ©ã‚°ã«ä»£å…¥
    isActive_ = !isInvincible_;

    // å„è¡Œå‹•ã‚¹ãƒ†ãƒ¼ãƒˆã®æ›´æ–°
    pBehaviorState_->Update();

    object_->Update();

    // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã¨ã®è·é›¢ã‚’è¨ˆç®—
    float distanceToPlayer = position_.Distance(playerPosition_);

	isEscape_ = false;
	isApproach_ = false;
	isStopAndTrap_ = false;

    // è·é›¢ã«å¿œã˜ã¦ãƒ•ãƒ©ã‚°ã‚’æ›´æ–°
    if (distanceToPlayer < kTooCloseDistance) 
    {
        // é›¢ã‚Œã‚‹
		isEscape_ = true;
    }
    else if (distanceToPlayer > kTooFarDistance)
    {
        // è¿‘ã¥ã
		isApproach_ = true;
	}
    else
    {
		// ç½ ã‚’è¨­ç½®ã™ã‚‹
		isStopAndTrap_ = true;
    }

    // ç½ ã®å‰Šé™¤
	pTimeBomb_.erase(
		std::remove_if(pTimeBomb_.begin(), pTimeBomb_.end(), [](std::unique_ptr<TimeBomb>& trap)
			{
				if (trap->IsDead())
				{
                    ParticleEmitter::Emit("BltReaction", trap->GetPosition(), 1);
					trap->Finalize();
					return true;
				}
				return false;
			}),
		pTimeBomb_.end()
	);

	pVignetteTrap_.erase(
		std::remove_if(pVignetteTrap_.begin(), pVignetteTrap_.end(), [](std::unique_ptr<VignetteTrap>& trap)
			{
				if (trap->IsDead())
				{
                    ParticleEmitter::Emit("BltReaction", trap->GetPosition(), 1);
					trap->Finalize();
					return true;
				}
				return false;
			}),
		pVignetteTrap_.end()
	);

    // ç½ ã®æ›´æ–°
	for (auto& trap : pTimeBomb_)
	{
		trap->Update();
	}

	for (auto& trap : pVignetteTrap_)
	{
		trap->Update();
	}

    // aabbã®æ›´æ–°
    aabb_.min = position_ - object_->GetScale();
    aabb_.max = position_ + object_->GetScale();
    aabb_.max.y += 1.0f;
    collider_.SetPosition(position_);

}

void TrapEnemy::Draw()
{
    object_->Draw();

	// ç½ ã®æç”»
	for (auto& trap : pTimeBomb_)
	{
		trap->Draw();
	}
	for (auto& trap : pVignetteTrap_)
	{
		trap->Draw();
	}
}

void TrapEnemy::Draw2D()
{
}

void TrapEnemy::ImGuiDraw()
{
#ifdef USE_IMGUI

	ImGui::Begin("TrapEnemy");
	ImGui::Text("Position: (%.2f, %.2f, %.2f)", position_.x, position_.y, position_.z);
	ImGui::Text("Rotation: (%.2f, %.2f, %.2f)", rotation_.x, rotation_.y, rotation_.z);
	ImGui::Text("Scale: (%.2f, %.2f, %.2f)", scale_.x, scale_.y, scale_.z);
	ImGui::Text("HP: %d", hp_);
	ImGui::Text("Is Dead: %s", isDead_ ? "Yes" : "No");
	ImGui::End();

#endif // USE_IMGUI
}

void TrapEnemy::Move()
{
	// ãƒ‡ãƒ«ã‚¿ã‚¿ã‚¤ãƒ å–å¾—
    const float dt = TimeManager::Instance().GetDeltaTime();

    toPlayer_ = playerPosition_ - position_;
    Vector3 direction = Normalize(toPlayer_);
    moveVelocity_ = Normalize(moveVelocity_);

	if (isEscape_)
	{
		// é›¢ã‚Œã‚‹
		moveVelocity_ = Slerp(moveVelocity_, -direction, 0.1f);
	}
    else if (isApproach_)
	{
		// è¿‘ã¥ã
		moveVelocity_ = Slerp(moveVelocity_, direction, 0.1f);
	}
    // è·é›¢ãŒé©åˆ‡ã‹ã¤ç½ ã®ã‚¯ãƒ¼ãƒ«ã‚¿ã‚¤ãƒ ãŒç„¡ã‹ã£ãŸã‚‰ç–‘ä¼¼åœæ­¢
    else if (isStopAndTrap_ && isTrapCooldownComplete_)
	{
		// ç½ ã‚’è¨­ç½®ã™ã‚‹ãŸã‚åœæ­¢
		moveVelocity_ = { 0.0f, 0.0f, 0.00001f };
	}
    

    // Yè»¸å›žè»¢ã‚’é€²è¡Œæ–¹å‘ã«åˆã‚ã›ã‚‹
    rotation_.y = std::atan2(moveVelocity_.x, moveVelocity_.z);
    rotation_.x = 0.0f;

    moveVelocity_ /= 30.0f;
    moveVelocity_.y = 0.0f;
    position_ += moveVelocity_ * (dt * kDefaultFrameRate);

    ObjectTransformSet(position_, rotation_, scale_);

    ParticleEmitter::Emit("enemyWalk", position_, 1);
}


void TrapEnemy::TrapInit()
{
    if (isNextTrapTimeBomb_ && isTrapCooldownComplete_)
    {
        // TimeBombç™ºå°„
        auto timeBomb = std::make_unique<TimeBomb>();
        timeBomb->Initialize();
        timeBomb->SetPosition(position_);
        timeBomb->SetTrapLandingPosition(playerPosition_);
        timeBomb->LaunchTrap();
        timeBomb->UpdateModel();
        pTimeBomb_.push_back(std::move(timeBomb));
    } 
	else if (!isNextTrapTimeBomb_ && isTrapCooldownComplete_)
    {
        // VignetteTrapç™ºå°„
        auto vignetteTrap = std::make_unique<VignetteTrap>();
        vignetteTrap->Initialize();
        vignetteTrap->SetPosition(position_);
        vignetteTrap->SetTrapLandingPosition(playerPosition_);
        vignetteTrap->LaunchTrap();
        vignetteTrap->UpdateModel();
        pVignetteTrap_.push_back(std::move(vignetteTrap));
    }
}

void TrapEnemy::ChangeBehaviorState(std::unique_ptr<TrapEnemyBehaviorState> _pState)
{
    pBehaviorState_ = std::move(_pState);
    pBehaviorState_->Initialize();
}

void TrapEnemy::ObjectTransformSet(const Vector3& _position, const Vector3& _rotation, const Vector3& _scale)
{
    object_->SetPosition(_position);
    object_->SetRotate(_rotation);
    object_->SetScale(_scale);
}

void TrapEnemy::OnCollisionTrigger(const Collider* _other)
{
    if (_other->GetColliderID() == "PlayerBullet" && !isInvincible_)
    {
        // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®å¼¾ã¨è¡çªã—ãŸå ´åˆ
        if (hp_ > 0)
        {
            // HPæ¸›å°‘
            hp_--;

            isHit_ = true;
        }
    }
}

void TrapEnemy::OnCollision(const Collider* _other)
{
    if (_other->GetColliderID() == "NormalEnemy" or 
        _other->GetColliderID() == "TrapEnemy")
    {

        // æ•µã®ä½ç½®
        Vector3 enemyPosition = _other->GetOwner()->GetPosition();

        // æ•µåŒå£«ãŒé‡ãªã‚‰ãªã„ã‚ˆã†ã«ã™ã‚‹
        Vector3 direction = position_ - enemyPosition;
        direction.Normalize();
        float distance = 2.5f; // æ•µåŒå£«ã®é–“ã®è·é›¢ã‚’èª¿æ•´ã™ã‚‹ãŸã‚ã®å€¤

        // äº’ã„ã«é‡ãªã‚‰ãªã„ã‚ˆã†ã«å°‘ã—ãšã¤ä½ç½®ã‚’èª¿æ•´
        if ((position_ - enemyPosition).Length() < distance)
        {
            position_ += direction * 0.1f; // å¾®èª¿æ•´ã®ãŸã‚ã®å€¤
        }
    }

    if (_other->GetColliderID() == "Wall" or 
        _other->GetColliderID() == "Barrie" or
        _other->GetColliderID() == "Player")
    {
        // ç›¸æ‰‹ã®AABBã‚’å–å¾—
        const AABB* otherAABB = _other->GetAABB();
      
        if (otherAABB)
        {
            // è‡ªåˆ†ã®AABBã¨ä½ç½®ã‚’æ¸¡ã—ã¦è£œæ­£
            CorrectOverlap(*otherAABB, aabb_, position_);
        }
    }
}

std::vector<Vector3> TrapEnemy::GetRemainingTimeBombPositions() const
{
    std::vector<Vector3> positions;

	// ç”Ÿãã¦ã„ã‚‹TimeBombã®ä½ç½®ã‚’å–å¾—
    for (const auto& trap : pTimeBomb_)
    {
		// ç”Ÿãã¦ã„ã‚‹TimeBombã®ã¿å–å¾—
        if (trap && !trap->IsDead())
        {
            positions.push_back(trap->GetPosition());
        }
    }

    return positions;
}


============================================================
File Path: project/application/Objects/Enemy/TrapEnemy.h
============================================================
#pragma once

#include "../../baseObject/GameObject.h"
#include "bullet/VignetteTrap.h"
#include "bullet/TimeBomb.h"
#include "behaviorState/trapEnemyState/TrapEnemyBehaviorState.h"
#include"../../../gameEngine/collider/ColliderManager.h"
#include "../../../gameEngine/particle/ParticleEmitter.h"

#include <Object3d.h>
#include <Sprite.h>
#include <Framework.h>

/// <summary>
/// ç½ ã‚’è¨­ç½®ã—ã¦ãã‚‹æ•µ
/// </summary>
class TrapEnemy : public GameObject
{
public:

	TrapEnemy() = default;
	~TrapEnemy() = default;
	
	// åˆæœŸåŒ–
	void Initialize() override;
	
	// çµ‚äº†
	void Finalize() override;
	
	// æ›´æ–°
	void Update() override;
	
	// æç”»
	void Draw() override;
	
	// ã‚¹ãƒ—ãƒ©ã‚¤ãƒˆæç”»
	void Draw2D();
	
	// ImGui
	void ImGuiDraw();

	// ç§»å‹•
	void Move();

	// ç½ åˆæœŸåŒ–
	void TrapInit();

	/// <summary>
	/// è¡Œå‹•ã‚¹ãƒ†ãƒ¼ãƒˆåˆ‡ã‚Šæ›¿ãˆ
	/// </summary>
	/// <param name="_pState">æ–°ã—ã„ã‚¹ãƒ†ãƒ¼ãƒˆã®ãƒã‚¤ãƒ³ã‚¿</param>
	void ChangeBehaviorState(std::unique_ptr<TrapEnemyBehaviorState> _pState);

private: // è¡çªåˆ¤å®š

	/// <summary>
	/// è¡çªæ™‚ã®å‡¦ç†
	/// </summary>
	/// <param name="_other">è¡çªç›¸æ‰‹ã®ã‚³ãƒ©ã‚¤ãƒ€ãƒ¼</param>
	void OnCollisionTrigger(const Collider* _other);

	/// <summary>
	/// è¡çªä¸­ã®å‡¦ç†
	/// </summary>
	/// <param name="_other">è¡çªç›¸æ‰‹ã®ã‚³ãƒ©ã‚¤ãƒ€ãƒ¼</param>
	void OnCollision(const Collider* _other);

public: // ã‚²ãƒƒã‚¿ãƒ¼

	// è¢«å¼¾ãƒ•ãƒ©ã‚°
	bool IsHit() const { return isHit_; }
	// ç½ è¨­ç½®ã®ã‚¯ãƒ¼ãƒ«ã‚¿ã‚¤ãƒ å®Œäº†ãƒ•ãƒ©ã‚°
	bool IsTrapCooldownComplete() const { return isTrapCooldownComplete_; }
	// ç½ ã‚’è¨­ç½®ã™ã‚‹è·é›¢ã‹ã©ã†ã‹ã®ãƒ•ãƒ©ã‚°
	bool IsStopAndTrap() const { return isStopAndTrap_; }

	// æ®‹ã£ã¦ã„ã‚‹TimeBombã®åº§æ¨™ã‚’å–å¾—
	std::vector<Vector3> GetRemainingTimeBombPositions() const;

public: // ã‚»ãƒƒã‚¿ãƒ¼

	/// <summary>
	/// ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®ä½ç½®ã‚’ã‚»ãƒƒãƒˆ
	/// </summary>
	/// <param name="_playerPosition">ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®ä½ç½®</param>
	Vector3 SetPlayerPosition(const Vector3& _playerPosition) { return playerPosition_ = _playerPosition; }

	/// <summary>
	/// ç„¡æ•µãƒ•ãƒ©ã‚°ã‚’ã‚»ãƒƒãƒˆ
	/// </summary>
	/// <param name="_isInvincible">ç„¡æ•µãƒ•ãƒ©ã‚°</param>
	void SetIsInvincible(bool _isInvincible) { isInvincible_ = _isInvincible; }

	/// <summary>
	/// è¢«å¼¾ãƒ•ãƒ©ã‚°ã‚’ã‚»ãƒƒãƒˆ
	/// </summary>
	/// <param name="_isHit">è¢«å¼¾ãƒ•ãƒ©ã‚°</param>
	void SetIsHit(bool _isHit) { isHit_ = _isHit; }

	// ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®positionã‚’ã‚»ãƒƒãƒˆ
	void SetObjectPosition(const Vector3& _position) { object_->SetPosition(_position); }
	// ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®rotationã‚’ã‚»ãƒƒãƒˆ
	void SetObjectRotation(const Vector3& _rotation) { object_->SetRotate(_rotation); }
	// ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®scaleã‚’ã‚»ãƒƒãƒˆ
	void SetObjectScale(const Vector3& _scale) { object_->SetScale(_scale); }

	// ç½ è¨­ç½®å®Œäº†ãƒ•ãƒ©ã‚°ã‚»ãƒƒãƒˆ
	void SetIsTrapCooldownComplete(bool _isTrapCooldownComplete) { isTrapCooldownComplete_ = _isTrapCooldownComplete; }
	// æ¬¡ã®ç½ ãŒTimeBombã‹VignetteTrapã‹ã®ãƒ•ãƒ©ã‚°åè»¢
	void ChangeIsNextTrapTimeBomb() { isNextTrapTimeBomb_ = !isNextTrapTimeBomb_; }

	/// <summary>
	/// objectã®transformã‚’ã‚»ãƒƒãƒˆ
	/// </summary>
	/// <param name="_position">ä½ç½®</param>
	/// <param name="_rotation">å›žè»¢</param>
	/// <param name="_scale">ã‚¹ã‚±ãƒ¼ãƒ«</param>
	void ObjectTransformSet(const Vector3& _position, const Vector3& _rotation, const Vector3& _scale);

private:

	static constexpr float kDefaultFrameRate = 60.0f;

	// 3Dã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ
	std::unique_ptr<Object3d> object_ = nullptr;

	// å½“ãŸã‚Šåˆ¤å®šé–¢ä¿‚
	ColliderManager* colliderManager_ = nullptr;
	Collider collider_;
	AABB aabb_;
	Collider::ColliderDesc desc = {};

	// ç§»å‹•é€Ÿåº¦
	Vector3 moveVelocity_{};
	float moveSpeed_ = 0.05f;

	// ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®ä½ç½®
	Vector3 playerPosition_{};
	Vector3 toPlayer_{};
	// è¿½å°¾åœæ­¢è·é›¢
	const float kTooCloseDistance = 6.0f;
	// è¿½å°¾é–‹å§‹è·é›¢
	const float kTooFarDistance = 20.0f;

	// ç½ 
	std::vector<std::unique_ptr<TimeBomb>> pTimeBomb_ = {};
	std::vector<std::unique_ptr<VignetteTrap>> pVignetteTrap_ = {};
	
	// ã‚¯ãƒ¼ãƒ«ã‚¿ã‚¤ãƒ å®Œäº†ãƒ•ãƒ©ã‚°
	bool isTrapCooldownComplete_ = false;
	// æ¬¡ã®ç½ ãŒTimeBombã‹VignetteTrapã‹ã®ãƒ•ãƒ©ã‚°
	bool isNextTrapTimeBomb_ = true;

	// è¡Œå‹•ã‚¹ãƒ†ãƒ¼ãƒˆ
	std::unique_ptr<TrapEnemyBehaviorState> pBehaviorState_ = nullptr;

	// é›¢ã‚Œã‚‹
	bool isEscape_ = false;
	// è¿‘ã¥ã
	bool isApproach_ = false;
	// ç½ ã‚’è¨­ç½®ã™ã‚‹
	bool isStopAndTrap_ = false;


	// ç„¡æ•µãƒ•ãƒ©ã‚°(å‡ºç¾æ™‚ç­‰æ”»æ’ƒã‚’å—ã‘ãªãã•ã›ã‚‹)
	bool isInvincible_ = true;

	// è¢«å¼¾ãƒ•ãƒ©ã‚°
	bool isHit_ = false;

};



============================================================
File Path: project/application/Objects/Enemy/WaveState/EnemyWaveStage1.cpp
============================================================
#include "EnemyWaveStage1.h"

#include "../EnemyManager.h"
#include "EnemyWaveStage2.h"

EnemyWaveStage1::EnemyWaveStage1(EnemyManager* _pEnemyManager) : EnemyWaveState("Stage1", _pEnemyManager)
{
}

void EnemyWaveStage1::Initialize()
{
	// CSVãƒ•ã‚¡ã‚¤ãƒ«ã®èª­ã¿è¾¼ã¿
	LoadCSV("resources/csv/EnemyPop1.csv");

	// EnemyManagerã‹ã‚‰å…±æœ‰LevelDataã‚’å—ã‘å–ã‚‹
	SetLevelData(pEnemyManager_->GetLevelData());

	currentWave_ = 1;
}

void EnemyWaveStage1::Update()
{
	// ç¢ºèªç”¨csvæ›´æ–°
	//UpdateCSV(pEnemyManager_);

	// æ•µã®ç™ºç”Ÿã‚³ãƒžãƒ³ãƒ‰ã‚’æ›´æ–°
	UpdateEnemyPopCommands(pEnemyManager_);

	// ã‚¹ãƒ†ãƒ¼ãƒˆåˆ‡ã‚Šæ›¿ãˆ
	if (pEnemyManager_->IsWaveChange())
	{
		// ã‚¹ãƒ†ãƒ¼ãƒˆé·ç§»
		pEnemyManager_->ChangeState(std::make_unique<EnemyWaveStage2>(pEnemyManager_));
	}
}


============================================================
File Path: project/application/Objects/Enemy/WaveState/EnemyWaveStage1.h
============================================================
#pragma once

#include "EnemyWaveState.h"

/// <summary>
/// æ•µã®ã‚¦ã‚§ãƒ¼ãƒ–ã‚¹ãƒ†ãƒ¼ãƒˆ1
/// ã‚¦ã‚§ãƒ¼ãƒ–1
/// </summary>
class EnemyWaveStage1 : public EnemyWaveState
{
public:

	/// <summary>
	/// ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿
	/// </summary>
	/// <param name="_pEnemyManager">ã‚¨ãƒãƒŸãƒ¼ãƒžãƒãƒ¼ã‚¸ãƒ£ãƒ¼ã®ãƒã‚¤ãƒ³ã‚¿</param>
	EnemyWaveStage1(EnemyManager* _pEnemyManager);
	
	// åˆæœŸåŒ–
	void Initialize() override;

	// æ›´æ–°
	void Update() override;

};



============================================================
File Path: project/application/Objects/Enemy/WaveState/EnemyWaveStage2.cpp
============================================================
#include "EnemyWaveStage2.h"

#include "../EnemyManager.h"

EnemyWaveStage2::EnemyWaveStage2(EnemyManager* _pEnemyManager) : EnemyWaveState("Stage1", _pEnemyManager)
{
}

void EnemyWaveStage2::Initialize()
{
	// CSVãƒ•ã‚¡ã‚¤ãƒ«ã®èª­ã¿è¾¼ã¿
	LoadCSV("resources/csv/EnemyPop2.csv");

	// EnemyManagerã‹ã‚‰å…±æœ‰LevelDataã‚’å—ã‘å–ã‚‹
	SetLevelData(pEnemyManager_->GetLevelData());

	currentWave_ = 2;
}

void EnemyWaveStage2::Update()
{
	// ç¢ºèªç”¨csvæ›´æ–°
	//UpdateCSV(pEnemyManager_);

	// æ•µã®ç™ºç”Ÿã‚³ãƒžãƒ³ãƒ‰ã‚’æ›´æ–°
	UpdateEnemyPopCommands(pEnemyManager_);

	// ã‚¹ãƒ†ãƒ¼ãƒˆåˆ‡ã‚Šæ›¿ãˆ
	if (pEnemyManager_->IsWaveChange())
	{
		// ã‚¹ãƒ†ãƒ¼ãƒˆé·ç§»3ã‚’ä½œã£ãŸã‚‰ã“ã“ã«è¿½è¨˜

		// ä»Šã¯ã“ã®ã‚¦ã‚§ãƒ¼ãƒ–ã‚’ã‚¯ãƒªã‚¢ã—ãŸã‚‰ã‚²ãƒ¼ãƒ ã‚¯ãƒªã‚¢
		pEnemyManager_->SetAllEnemyDefeated(true);
	}
}


============================================================
File Path: project/application/Objects/Enemy/WaveState/EnemyWaveStage2.h
============================================================
#pragma once

#include "EnemyWaveState.h"

/// <summary>
/// æ•µã®ã‚¦ã‚§ãƒ¼ãƒ–ã‚¹ãƒ†ãƒ¼ãƒˆ
/// ã‚¦ã‚§ãƒ¼ãƒ–2
/// </summary>
class EnemyWaveStage2 : public EnemyWaveState
{
public:

	/// <summary>
	/// ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿
	/// </summary>
	/// <param name="_pEnemyManager">ã‚¨ãƒãƒŸãƒ¼ãƒžãƒãƒ¼ã‚¸ãƒ£ãƒ¼ã®ãƒã‚¤ãƒ³ã‚¿</param>
	EnemyWaveStage2(EnemyManager* _pEnemyManager);

	// åˆæœŸåŒ–
	void Initialize() override;

	// æ›´æ–°
	void Update() override;
};



============================================================
File Path: project/application/Objects/Enemy/WaveState/EnemyWaveState.cpp
============================================================
#include "EnemyWaveState.h"

#include "../EnemyManager.h"

#include <cassert>

EnemyWaveState::~EnemyWaveState()
{
}

void EnemyWaveState::LoadCSV(const std::string& csvPath)
{
	// CSVãƒ•ã‚¡ã‚¤ãƒ«ã®èª­ã¿è¾¼ã¿
	//ãƒ•ã‚¡ã‚¤ãƒ«ã‚’é–‹ã
	std::ifstream file(csvPath);
	assert(file.is_open());

	//ãƒ•ã‚¡ã‚¤ãƒ«ã®å†…å®¹ã‚’æ–‡å­—åˆ—ã‚¹ãƒˆãƒªãƒ¼ãƒ ã«ã‚³ãƒ”ãƒ¼
	enemyPopCommands_ << file.rdbuf();

	//ãƒ•ã‚¡ã‚¤ãƒ«ã‚’é–‰ã˜ã‚‹
	file.close();
}

void EnemyWaveState::UpdateEnemyPopCommands(EnemyManager* _pEnemyManager)
{
	enemyWaitingTimer_++; // æ¯Žãƒ•ãƒ¬ãƒ¼ãƒ ã‚«ã‚¦ãƒ³ãƒˆ

    for (auto& enemy : levelData_->enemies)
    {
        if (!enemy.isSpawned && enemy.waveNum == currentWave_ && enemyWaitingTimer_ >= enemy.spawnDelay)
        {
            // æ•µã‚’å‡ºç¾
            _pEnemyManager->NormalEnemyInit(enemy.position);
            enemy.isSpawned = true;

            // ã‚¿ã‚¤ãƒžãƒ¼ã‚’ãƒªã‚»ãƒƒãƒˆã—ã¦ã€æ¬¡ã®æ•µã®delayã‚«ã‚¦ãƒ³ãƒˆé–‹å§‹
            enemyWaitingTimer_ = 0;

            // 1ãƒ•ãƒ¬ãƒ¼ãƒ ã«è¤‡æ•°å‡ºã•ãªã„ã‚ˆã†ã« break
            break;
        }
    }

    for (auto& trapEnemy : levelData_->trapEnemies)
    {
        if (!trapEnemy.isSpawned && trapEnemy.waveNum == currentWave_ && enemyWaitingTimer_ >= trapEnemy.spawnDelay)
        {
            // æ•µã‚’å‡ºç¾
            _pEnemyManager->TrapEnemyInit(trapEnemy.position);
            trapEnemy.isSpawned = true;
           
            // ã‚¿ã‚¤ãƒžãƒ¼ã‚’ãƒªã‚»ãƒƒãƒˆã—ã¦ã€æ¬¡ã®æ•µã®delayã‚«ã‚¦ãƒ³ãƒˆé–‹å§‹
            enemyWaitingTimer_ = 0;
            
            // 1ãƒ•ãƒ¬ãƒ¼ãƒ ã«è¤‡æ•°å‡ºã•ãªã„ã‚ˆã†ã« break
            break;
        }
	}
}

void EnemyWaveState::UpdateCSV(EnemyManager* _pEnemyManager)
{
    //å¾…æ©Ÿå‡¦ç†
    if (isEnemyWaiting_) 
    {
        if (debugCount_ > 0)
        {
            debugCount_--;
        }

    	if (debugCount_ == 0)
    	{
    		isEnemyWaiting_ = false;
    	}
    	return;
    }

    std::string line;

    while (getline(enemyPopCommands_, line)) 
    {
    	std::istringstream line_stream(line);
    	std::string word;

    	getline(line_stream, word, ','); // ã‚³ãƒžãƒ³ãƒ‰å–å¾—

    	// ã‚³ãƒ¡ãƒ³ãƒˆè¡Œã‚’ã‚¹ã‚­ãƒƒãƒ—
    	if (word.find("//") == 0)
    	{
    		continue;
    	}

    	// POSITONã‚³ãƒžãƒ³ãƒ‰ï¼ˆNormalEnemy or TrapEnemyï¼‰
    	if (word == "POSITION")
    	{

    		// æ•µã‚¿ã‚¤ãƒ—ï¼ˆä¾‹: "Normal", "Trap"ï¼‰
    		std::string enemyType;
    		getline(line_stream, enemyType, ',');

    		// X, Y, Z åº§æ¨™ã‚’å–å¾—
    		getline(line_stream, word, ',');
    		float x = static_cast<float>(atof(word.c_str()));

    		getline(line_stream, word, ',');
    		float y = static_cast<float>(atof(word.c_str()));

    		getline(line_stream, word, ',');
    		float z = static_cast<float>(atof(word.c_str()));

    		if (enemyType == "Normal")
    		{
    			_pEnemyManager->NormalEnemyInit({ x, y, z });
    		} 
    		else if (enemyType == "Trap") 
    		{
    			_pEnemyManager->TrapEnemyInit({ x, y, z });
    		}
    	}
    	// WAITã‚³ãƒžãƒ³ãƒ‰
    	else if (word == "WAIT")
    	{
    		getline(line_stream, word, ',');
    		int waitTime = atoi(word.c_str());

    		isEnemyWaiting_ = true;
            debugCount_ = waitTime;
    		break;
    	}
    }
}


============================================================
File Path: project/application/Objects/Enemy/WaveState/EnemyWaveState.h
============================================================
#pragma once

#include <sstream>

#include "../../../../gameEngine/level_editor/LevelDataLoader.h"

class EnemyManager;

/// <summary>
/// é€šå¸¸æ•µã®ã‚¦ã‚§ãƒ¼ãƒ–ã‚¹ãƒ†ãƒ¼ãƒˆ
/// é€šå¸¸æ•µã®ç™ºç”Ÿã‚’ç®¡ç†
/// </summary>
class EnemyWaveState
{
public:

	/// <summary>
	/// ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿
	/// </summary>
	/// <param name="_wave">ã‚¦ã‚§ãƒ¼ãƒ–å</param>
	/// <param name="_pEnemyManager">ã‚¨ãƒãƒŸãƒ¼ãƒžãƒãƒ¼ã‚¸ãƒ£ãƒ¼ã®ãƒã‚¤ãƒ³ã‚¿</param>
	EnemyWaveState(const std::string& _wave, EnemyManager* _pEnemyManager) : wave_(_wave), pEnemyManager_(_pEnemyManager) {};
	
	virtual~EnemyWaveState();

	// åˆæœŸåŒ–
	virtual void Initialize() = 0;
	
	// æ›´æ–°
	virtual void Update() = 0;

public: // ã‚»ãƒƒã‚¿ãƒ¼

	/// <summary>
	/// ã‚¨ãƒ‡ã‚£ã‚¿ã‚»ãƒƒãƒˆ
	/// </summary>
	/// <param name="_levelData">ãƒ¬ãƒ™ãƒ«ãƒ‡ãƒ¼ã‚¿ãƒ­ãƒ¼ãƒ€ãƒ¼</param>
	void SetLevelData(std::shared_ptr<LevelData> _levelData) { levelData_ = _levelData; }

protected:

	/// <summary>
	/// CSVãƒ•ã‚¡ã‚¤ãƒ«ã®èª­ã¿è¾¼ã¿
	/// </summary>
	/// <param name="csvPath">CSVãƒ•ã‚¡ã‚¤ãƒ«ã®ãƒ‘ã‚¹</param>
	void LoadCSV(const std::string& csvPath);

	/// <summary>
	/// æ•µã®ç™ºç”Ÿã‚³ãƒžãƒ³ãƒ‰ã‚’æ›´æ–°
	/// </summary>
	/// <param name="_pEnemyManager">ã‚¨ãƒãƒŸãƒ¼ãƒžãƒãƒ¼ã‚¸ãƒ£ãƒ¼ã®ãƒã‚¤ãƒ³ã‚¿</param>
	void UpdateEnemyPopCommands(EnemyManager* _pEnemyManager);

	/// <summary>
	/// csvã®æ›´æ–°
	/// </summary>
	/// <param name="_pEnemyManager">ã‚¨ãƒãƒŸãƒ¼ãƒžãƒãƒ¼ã‚¸ãƒ£ãƒ¼ã®ãƒã‚¤ãƒ³ã‚¿</param>
	void UpdateCSV(EnemyManager* _pEnemyManager);

	std::string wave_;
	EnemyManager* pEnemyManager_ = nullptr;

	
	// æ•µå¾…æ©Ÿã‚¿ã‚¤ãƒžãƒ¼
	uint32_t enemyWaitingTimer_ = 9;

	// ãƒ¬ãƒ™ãƒ«ãƒ‡ãƒ¼ã‚¿ãƒ­ãƒ¼ãƒ€ãƒ¼
	std::shared_ptr<LevelData> levelData_ = nullptr;

	// ç¾åœ¨ã®ã‚¦ã‚§ãƒ¼ãƒ–
	uint32_t currentWave_ = 1;



	// æ•µã®ç™ºç”Ÿã‚³ãƒžãƒ³ãƒ‰
	std::stringstream enemyPopCommands_;
	// æ•µæ©Ÿä¸­ãƒ•ãƒ©ã‚°
	bool isEnemyWaiting_ = true;
	// ç¢ºèªç”¨csvæ›´æ–°ç”¨ã‚«ã‚¦ãƒ³ãƒˆ
	uint32_t debugCount_ = 9;
};



============================================================
File Path: project/application/Objects/Field/Barrie.cpp
============================================================
#include "Barrie.h"

void Barrie::Initialize()
{
	// --- 3Dã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ ---
	object_ = std::make_unique<Object3d>();
	object_->Initialize("barrie.obj");
	object_->SetRotate(rotation_);

	// å¤§ãã•ã‚»ãƒƒãƒˆ
	scale_ = defaultScale_;
	targetScale_ = defaultScale_;
	object_->SetScale(scale_);
	// ãƒ©ã‚¤ãƒˆè¨­å®š
	//object_->SetDirectionalLightEnable(true);
	object_->SetLighting(true);

	// å½“ãŸã‚Šåˆ¤å®š
	colliderManager_ = ColliderManager::GetInstance();
	objectName_ = "Barrie";
	desc =
	{
		//ã“ã“ã«è¨­å®š
		.owner = this,
		.colliderID = objectName_,
		.shape = Shape::AABB,
		.shapeData = &aabb_,
		.attribute = colliderManager_->GetNewAttribute(objectName_),
		.onCollisionTrigger = std::bind(&Barrie::OnCollisionTrigger, this, std::placeholders::_1),
	};
	collider_.MakeAABBDesc(desc);
	colliderManager_->RegisterCollider(&collider_);

}

void Barrie::Finalize()
{
	colliderManager_->DeleteCollider(&collider_);
}

void Barrie::Update()
{
	// ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®æ›´æ–°
	object_->SetPosition(position_);
	object_->SetRotate(rotation_);
	object_->SetScale(scale_);
	object_->Update();

	// å½“ãŸã‚Šåˆ¤å®šæ›´æ–°
	aabb_.min = position_ - object_->GetScale();
	aabb_.max = position_ + object_->GetScale();
	aabb_.max.y += 1.0f; // è¦‹ãŸç›®ã‚ˆã‚Šã‚‚ç¸¦ã«å¤§ãã
	collider_.SetPosition(position_);


	// ã‚¹ã‚±ãƒ¼ãƒ«ã‚’è£œé–“ã—ã¦å…ƒã«æˆ»ã™
	/*scale_ += (targetScale_ - scale_) * scaleLerpSpeed_;
	object_->SetScale(scale_);*/

	// ãƒãƒªã‚¢ç ´å£Šå‡¦ç†
	if (isBarrierDestroyed_ && !isExploding_)
	{
		isExploding_ = true;
		explodeCount_ = 0;
	}

	// ç ´è£‚æ¼”å‡ºå‡¦ç†
	if (isExploding_)
	{
		uint32_t phaseLength = explodeMaxCount_ / 2;
		float scale = 1.0f;

		if (explodeCount_ < phaseLength)
		{
			// è†¨å¼µ
			float t = static_cast<float>(explodeCount_) / phaseLength;
			scale = Lerp(1.0f, 2.5f, t);
		} else if (explodeCount_ < phaseLength * 2) {
			// æ¶ˆæ»…
			float t = static_cast<float>(explodeCount_ - phaseLength) / phaseLength;
			scale = Lerp(2.5f, 0.0f, t);
		}

		// ã‚¹ã‚±ãƒ¼ãƒ«é©ç”¨
		scale_ = defaultScale_ * scale;
		object_->SetScale(scale_);

		// ã‚«ã‚¦ãƒ³ã‚¿æ›´æ–°
		explodeCount_++;

		// æ¼”å‡ºçµ‚äº†
		if (explodeCount_ >= explodeMaxCount_)
		{
			scale_ = { 0.0f, 0.0f, 0.0f };
			object_->SetScale(scale_);
			isExploding_ = false;

			// ç ´å£Šãƒ•ãƒ©ã‚°ã‚’ãƒªã‚»ãƒƒãƒˆ
			isBarrierDestroyed_ = false;

			// ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«
			ParticleEmitter::Emit("sparkBurst", position_ , 8);

		}

		// è£œé–“å¾Œå‡¦ç†
		if ((scale_ - defaultScale_).Length() < 0.01f)
		{
			targetScale_ = defaultScale_;
		}

	}

	if (scale_.x >= 0.1f)
	{
		// ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«
		ParticleEmitter::Emit("spark", { position_.x,position_.y + 3.0f,position_.z }, 1);
	}
}

void Barrie::Draw()
{
	object_->Draw();
}

void Barrie::OnCollisionTrigger(const Collider* _other)
{
	if (_other->GetColliderID() == "PlayerBullet" or
		_other->GetColliderID() == "Player" or
		_other->GetColliderID() == "TrapEnemy" or
		_other->GetColliderID() == "NormalEnemy" or
		_other->GetColliderID() == "EnemyBullet" or
		_other->GetColliderID() == "VignetteTrap" or
		_other->GetColliderID() == "SetTimeBomb")
	{
		// ä¸€çž¬å¤§ããã—ã€å…ƒã«æˆ»ã™
		targetScale_ = defaultScale_ * 1.5f;
	}
	
}


============================================================
File Path: project/application/Objects/Field/Barrie.h
============================================================
#pragma once

#include "../../baseObject/GameObject.h"
#include "../../../gameEngine/collider/ColliderManager.h"
#include "../../../gameEngine/particle/ParticleEmitter.h"

#include <Object3d.h>
#include <memory>
#include <Framework.h>

/// <summary>
/// ãƒãƒªã‚¢
/// ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚’å®ˆã‚‹ãƒãƒªã‚¢ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ
/// </summary>
class Barrie : public GameObject
{
public:

	Barrie() = default;
	~Barrie() = default;

	// åˆæœŸåŒ–
	void Initialize() override;

	// çµ‚äº†
	void Finalize() override;

	// æ›´æ–°
	void Update() override;

	// æç”»
	void Draw() override;


public: // ã‚»ãƒƒã‚¿ãƒ¼

	/// <summary>
	/// ãƒãƒªã‚¢ç ´å£Šãƒ•ãƒ©ã‚°ã‚’ã‚»ãƒƒãƒˆ
	/// </summary>
	/// <param name="_isDestroyed"> ç ´å£Šãƒ•ãƒ©ã‚°</param>
	void SetBarrierDestroyed(bool _isDestroyed) { isBarrierDestroyed_ = _isDestroyed; }

private: // è¡çªåˆ¤å®š

	/// <summary>
	/// å½“ãŸã‚Šåˆ¤å®šå‡¦ç†
	/// </summary>
	/// <param name="_other"> è¡çªç›¸æ‰‹ã®ã‚³ãƒ©ã‚¤ãƒ€ãƒ¼</param>
	void OnCollisionTrigger(const Collider* _other);

private:

	// 3Dã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ
	std::unique_ptr<Object3d> object_ = nullptr;

	// å½“ãŸã‚Šåˆ¤å®šé–¢ä¿‚
	ColliderManager* colliderManager_ = nullptr;
	Collider collider_;
	AABB aabb_;
	Collider::ColliderDesc desc = {};

	// ãƒãƒªã‚¢ç ´å£Šãƒ•ãƒ©ã‚°
	bool isBarrierDestroyed_ = false;

	// å…ƒã®ã‚¹ã‚±ãƒ¼ãƒ«
	Vector3 defaultScale_ = { 1.5f, 1.5f, 1.5f };
	// ç›®æ¨™ã‚¹ã‚±ãƒ¼ãƒ«
	Vector3 targetScale_ = { 1.5f, 1.5f, 1.5f };  
	float scaleLerpSpeed_ = 0.2f;

	// çˆ†ç™ºæ¼”å‡ºç”¨ã‚«ã‚¦ãƒ³ãƒˆ
	uint32_t explodeCount_ = 0;      
	// çˆ†ç™ºæ¼”å‡ºã®ç¶™ç¶šãƒ•ãƒ¬ãƒ¼ãƒ æ•°
	const uint32_t explodeMaxCount_ = 10; 
	bool isExploding_ = false;

};

============================================================
File Path: project/application/Objects/Field/Field.cpp
============================================================
#include "Field.h"

void Field::Initialize()
{
	// --- 3Dã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ ---
	object_ = std::make_unique<Object3d>();
	object_->Initialize("field.obj");
	
	position_ = { 0.0f,0.0f,0.0f };
	object_->SetPosition(position_);
	object_->SetRotate(rotation_);
	scale_ = { 100.0f,0.1f,100.0f };
	object_->SetScale(scale_);

	// å½“ãŸã‚Šåˆ¤å®š
	colliderManager_ = ColliderManager::GetInstance();
	objectName_ = "Field";
	desc =
	{
		//ã“ã“ã«è¨­å®š
		.owner = this,
		.colliderID = objectName_,
		.shape = Shape::AABB,
		.shapeData = &aabb_,
		.attribute = colliderManager_->GetNewAttribute(objectName_),
	};
	collider_.MakeAABBDesc(desc);
	colliderManager_->RegisterCollider(&collider_);
}

void Field::Finalize()
{
	colliderManager_->DeleteCollider(&collider_);
}

void Field::Update()
{
	object_->SetPosition(position_);
	object_->SetRotate(rotation_);
	object_->SetScale(scale_);
	object_->Update();

	aabb_.min = position_ - object_->GetScale();
	aabb_.max = position_ + object_->GetScale();
	aabb_.max.y += 1.0f;
	collider_.SetPosition(position_);
}

void Field::Draw()
{
	object_->Draw();
}

void Field::ImGuiDraw()
{
#ifdef USE_IMGUI

	ImGui::Begin("Field");

	ImGui::SliderFloat3("pos", &position_.x, -100.0f, 100.0f);
	ImGui::SliderFloat3("rot", &rotation_.x, -3.14f, 3.14f);
	ImGui::SliderFloat3("scale", &scale_.x, 0.0f, 10.0f);
	
	ImGui::End();

#endif // USE_IMGUI
}

void Field::OnCollisionTrigger()
{
	// ä½•ã‚‚ã—ãªã„
}


============================================================
File Path: project/application/Objects/Field/Field.h
============================================================
#pragma once

#include "../../baseObject/GameObject.h"
#include"../../../gameEngine/collider/ColliderManager.h"

#include <Object3d.h>
#include <memory>
#include <Framework.h>

/// <summary>
/// ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰
/// </summary>
class Field : public GameObject
{
public:
	
	Field() = default;
	~Field() = default;
	
	// åˆæœŸåŒ–
	void Initialize() override;
	
	// çµ‚äº†
	void Finalize() override;
	
	// æ›´æ–°
	void Update() override;
	
	// æç”»
	void Draw() override;

	// ImGui
	void ImGuiDraw();

private: // è¡çªåˆ¤å®š

	/// <summary>
	/// è¡çªæ™‚å‡¦ç†
	/// </summary>
	void OnCollisionTrigger();

private: // ãƒ¡ãƒ³ãƒå¤‰æ•°

	// 3Dã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ
	std::unique_ptr<Object3d> object_ = nullptr;
	
	// å½“ãŸã‚Šåˆ¤å®šé–¢ä¿‚
	ColliderManager* colliderManager_ = nullptr;
	Collider collider_;
	AABB aabb_;
	Collider::ColliderDesc desc = {};

};

============================================================
File Path: project/application/Objects/Field/Goal.cpp
============================================================
#include "Goal.h"

void Goal::Initialize()
{
	// --- 3Dã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ ---
	object_ = std::make_unique<Object3d>();
	object_->Initialize("goal.obj");
	position_ = { 0.0f,0.0f,-3.5f };
	object_->SetPosition(position_);
	object_->SetRotate(rotation_);
	scale_ = { 1.0f,1.0f,1.0f };
	object_->SetScale(scale_);
	// ãƒ©ã‚¤ãƒˆè¨­å®š
	//object_->SetDirectionalLightEnable(true);
	object_->SetLighting(true);

	// å½“ãŸã‚Šåˆ¤å®š
	colliderManager_ = ColliderManager::GetInstance();

	objectName_ = "Goal";
	desc =
	{
		//ã“ã“ã«è¨­å®š
		.owner = this,
		.colliderID = objectName_,
		.shape = Shape::AABB,
		.shapeData = &aabb_,
		.attribute = colliderManager_->GetNewAttribute(objectName_),
		.onCollisionTrigger = std::bind(&Goal::OnCollisionTrigger, this, std::placeholders::_1),
	};
	collider_.MakeAABBDesc(desc);
	colliderManager_->RegisterCollider(&collider_);

	// ãƒãƒªã‚¢
	pBarrie_ = std::make_unique<Barrie>();
	pBarrie_->SetPosition(position_);
	pBarrie_->Initialize();
}

void Goal::Finalize()
{
	colliderManager_->DeleteCollider(&collider_);
	pBarrie_->Finalize();
}

void Goal::Update()
{
	// ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®æ›´æ–°
	object_->SetPosition(position_);
	object_->SetRotate(rotation_);
	object_->SetScale(scale_);
	object_->Update();

	// ãƒãƒªã‚¢ã®æ›´æ–°
	pBarrie_->Update();

	// å½“ãŸã‚Šåˆ¤å®šæ›´æ–°
	aabb_.min = position_ - object_->GetScale();
	aabb_.max = position_ + object_->GetScale();
	aabb_.max.y += 1.0f; // è¦‹ãŸç›®ã‚ˆã‚Šã‚‚ç¸¦ã«å¤§ãã
	collider_.SetPosition(position_);

	// ãƒãƒªã‚¢ç ´å£Šã®çŠ¶æ…‹ãŒå¤‰ã‚ã£ãŸã¨ãã ã‘ä¼ãˆã‚‹
	if (isBarrierDestroyed_ && !wasBarrierDestroyed_)
	{
		pBarrie_->SetBarrierDestroyed(true);
	}
	
	// çŠ¶æ…‹ã‚’ä¿å­˜
	wasBarrierDestroyed_ = isBarrierDestroyed_;

	if (isCleared_)
	{
		ParticleEmitter::Emit("goal", position_, 2);
	}

}

void Goal::Draw()
{
	object_->Draw();
	
	pBarrie_->Draw();
}

void Goal::ImGuiDraw()
{
}

void Goal::OnCollisionTrigger(const Collider* _other)
{
	if (_other->GetColliderID() == "Player" && isBarrierDestroyed_)
	{
		// ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ãŒã‚´ãƒ¼ãƒ«ã«åˆ°é”ã—ãŸå ´åˆã‚¯ãƒªã‚¢
		isCleared_ = true;
	}
}


============================================================
File Path: project/application/Objects/Field/Goal.h
============================================================
#pragma once

#include "../../baseObject/GameObject.h"
#include "../../../gameEngine/collider/ColliderManager.h"
#include "Barrie.h"

#include <Object3d.h>
#include <memory>
#include <Framework.h>

/// <summary>
/// ã‚´ãƒ¼ãƒ«
/// </summary>
class Goal : public GameObject
{
public:

	Goal() = default;
	~Goal() = default;

	// åˆæœŸåŒ–
	void Initialize() override;

	// çµ‚äº†
	void Finalize() override;

	// æ›´æ–°
	void Update() override;

	// æç”»
	void Draw() override;

	// ImGui
	void ImGuiDraw();

public: // ã‚»ãƒƒã‚¿ãƒ¼

	/// <summary>
	/// ã‚´ãƒ¼ãƒ«å‡ºç¾ãƒ•ãƒ©ã‚°ã‚’ã‚»ãƒƒãƒˆ
	/// </summary>
	/// <param name="_isCleared"> ã‚¯ãƒªã‚¢ãƒ•ãƒ©ã‚°</param>
	void SetBarrierDestroyed(bool _isDestroyed) { isBarrierDestroyed_ = _isDestroyed; }
	
public: // ã‚²ãƒƒã‚¿ãƒ¼

	// ã‚¯ãƒªã‚¢ãƒ•ãƒ©ã‚°ã‚’å–å¾—
	bool IsCleared() const { return isCleared_; }


private: // è¡çªåˆ¤å®š

	/// <summary>
	/// å½“ãŸã‚Šåˆ¤å®šå‡¦ç†
	/// </summary>
	/// <param name="_other"> è¡çªç›¸æ‰‹ã®ã‚³ãƒ©ã‚¤ãƒ€ãƒ¼</param>
	void OnCollisionTrigger(const Collider* _other);

private:

	// 3Dã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ
	std::unique_ptr<Object3d> object_ = nullptr;

	// ãƒãƒªã‚¢
	std::unique_ptr<Barrie> pBarrie_ = nullptr;

	// å½“ãŸã‚Šåˆ¤å®šé–¢ä¿‚
	ColliderManager* colliderManager_ = nullptr;
	Collider collider_;
	AABB aabb_;
	Collider::ColliderDesc desc = {};

	// ã‚¯ãƒªã‚¢ãƒ•ãƒ©ã‚°
	bool isCleared_ = false;

	// ãƒãƒªã‚¢ç ´å£Šãƒ•ãƒ©ã‚°
	bool isBarrierDestroyed_ = false;
	bool wasBarrierDestroyed_ = false;

};

============================================================
File Path: project/application/Objects/Field/Wall.cpp
============================================================
#include "Wall.h"

void Wall::Initialize()
{
	// --- 3Dã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ ---
	object_ = std::make_unique<Object3d>();
	object_->Initialize("wall.obj");
	position_ = { 0.0f,0.0f,-0.5f };
	object_->SetPosition(position_);
	object_->SetRotate(rotation_);
	scale_ = { 1.5f,3.0f,1.0f };
	object_->SetScale(scale_);
	
	// ãƒ©ã‚¤ãƒˆè¨­å®š
	//object_->SetDirectionalLightEnable(true);
	object_->SetLighting(true);

	// å½“ãŸã‚Šåˆ¤å®š
	colliderManager_ = ColliderManager::GetInstance();

	objectName_ = "Wall";
	desc =
	{
		//ã“ã“ã«è¨­å®š
		.owner = this,
		.colliderID = objectName_,
		.shape = Shape::AABB,
		.shapeData = &aabb_,
		.attribute = colliderManager_->GetNewAttribute(objectName_),
	};
	
	collider_.MakeAABBDesc(desc);
	colliderManager_->RegisterCollider(&collider_);
}

void Wall::Finalize()
{
	colliderManager_->DeleteCollider(&collider_);
}

void Wall::Update()
{
	// ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®æ›´æ–°
	object_->SetPosition(position_);
	object_->SetRotate(rotation_);
	object_->SetScale(scale_);
	object_->Update();

	// å½“ãŸã‚Šåˆ¤å®šæ›´æ–°
	aabb_.min = position_ - object_->GetScale();
	aabb_.max = position_ + object_->GetScale();
	aabb_.max.y += 1.0f; // è¦‹ãŸç›®ã‚ˆã‚Šã‚‚ç¸¦ã«å¤§ãã
	collider_.SetPosition(position_);
}

void Wall::Draw()
{
	object_->Draw();
}

void Wall::ImGuiDraw()
{
#ifdef USE_IMGUI

	ImGui::Begin("Wall");

	ImGui::SliderFloat3("pos", &position_.x, -100.0f, 100.0f);
	ImGui::SliderFloat3("rot", &rotation_.x, -3.14f, 3.14f);
	ImGui::SliderFloat3("scale", &scale_.x, 0.0f, 10.0f);
	
	ImGui::End();

#endif // USE_IMGUI
}

void Wall::OnCollisionTrigger()
{
	// ã¨ã‚Šã‚ãˆãšä½•ã‚‚ã—ãªã„
}


============================================================
File Path: project/application/Objects/Field/Wall.h
============================================================
#pragma once

#include "../../baseObject/GameObject.h"
#include"../../../gameEngine/collider/ColliderManager.h"

#include <Object3d.h>
#include <memory>
#include <Framework.h>

/// <summary>
/// å£ã‚¯ãƒ©ã‚¹
/// </summary>
class Wall : public GameObject
{
public:

	Wall() = default;
	~Wall() = default;

	// åˆæœŸåŒ–
	void Initialize() override;
	
	// çµ‚äº†
	void Finalize() override;
	
	// æ›´æ–°
	void Update() override;
	
	// æç”»
	void Draw() override;
	
	// ImGui
	void ImGuiDraw();

private: // è¡çªåˆ¤å®š

	// è¡çªæ™‚ã‚³ãƒ¼ãƒ«ãƒãƒƒã‚¯
	void OnCollisionTrigger();

private:

	// 3Dã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ
	std::unique_ptr<Object3d> object_ = nullptr;

	// å½“ãŸã‚Šåˆ¤å®šé–¢ä¿‚
	ColliderManager* colliderManager_ = nullptr;
	Collider collider_;
	AABB aabb_;
	Collider::ColliderDesc desc = {};

};



============================================================
File Path: project/application/Objects/Player/Bullet/PlayerBullet.cpp
============================================================
#include "PlayerBullet.h"
#include "TimeManager.h"

void PlayerBullet::Initialize()
{
	// --- 3Dã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ ---
  	object_ = std::make_unique<Object3d>();
	object_->Initialize("playerBullet.obj");

	object_->SetPosition(position_);
	object_->SetRotate(rotation_);
	scale_ = { 0.5f,0.5f,0.5f };
	object_->SetScale(scale_);
	// ãƒ©ã‚¤ãƒˆè¨­å®š
	//object_->SetDirectionalLightEnable(true);
	object_->SetLighting(true);

	// å½“ãŸã‚Šåˆ¤å®š
	colliderManager_ = ColliderManager::GetInstance();

	objectName_ = "PlayerBullet";

	desc =
	{
		//ã“ã“ã«è¨­å®š
		.owner = this,
		.colliderID = objectName_,
		.shape = Shape::AABB,
		.shapeData = &aabb_,
		.attribute = colliderManager_->GetNewAttribute(objectName_),
		.onCollisionTrigger = std::bind(&PlayerBullet::OnCollisionTrigger, this, std::placeholders::_1),
	};
	collider_.MakeAABBDesc(desc);
	colliderManager_->RegisterCollider(&collider_);


}

void PlayerBullet::Finalize()
{
	colliderManager_->DeleteCollider(&collider_);
}

void PlayerBullet::Update()
{
	const float dt = TimeManager::Instance().GetDeltaTime();

	object_->Update();

	object_->SetPosition(position_);
	object_->SetRotate(rotation_);
	object_->SetScale(scale_);

	rotation_.y += 1.0f * dt * PlayerBullet::kDefaultFrameRate;
	position_ += velocity_ * dt;

	aabb_.min = position_ - object_->GetScale();
	aabb_.max = position_ + object_->GetScale();
	collider_.SetPosition(position_);

	// ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«
	ParticleEmitter::Emit("slash", position_, 1);

	//æ™‚é–“çµŒéŽã§ãƒ‡ã‚¹
	deathRemainingSeconds_ -= dt;
	if (deathRemainingSeconds_ <= 0.0f)
	{
		isDead_ = true;
	}


}

void PlayerBullet::Draw()
{
	object_->Draw();
}

void PlayerBullet::Draw2D()
{
}

void PlayerBullet::ImGuiDraw()
{
#ifdef USE_IMGUI

	ImGui::Begin("PlayerBullet");
	
	ImGui::SliderFloat3("position", &position_.x, -30.0f, 30.0f);
	ImGui::SliderFloat3("rotation", &rotation_.x, -3.14f, 3.14f);
	ImGui::SliderFloat3("scale", &scale_.x, 0.0f, 10.0f);
	
	ImGui::End();

#endif // USE_IMGUI
}

void PlayerBullet::OnCollisionTrigger(const Collider* _other)
{
	if (_other->GetColliderID() != "Player" && _other->GetColliderID() != "Field")
	{
		isDead_ = true;
	}  
}

============================================================
File Path: project/application/Objects/Player/Bullet/PlayerBullet.h
============================================================
#pragma once

#include "../../../baseObject/GameObject.h"
#include "../../../../gameEngine/collider/ColliderManager.h"
#include "../../../../gameEngine/particle/ParticleEmitter.h"

#include <Object3d.h>
#include <Sprite.h>

/// <summary>
/// ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼å¼¾ã‚¯ãƒ©ã‚¹
/// </summary>
class PlayerBullet : public GameObject
{
public:

	PlayerBullet() = default;
	~PlayerBullet() = default;
	
	// åˆæœŸåŒ–
	void Initialize() override;
	
	// çµ‚äº†
	void Finalize() override;
	
	// æ›´æ–°
	void Update() override;
	
	// æç”»
	void Draw() override;
	
	// ã‚¹ãƒ—ãƒ©ã‚¤ãƒˆæç”»
	void Draw2D();
	
	// ImGui
	void ImGuiDraw();
	
private: // è¡çªåˆ¤å®š

	/// <summary>
	/// è¡çªæ™‚å‡¦ç†
	/// </summary>
	/// <param name="_other">è¡çªç›¸æ‰‹ã®ã‚³ãƒ©ã‚¤ãƒ€ãƒ¼</param>
	void OnCollisionTrigger(const Collider* _other);

public: // ã‚²ãƒƒã‚¿ãƒ¼

	/// <summary>
	/// é€Ÿåº¦å–å¾—
	/// </summary>
	/// <returns>é€Ÿåº¦ãƒ™ã‚¯ãƒˆãƒ«</returns>
	Vector3 SetVelocity(const Vector3 _velocity)
	{
		velocity_ = _velocity * kDefaultFrameRate; 
		return velocity_; 
	}

public: // ã‚»ãƒƒã‚¿ãƒ¼


private: // ãƒ¡ãƒ³ãƒå¤‰æ•°

	static constexpr float kDefaultFrameRate = 60.0f;

	// 3Dã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ
	std::unique_ptr<Object3d> object_ = nullptr;

	// å½“ãŸã‚Šåˆ¤å®šé–¢ä¿‚
	ColliderManager* colliderManager_ = nullptr;
	Collider collider_;
	AABB aabb_;
	Collider::ColliderDesc desc = {};

	// é€Ÿåº¦
	Vector3 velocity_{};

	//å¯¿å‘½<frm>
	static const int32_t kLifeTime = 60 * 5;

	//ãƒ‡ã‚¹ã‚¿ã‚¤ãƒžãƒ¼
	//int32_t deathTimer_ = kLifeTime;
	float deathRemainingSeconds_ = kLifeTime / kDefaultFrameRate;
};

============================================================
File Path: project/application/Objects/Player/Player.cpp
============================================================
#include "Player.h"

#include <cmath>

#include "TimeManager.h"

void Player::Initialize()
{
	// --- 3Dã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ ---
	object_ = std::make_unique<Object3d>();
	object_->Initialize("player.obj");


	position_ = { 0.2f,0.7f,-1.2f };
	object_->SetPosition(position_);
	object_->SetRotate(rotation_);
	scale_ = { 1.0f,1.5f,1.0f };
	object_->SetScale(scale_);


	// ãƒ©ã‚¤ãƒˆè¨­å®š
	object_->SetLighting(true);

	// è¡çªåˆ¤å®š
	colliderManager_ = ColliderManager::GetInstance();

	objectName_ = "Player";

	desc =
	{
		//ã“ã“ã«è¨­å®š
		.owner = this,
		.colliderID = objectName_,
		.shape = Shape::AABB,
		.shapeData = &aabb_,
		.attribute = colliderManager_->GetNewAttribute(objectName_),
		.onCollision = std::bind(&Player::OnCollision, this, std::placeholders::_1),
		.onCollisionTrigger = std::bind(&Player::OnCollisionTrigger, this, std::placeholders::_1),
	};
	collider_.MakeAABBDesc(desc);
	colliderManager_->RegisterCollider(&collider_);

	// ç”»é¢ãŒæ›´æ–°ã•ã‚ŒãŸã‚‰ãƒ“ãƒãƒƒãƒˆã‚’0ã«ã™ã‚‹
	PostEffectManager::GetInstance()->GetPassAs<VignettePass>("Vignette")->SetStrength(0.0f);

	// ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹
	hp_ = 12;
	isDead_ = false;
	isAutoControl_= false;

	// ç’°å¢ƒãƒžãƒƒãƒ—
	cubeMapPath_ = "resources/images/studio.dds";
	TextureManager::GetInstance()->LoadTexture(cubeMapPath_);
	cubeSrvIndex_ = TextureManager::GetInstance()->GetTextureIndexByFilePath(cubeMapPath_);
	cubeHandle_ = TextureManager::GetInstance()->GetSrvManager()->GetGPUDescriptorHandle(cubeSrvIndex_);

	// ç§»å‹•å¯èƒ½ãƒ•ãƒ©ã‚°
	isCanMove_ = true;

	// æ­»äº¡ãƒ¢ãƒ¼ã‚·ãƒ§ãƒ³åˆæœŸå€¤
	deathMotion_.isActive = false;
	deathMotion_.isComplete = false;
	deathMotion_.count = 0;
	deathMotion_.shakeFrames = 40;     // ã·ã‚‹ã·ã‚‹æ™‚é–“ï¼ˆãƒ•ãƒ¬ãƒ¼ãƒ ï¼‰
	deathMotion_.wobbleAmplitude = 0.10f;
	deathMotion_.wobbleFreq = 10.0f;
	deathMotion_.popScale = 2.0f;

	// ãƒ•ãƒ¬ãƒ¼ãƒ ãƒ¬ãƒ¼ãƒˆè£œæ­£
	moveSpeed_.x *= kDefaultFrameRate;
	moveSpeed_.z *= kDefaultFrameRate;
	evadeSpeed_.x *= kDefaultFrameRate;
	evadeSpeed_.z *= kDefaultFrameRate;
}

void Player::Finalize()
{
	for (auto& bullet : pBullets_)
	{
		bullet->SetIsDead(true);
		bullet->Finalize();
	}

	pBullets_.erase(
		std::remove_if(pBullets_.begin(), pBullets_.end(), [](std::unique_ptr < PlayerBullet>& bullet)
			{
				if (bullet->IsDead())
				{
					ParticleEmitter::Emit("BltReaction", bullet->GetPosition(), 1);
					bullet->Finalize();
					return true;
				}
				return false;
			}),
		pBullets_.end()
	);

	colliderManager_->DeleteCollider(&collider_);
}

void Player::Update()
{
	// æ­»äº¡ãƒ¢ãƒ¼ã‚·ãƒ§ãƒ³ãŒã‚¢ã‚¯ãƒ†ã‚£ãƒ–ãªã‚‰ç§»å‹•å…¥åŠ›ç­‰ã‚’ç„¡è¦–ã—ã¦ DeadEffect ã‚’æ›´æ–°
	if (deathMotion_.isActive)
	{
		DeadEffect();
		return;
	}

	object_->SetPosition(position_);
	object_->SetRotate(rotation_);
	object_->SetScale(scale_);
	object_->Update();

	if (isAutoControl_)
	{
		// ã‚ªãƒ¼ãƒˆç§»å‹•
		AutoMove();
		// ã‚ªãƒ¼ãƒˆæ”»æ’ƒ
		AutoAttack();

		isActive_ = false;

		if (isDead_)
		{
			isDead_ = false;

			hp_ = 8;
		}

	}
	else if(isCanMove_)
 	{
		// å›žé¿å‡¦ç†
		Evade();
		// ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ãƒ•ãƒ©ã‚°ã«å›žé¿ãƒ•ãƒ©ã‚°ã‚’å…¥ã‚Œã‚‹
		isActive_ = isEvading_;

		// å›žé¿ä¸­ã¯ç§»å‹•ãƒ»æ”»æ’ƒã‚’ç„¡åŠ¹åŒ–
		if (!isEvading_ && !isDead_)
		{
			Move();
			Attack();
		}
	}
	else
	{
		if (isDead_)
		{
			isDead_ = false;

			hp_ = 8;
		}
	}

	// æ­»äº¡ã—ãŸã‚‰yè»¸å›žè»¢ã‚’å¾ã€…ã«0ã«ã™ã‚‹
	if (isDead_)
	{
		rotation_.y = Lerp(rotation_.y, 0.0f, 0.05f);
	}

	// å¼¾ã®å‰Šé™¤
	pBullets_.erase(
		std::remove_if(pBullets_.begin(), pBullets_.end(), [](std::unique_ptr < PlayerBullet>& bullet)
			{
				if (bullet->IsDead())
				{
					ParticleEmitter::Emit("BltReaction", bullet->GetPosition(), 1);
					bullet->Finalize();
					return true;
				}
				return false;
			}),
		pBullets_.end()
	);

	// å¼¾æ›´æ–°
	for (auto& bullet : pBullets_)
	{
		bullet->Update();
	}

	// AABBã®æ›´æ–°
	aabb_.min = position_ - object_->GetScale();
	aabb_.max = position_ + object_->GetScale();
	aabb_.max.y += 1.0f;
	collider_.SetPosition(position_);

	// æš—é—‡å‡¦ç†
	HitVignetteTrap();

	// ã‚¯ãƒ¼ãƒ«ãƒ€ã‚¦ãƒ³ç³»
	if (countCoolDownFrame_ > 0)
	{
		countCoolDownFrame_--;
	}
	
	// Evade æ™‚é–“ç®¡ç†
	if (isEvading_)
	{
		if (evadeFrame_ > 0)
		{
			evadeFrame_--;

		}
		else
		{
			isEvading_ = false;
		}
	}
}

void Player::Draw()
{
	object_->Draw();

	// å¼¾æç”»
	for (auto& bullet : pBullets_)
	{
		bullet->Draw();
	}
}

void Player::Draw2D()
{
}

void Player::ImGuiDraw()
{
#ifdef USE_IMGUI

	ImGui::Begin("Player");

	ImGui::SliderFloat3("pos", &position_.x, -290.0f, 290.0f);
	ImGui::SliderFloat3("rot", &rotation_.x, -3.14f, 3.14f);
	ImGui::SliderFloat3("scale", &scale_.x, 0.0f, 10.0f);

	// HitMomentã‚ªãƒ³
	if (ImGui::Button("HitMoment"))
	{
		isHitMoment_ = true;
	}

	// HP
	ImGui::Text("HP: %.0f", hp_);

	ImGui::End();

	for (auto& bullet : pBullets_)
	{
		bullet->ImGuiDraw();
	}

#endif // USE_IMGUI
}

void Player::Move()
{
	// delta
	const float dt = TimeManager::Instance().GetDeltaTime();

	moveVelocity_ = {};

	// ç”»é¢ä¸Šã®è¦‹ãŸç›®é€šã‚Šã«ç§»å‹•ï¼ˆã‚«ãƒ¡ãƒ©å›žè»¢ãªã—ï¼‰
	if (Input::GetInstance()->PushKey(DIK_W))
	{
		moveVelocity_.z += moveSpeed_.z;
	}
	if (Input::GetInstance()->PushKey(DIK_S))
	{
		moveVelocity_.z -= moveSpeed_.z;
	}
	if (Input::GetInstance()->PushKey(DIK_A))
	{
		moveVelocity_.x -= moveSpeed_.x;
	}
	if (Input::GetInstance()->PushKey(DIK_D))
	{
		moveVelocity_.x += moveSpeed_.x;
	}

	// ç§»å‹•ãƒ™ã‚¯ãƒˆãƒ«ãŒã‚¼ãƒ­ã§ãªã„å ´åˆã«ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®å‘ãã‚’è£œé–“ã§æ›´æ–°
	if (moveVelocity_.x != 0.0f || moveVelocity_.z != 0.0f)
	{
		// æ­£è¦åŒ–ã•ã‚ŒãŸæ–¹å‘ãƒ™ã‚¯ãƒˆãƒ«
		Vector3 normalizedDir = moveVelocity_;
		
		normalizedDir = normalizedDir.Normalize();

		// Yè»¸å›žã‚Šã®ç›®æ¨™å›žè»¢è§’åº¦ã‚’è¨ˆç®—
		float targetRotationY = std::atan2(normalizedDir.x, normalizedDir.z);

		// ç¾åœ¨ã®å›žè»¢ã‚’å–å¾—
		Vector3 currentRotation = rotation_;

		// Yè»¸ã®å›žè»¢ã®ã¿ã€æœ€çŸ­çµŒè·¯ã§è£œé–“
		float easedRotationY = LerpAngle(currentRotation.y, targetRotationY, 0.2f);

		// å›žè»¢ã‚’æ›´æ–°
		rotation_ = { currentRotation.x, easedRotationY, currentRotation.z };
	}

	// ä½ç½®æ›´æ–°
	position_ += moveVelocity_ * dt;

	// ç§»å‹•åˆ¶é™
	ClampPosition();

	// ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«
	ParticleEmitter::Emit("walk", position_, 1);
}

void Player::Attack()
{
	// delta
	const float dt = TimeManager::Instance().GetDeltaTime();

	// ãƒ­ãƒ¼ã‚«ãƒ«æŒç¶šã‚¯ãƒ¼ãƒ«ãƒ€ã‚¦ãƒ³
	static float shootCooldownSec = 0.0f;
	// æ—¢å­˜ã®ãƒ•ãƒ¬ãƒ¼ãƒ ãƒ™ãƒ¼ã‚¹å®šæ•°ã‚’ç§’ã«å¤‰æ›ã—ã¦åˆ©ç”¨
	const float shootCooldownDuration = static_cast<float>(kShootCoolDownFrame_) / kDefaultFrameRate;

	// ã‚¯ãƒ¼ãƒ«ãƒ€ã‚¦ãƒ³ã‚’é€²ã‚ã‚‹
	if (shootCooldownSec > 0.0f)
	{
		shootCooldownSec -= dt;
		if (shootCooldownSec < 0.0f)
		{
			shootCooldownSec = 0.0f;
		}
	}

	if (Input::GetInstance()->PushKey(DIK_SPACE))
	{
		// ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®å‘ãã«åˆã‚ã›ã¦å¼¾ã®é€Ÿåº¦ã‚’å¤‰æ›´
		Vector3 bulletVelocity =
		{
			std::cosf(rotation_.x) * std::sinf(rotation_.y),     // x
			std::sinf(-rotation_.x),                             // y
			std::cosf(rotation_.x) * std::cosf(rotation_.y)      // z
		};

		if (shootCooldownSec <= 0)
		{
			// å¼¾ã‚’ç”Ÿæˆã—ã€åˆæœŸåŒ–
			auto newBullet = std::make_unique<PlayerBullet>();

			newBullet->SetPosition(position_);
			newBullet->Initialize();
			newBullet->SetVelocity(bulletVelocity);

			// å¼¾ã‚’ç™»éŒ²ã™ã‚‹
			pBullets_.push_back(std::move(newBullet));

			shootCooldownSec = shootCooldownDuration;
		}
	}
}

void Player::Evade()
{
	// delta
	const float dt = TimeManager::Instance().GetDeltaTime();

	// å›žé¿å…¥åŠ›
	if (!isEvading_ && Input::GetInstance()->PushKey(DIK_LSHIFT))
	{
		// ç§»å‹•æ–¹å‘ãŒã‚ã‚‹å ´åˆã®ã¿å›žé¿
		if (moveVelocity_.x != 0.0f or moveVelocity_.z != 0.0f) 
		{
			isEvading_ = true;
			evadeFrame_ = kEvadeDuration_;
			// ç¾åœ¨ã®ç§»å‹•æ–¹å‘ã‚’å›žé¿æ–¹å‘ã¨ã—ã¦ä¿å­˜
			evadeDirection_ = moveVelocity_;
			// æ­£è¦åŒ–
			float len = std::sqrt(evadeDirection_.x * evadeDirection_.x + evadeDirection_.z * evadeDirection_.z);
			if (len > 0.0f) 
			{
				evadeDirection_.x /= len;
				evadeDirection_.z /= len;
			}
			// å›žé¿é–‹å§‹æ™‚ã®xè»¸è§’åº¦ã‚’ä¿å­˜
			evadeStartRotationX_ = rotation_.x;
			// ç›®æ¨™è§’åº¦ã‚’è¨­å®šï¼ˆ1å›žè»¢åˆ†åŠ ç®—ï¼‰
			evadeTargetRotationX_ = evadeStartRotationX_ + kEvadeRotateAngle_;
		}
	}

	if (isEvading_)
	{
		// å›žé¿ç§»å‹•
		position_ += evadeDirection_ * Vector3{ evadeSpeed_.x, 0.0f, evadeSpeed_.z } * dt;

		// ç§»å‹•åˆ¶é™
		ClampPosition();

		// å›žé¿ä¸­ã®xè»¸å›žè»¢ï¼ˆç·šå½¢è£œé–“ã§é€Ÿã‚ã«å›žã™ï¼‰
		float t = 1.0f - static_cast<float>(evadeFrame_) / static_cast<float>(kEvadeDuration_);
		rotation_.x = evadeStartRotationX_ + (evadeTargetRotationX_ - evadeStartRotationX_) * t * dt * kDefaultFrameRate;

		evadeFrame_--;
		if (evadeFrame_ <= 0)
		{
			isEvading_ = false;
			// å›žé¿çµ‚äº†æ™‚ã«å…ƒã®è§’åº¦ã«æˆ»ã™
			rotation_.x = evadeStartRotationX_;
		}
	}
}

void Player::DeadEffect()
{
	if (!deathMotion_.isActive)
	{
		return;
	}

	uint32_t frame = deathMotion_.count;

	// ã¾ãšã¯ã€Œã·ã‚‹ã·ã‚‹ã€ãƒ•ã‚§ãƒ¼ã‚ºï¼šframe < shakeFrames
	if (frame < deathMotion_.shakeFrames)
	{
		// æ­£è¦åŒ– t [0,1]
		float t = static_cast<float>(frame) / static_cast<float>(deathMotion_.shakeFrames);
		t = std::clamp(t, 0.0f, 1.0f);

		// æ¸›è¡°ä»˜ãã‚µã‚¤ãƒ³æŒ¯å‹•
		float angular = static_cast<float>(frame) * deathMotion_.wobbleFreq * (2.0f * 3.14159265f / kDefaultFrameRate);
		float decay = 1.0f - t; // ã ã‚“ã ã‚“æŒ¯å¹…ã‚’æ¸›ã‚‰ã™
		float wobble = std::sin(angular) * deathMotion_.wobbleAmplitude * decay;

		// åŸºæº–ã‚¹ã‚±ãƒ¼ãƒ«ã« wobble ã‚’åŠ ç®—ï¼ˆå‡ç­‰ï¼‰
		float baseSx = deathMotion_.startScale.x;
		float s = baseSx + wobble;
		if (s < 0.001f) s = 0.001f; // è² ã‚¹ã‚±ãƒ¼ãƒ«é˜²æ­¢
		scale_.x = s;
		scale_.y = s;
		scale_.z = s;

		// ã¡ã‚‡ã£ã¨ä¸Šä¸‹ã«æºã‚‰ã™ï¼ˆè¦–è¦šåŠ¹æžœï¼‰
		position_ = deathMotion_.startPosition;
		position_.y += std::sin(angular) * 0.01f * decay;

		// è»½ãå›žã™
		rotation_ = deathMotion_.startRotation;
		rotation_.y += 0.04f * decay;

		// åæ˜ 
		if (object_)
		{
			object_->SetPosition(position_);
			object_->SetRotate(rotation_);
			object_->SetScale(scale_);
			object_->Update();
		}

		deathMotion_.count++;
		return;
	}

	// æœ€å¾Œã¯å¤§ãã•ï¼ã«ã™ã‚‹
	scale_.x = 0.0f;
	scale_.y = 0.0f;
	scale_.z = 0.0f;

	if (object_)
	{
		object_->SetScale(scale_);
		object_->Update();
	}

	// ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã‚’ç™ºç”Ÿã•ã›ã‚‹
	ParticleEmitter::Emit("rupture", position_, 20);

	// ãƒ¢ãƒ¼ã‚·ãƒ§ãƒ³çµ‚äº†æ‰±ã„ã«ã™ã‚‹(isActive=false)
	deathMotion_.isActive = false;
	deathMotion_.isComplete = true;
}

void Player::StartDeathMotion()
{
	if (deathMotion_.isActive)
	{
		return;
	}

	deathMotion_.isActive = true;
	deathMotion_.count = 0;
	// ä¿å­˜ã—ã¦ãŠãç¾åœ¨ã®ãƒˆãƒ©ãƒ³ã‚¹ãƒ•ã‚©ãƒ¼ãƒ 
	deathMotion_.startPosition = position_;
	deathMotion_.startRotation = rotation_;
	deathMotion_.startScale = scale_;

	// åæ˜ 
	if (object_)
	{
		object_->SetPosition(position_);
		object_->SetRotate(rotation_);
		object_->SetScale(scale_);
		object_->Update();
	}
}

void Player::ClearSceneUpdate()
{
	isCanMove_ = false;

	// unscaled delta
	const float dt = TimeManager::Instance().GetUnscaledDeltaTime();

	constexpr float TWO_PI = 3.14159265358979323846f * 2.0f;

	// èª¿æ•´ç”¨ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿
	static Vector3 center{ 0.0f, 0.5f, 0.0f }; // è»Œé“ä¸­å¿ƒï¼ˆé«˜ã• = center.yï¼‰
	static float radius = 8.0f;              // è»Œé“åŠå¾„
	static float angularSpeed = 1.5f;        // è§’é€Ÿåº¦ (rad/s)
	static float currentAngle = 0.2f;        // ç¾åœ¨è§’åº¦ï¼ˆåˆæœŸã‚ªãƒ•ã‚»ãƒƒãƒˆå«ã‚€ï¼‰
	static bool clockwise = false;           // å›žè»¢æ–¹å‘

	// other poyo params...
	static float poyoAmp = 0.2f;
	static float poyoAmpZ = 0.2f;
	static float poyoAmpY = 0.2f;
	static float poyoFreq = 1.2f;
	static float poyoFreqY = 1.2f;
	static float poyoPhase = 0.0f;
	static float poyoPhaseY = 0.0f;
	static bool maintainArea = false;
	static bool maintainVolume = false;
	static Vector3 baseScale{ 1.0f, 1.0f, 1.0f };

	static float totalTime = 0.0f;
	totalTime += dt;

	// è§’åº¦æ›´æ–°
	float dir = clockwise ? -1.0f : 1.0f;
	currentAngle += dir * angularSpeed * dt;
	// è§’åº¦ã‚’å®‰å®šåŒ–
	if (currentAngle > TWO_PI) currentAngle = std::fmod(currentAngle, TWO_PI);
	else if (currentAngle < 0.0f) currentAngle = std::fmod(currentAngle + TWO_PI, TWO_PI);

	// ä½ç½®
	clearMotion_.position.x = center.x + radius * std::cos(currentAngle);
	clearMotion_.position.y = center.y;
	clearMotion_.position.z = center.z + radius * std::sin(currentAngle);

	// é€²è¡Œæ–¹å‘ã«å‘ã‘ã‚‹å††é‹å‹•ã®é€Ÿåº¦ãƒ™ã‚¯ãƒˆãƒ«
	float velX = -radius * std::sin(currentAngle) * (dir * angularSpeed);
	float velZ = radius * std::cos(currentAngle) * (dir * angularSpeed);
	// å°ã•ãªé€Ÿåº¦ã§ã¯ç›´å‰ã®å‘ãã‚’ä¿ã¤ãŸã‚ã®ã‚¬ãƒ¼ãƒ‰
	static float lastYaw = 0.0f;
	if (std::abs(velX) < 1e-6f && std::abs(velZ) < 1e-6f)
	{
		// é€Ÿåº¦ãŒã»ã¼0ãªã‚‰è§’åº¦ã¯æ›´æ–°ã—ãªã„
	} 
	else
	{
		// atan2(x,z) ã‚’ä½¿ã£ã¦ yaw ã‚’å¾—ã‚‹ï¼ˆãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆå†…ã®å›žè»¢è»¸ã¨åˆã‚ã›ã¦ãã ã•ã„ï¼‰
		lastYaw = std::atan2(velX, velZ);
	}
	clearMotion_.rotation.x = 0.0f;
	clearMotion_.rotation.y = lastYaw;
	clearMotion_.rotation.z = 0.0f;

	// ã‚¹ã‚±ãƒ¼ãƒ« (X, Z ã¯æ—¢å­˜ãƒ­ã‚¸ãƒƒã‚¯ã€‚Y ã‚’è¿½åŠ ã—ã¦ä½“ç©ç¶­æŒ or ç‹¬ç«‹åˆ¶å¾¡ã‚’å¯èƒ½ã«ã™ã‚‹)
	float omegaXZ = 2.0f * 3.14159265358979323846f * poyoFreq;
	float sXZ = std::sin(omegaXZ * totalTime + poyoPhase);
	float sx = 1.0f + poyoAmp * sXZ;
	sx = std::max(0.05f, sx); // æ¥µç«¯ã«æ½°ã‚Œãªã„ã‚ˆã†ã«ã‚¯ãƒ©ãƒ³ãƒ—

	float sz;
	if (maintainArea)
	{
		// é¢ç©ç¶­æŒï¼ˆXZé¢ï¼‰
		sz = 1.0f / sx;
		sz = std::clamp(sz, 0.05f, 5.0f);
	} 
	else
	{
		sz = 1.0f + poyoAmpZ * std::sin(omegaXZ * totalTime + poyoPhase + 3.14159265f / 2.0f);
		sz = std::clamp(sz, 0.05f, 5.0f);
	}

	// Yæ–¹å‘ï¼ˆé«˜ã•ï¼‰ã®ãƒãƒ¨ãƒãƒ¨
	float sy; // å®Ÿã‚¹ã‚±ãƒ¼ãƒ«ï¼ˆä¹—ç®—å‰ï¼‰
	if (maintainVolume)
	{
		// 3Dä½“ç©ç¶­æŒï¼šç›¸å¯¾ã‚¹ã‚±ãƒ¼ãƒ«ã®ç©ã‚’1ã«è¿‘ã¥ã‘ã‚‹ -> sy_rel = 1 / (sx_rel * sz_rel)
		float sx_rel = std::max(0.01f, sx);
		float sz_rel = std::max(0.01f, sz);
		float sy_rel = 1.0f / (sx_rel * sz_rel);
		sy_rel = std::clamp(sy_rel, 0.05f, 5.0f);
		sy = baseScale.y * sy_rel;
	} 
	else
	{
		// Yã¯ç‹¬ç«‹ã—ã¦æŒ¯å‹•ã•ã›ã‚‹
		float omegaY = 2.0f * 3.14159265358979323846f * poyoFreqY;
		float sY = std::sin(omegaY * totalTime + poyoPhaseY);
		float sy_rel = 1.0f + poyoAmpY * sY;
		sy_rel = std::clamp(sy_rel, 0.05f, 5.0f);
		sy = baseScale.y * sy_rel;
	}

	// baseScale ã‚’ä¹—ç®—ã—ã¦æœ€çµ‚ã‚¹ã‚±ãƒ¼ãƒ«ã‚’å‡ºã™
	clearMotion_.scale.x = baseScale.x * sx; // æ¨ªæ–¹å‘
	clearMotion_.scale.y = sy;               // é«˜ã•ã‚‚å¤‰åŒ–ã•ã›ã‚‹
	clearMotion_.scale.z = baseScale.z * sz; // ç¸¦æ–¹å‘ï¼ˆtop-down ã ã¨è¦–è¦šçš„ã« z ã‚’ä½¿ã†ï¼‰

	object_->SetPosition(clearMotion_.position);
	object_->SetRotate(clearMotion_.rotation);
	object_->SetScale(clearMotion_.scale);
	object_->Update();

	// ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«
	ParticleEmitter::Emit("walk", clearMotion_.position, 1);

}

void Player::AutoMove()
{
	const float dt = TimeManager::Instance().GetUnscaledDeltaTime();

	static int moveTimer = 0;
	static Vector3 autoDir = { 0.0f, 0.0f, 1.0f }; // åˆæœŸã¯å‰é€²

	// ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ç«¯ã®ç¯„å›²
	const float minX = -15.0f, maxX = 15.0f;
	const float minZ = -15.0f, maxZ = 15.0f;

	// ä¸€å®šãƒ•ãƒ¬ãƒ¼ãƒ ã”ã¨ã«æ–°ã—ã„ãƒ©ãƒ³ãƒ€ãƒ æ–¹å‘ã‚’æ±ºã‚ã‚‹
	if (moveTimer <= 0)
	{
		// -1.0fï½ž1.0fã®ç¯„å›²ã§ãƒ©ãƒ³ãƒ€ãƒ ãªx,zã‚’ç”Ÿæˆ
		float randX = (float(rand()) / RAND_MAX) * 2.0f - 1.0f;
		float randZ = (float(rand()) / RAND_MAX) * 2.0f - 1.0f;
		Vector3 dir = { randX, 0.0f, randZ };
		if (dir.Length() < 0.1f) dir.z = 1.0f; // ã‚¼ãƒ­ãƒ™ã‚¯ãƒˆãƒ«å¯¾ç­–
		autoDir = dir.Normalize();
		moveTimer = 60 + rand() % 90; // 1ï½ž2.5ç§’ã”ã¨ã«æ–¹å‘è»¢æ›
	}
	moveTimer--;

	// å£éš›åˆ¤å®šï¼šç«¯ã«è¿‘ã¥ã„ãŸã‚‰(ä»Šã®é€²è¡Œæ–¹å‘ãŒå¤–ã«å‘ã‹ã£ã¦ã„ãŸã‚‰)å¼·åˆ¶çš„ã«å†…å‘ãã«ãƒªãƒ€ã‚¤ãƒ¬ã‚¯ãƒˆ
	bool redirected = false;
	Vector3 nextPos = position_ + Vector3{ autoDir.x * moveSpeed_.x, 0.0f, autoDir.z * moveSpeed_.z };

	if (nextPos.x < minX or nextPos.x > maxX) 
	{
		autoDir.x = -autoDir.x;
		redirected = true;
	}
	if (nextPos.z < minZ or nextPos.z > maxZ) 
	{
		autoDir.z = -autoDir.z;
		redirected = true;
	}

	if (redirected) 
	{
		// ç«¯ã§æ–¹å‘åè»¢ã—ãŸã‚‰æ–°ãŸã«moveTimerã‚’è¨­å®šã—ã€å³åº§ã«å†ãƒ©ãƒ³ãƒ€ãƒ åŒ–ã—ãªã„
		moveTimer = 60 + rand() % 90;
	}

	// ç§»å‹•é€Ÿåº¦ã‚’è¨ˆç®—
	moveVelocity_ = { autoDir.x * moveSpeed_.x, 0.0f, autoDir.z * moveSpeed_.z };

	// ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®å‘ãè£œé–“
	if (moveVelocity_.x != 0.0f or moveVelocity_.z != 0.0f)
	{
		Vector3 normalizedDir = moveVelocity_.Normalize();
		float targetRotationY = std::atan2(normalizedDir.x, normalizedDir.z);
		Vector3 currentRotation = rotation_;
		float easedRotationY = LerpAngle(currentRotation.y, targetRotationY, 0.2f);
		rotation_ = { currentRotation.x, easedRotationY, currentRotation.z };
	}

	// ä½ç½®æ›´æ–°
	position_ += moveVelocity_ * dt;

	// ç§»å‹•åˆ¶é™
	ClampPosition();

	// ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«
	ParticleEmitter::Emit("walk", position_, 1);
}

void Player::AutoAttack()
{
	// ä¸€å®šé–“éš”ã§è‡ªå‹•æ”»æ’ƒ
	static int attackCooldown = 0;
	const int attackInterval = 50; // ãƒ•ãƒ¬ãƒ¼ãƒ æ•°
	if (attackCooldown <= 0)
	{
		// ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®å‘ãã«åˆã‚ã›ã¦å¼¾ã®é€Ÿåº¦ã‚’å¤‰æ›´
		Vector3 bulletVelocity =
		{
			std::cosf(rotation_.x) * std::sinf(rotation_.y),     // x
			std::sinf(-rotation_.x),                             // y
			std::cosf(rotation_.x) * std::cosf(rotation_.y)      // z
		};
		// å¼¾ã‚’ç”Ÿæˆã—ã€åˆæœŸåŒ–
		auto newBullet = std::make_unique<PlayerBullet>();
		newBullet->SetPosition(position_);
		newBullet->Initialize();
		newBullet->SetVelocity(bulletVelocity);
		
		// å¼¾ã‚’ç™»éŒ²ã™ã‚‹
		pBullets_.push_back(std::move(newBullet));
		attackCooldown = attackInterval;
	}
	else
	{
		attackCooldown--;
	}
}

void Player::ClampPosition()
{
	position_.x = std::clamp(position_.x, limitMin_.x, limitMax_.x);
	position_.z = std::clamp(position_.z, limitMin_.y, limitMax_.y);
}

void Player::OnCollisionTrigger(const Collider* _other)
{

	if (!isEvading_ && (_other->GetColliderID() == "EnemyBullet" or
		_other->GetColliderID() == "NormalEnemy" or
		_other->GetColliderID() == "TrapEnemy"))
	{
		// ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®HPã‚’æ¸›å°‘
		if (hp_ > 0.3)
		{
			hp_--;

			ParticleEmitter::Emit("HitReaction", position_, 5);
		}
		else
		{
			isDead_ = true;
		}

		isHitMoment_ = true;
	} 

	if (!isEvading_ && (_other->GetColliderID() == "ExplosionTimeBomb" or
		_other->GetColliderID() == "Corruptor"))
	{
		if (_other->GetOwner()->IsActive())
		{
			// ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®HPã‚’æ¸›å°‘
			if (hp_ > 0.3)
			{
				hp_ -= 1.5f;
				ParticleEmitter::Emit("HitReaction", position_, 8);
			}
			else
			{
				isDead_ = true;
			}

			isHitMoment_ = true;
		}
	}

	if (!isEvading_ && _other->GetColliderID() == "VignetteTrap")
	{
		if (_other->GetOwner()->IsActive())
		{
			// VignetteTrapã«å½“ãŸã£ãŸå ´åˆ
			isHitVignetteTrap_ = true;
		}
	}
}

void Player::OnCollision(const Collider* _other)
{
	if (_other->GetColliderID() == "Wall" or
		_other->GetColliderID() == "Barrie" or 
		_other->GetColliderID() == "NormalEnemy")
	{
		// ç›¸æ‰‹ã®AABBã‚’å–å¾—
		const AABB* otherAABB = _other->GetAABB();
		
		if (otherAABB) 
		{
			// è‡ªåˆ†ã®AABBã¨ä½ç½®ã‚’æ¸¡ã—ã¦è£œæ­£
			CorrectOverlap(*otherAABB, aabb_, position_);
		}
	}
}

void Player::HitVignetteTrap()
{
	// ãƒ‡ãƒ«ã‚¿ã‚¿ã‚¤ãƒ 
	const float dt = TimeManager::Instance().GetDeltaTime();

	// ãƒ•ã‚§ãƒ¼ãƒ‰ã‚¢ã‚¦ãƒˆä¸­ã®å‡¦ç†
	if (isFadingOut_)
	{
		static const float fadeDuration = 30.0f;
		static float fadeTimer = 0.0f;

		fadeTimer++;
		float t = (fadeTimer / fadeDuration) * dt * kDefaultFrameRate;
		t = std::clamp(t, 0.0f, 1.0f);
		vignetteStrength_ = std::lerp(1.8f, 0.0f, t);

		PostEffectManager::GetInstance()->GetPassAs<VignettePass>("Vignette")->SetStrength(vignetteStrength_);

		if (t >= 1.0f)
		{
			// å®Œäº†ï¼šã™ã¹ã¦ãƒªã‚»ãƒƒãƒˆ
			isFadingOut_ = false;
			fadeTimer = 0.0f;
			vignetteStrength_ = 0.0f;
			PostEffectManager::GetInstance()->SetActiveEffect("Vignette", isHitVignetteTrap_);

			// ç’°å¢ƒãƒžãƒƒãƒ—ã‚’ç„¡åŠ¹åŒ–
			environmentStrength_ = 0.0f;
			object_->SetEnvironmentStrength(environmentStrength_);

		}

		return;
	}

	// é€šå¸¸ã®åŠ¹æžœä¸­
	if (isHitVignetteTrap_)
	{
		if (vignetteTime_ > 150)
		{
			// ãƒ•ã‚§ãƒ¼ãƒ‰ã‚¤ãƒ³
			float t = (1.0f - static_cast<float>(kMaxVignetteTime - vignetteTime_) / 30.0f) * dt * kDefaultFrameRate;
			t = std::clamp(t, 0.0f, 1.0f);
			vignetteStrength_ = std::lerp(1.8f, 0.0f, t);
		}
		else
		{
			vignetteStrength_ = 1.8f;
		}

		// vignetteã®å¼·ã•ã‚’è¨­å®š
		PostEffectManager::GetInstance()->SetActiveEffect("Vignette", isHitVignetteTrap_);
		PostEffectManager::GetInstance()->GetPassAs<VignettePass>("Vignette")->SetStrength(vignetteStrength_);

		ParticleEmitter::Emit("debuff", position_, 2);

		environmentStrength_ = 1.0f;

		object_->SetEnvironmentMapHandle(cubeHandle_, true);
		object_->SetEnvironmentStrength(environmentStrength_);


		// ã‚¿ã‚¤ãƒžãƒ¼æ›´æ–°
		if (vignetteTime_ > 0)
		{
			vignetteTime_--;
		}
		else
		{
			// æ˜Žã‚‹ãã™ã‚‹æº–å‚™
			isHitVignetteTrap_ = false;
			isFadingOut_ = true;
			// ã‚¿ã‚¤ãƒžãƒ¼ã‚’ãƒªã‚»ãƒƒãƒˆ
			vignetteTime_ = kMaxVignetteTime;
		}
	}
}

============================================================
File Path: project/application/Objects/Player/Player.h
============================================================
#pragma once

#include "../../baseObject/GameObject.h"
#include "bullet/PlayerBullet.h"
#include"../../../gameEngine/collider/ColliderManager.h"

#include "postEffect/PostEffectManager.h"

#include <Object3d.h>
#include <Sprite.h>
#include <Framework.h>

/// <summary>
/// ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚¯ãƒ©ã‚¹
/// ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®ç§»å‹•ã€æ”»æ’ƒã€å›žé¿ã€å½“ãŸã‚Šåˆ¤å®šãªã©ã‚’ç®¡ç†
/// </summary>
class Player : public GameObject
{
public:

	Player() = default;
	~Player() = default;
	
	// åˆæœŸåŒ–
	void Initialize() override;
	
	// çµ‚äº†
	void Finalize() override;
	
	// æ›´æ–°
	void Update() override;
	
	// æç”»
	void Draw() override;
	
	// ã‚¹ãƒ—ãƒ©ã‚¤ãƒˆæç”»
	void Draw2D();
	
	// ImGui
	void ImGuiDraw();
	
	/// <summary>
	/// ãƒ‡ã‚¹ãƒ¢ãƒ¼ã‚·ãƒ§ãƒ³é–‹å§‹
	/// å¤–éƒ¨ã‹ã‚‰å‘¼ã³å‡ºã™ç”¨
	/// </summary>
	void StartDeathMotion();

	/// <summary>
	/// ã‚¯ãƒªã‚¢ã‚·ãƒ¼ãƒ³æ›´æ–°
	/// </summary>
	void ClearSceneUpdate();

private: // å†…éƒ¨å‡¦ç†

	// ç§»å‹•
	void Move();
	
	// æ”»æ’ƒ
	void Attack();

	// å›žé¿
	void Evade();

	// æ­»äº¡æ¼”å‡º
	void DeadEffect();

	// ã‚ªãƒ¼ãƒˆç§»å‹•
	void AutoMove();

	// ã‚ªãƒ¼ãƒˆæ”»æ’ƒ
	void AutoAttack();

	// ç§»å‹•åˆ¶é™
	void ClampPosition();

private: // è¡çªåˆ¤å®š

	/// <summary>
	/// è¡çªæ™‚ã®å‡¦ç†
	/// </summary>
	/// <param name="_other">è¡çªç›¸æ‰‹ã®ã‚³ãƒ©ã‚¤ãƒ€ãƒ¼</param>
	void OnCollisionTrigger(const Collider* _other);
	
	/// <summary>
	/// è¡çªä¸­ã®å‡¦ç†
	/// </summary>
	/// <param name="_other">è¡çªç›¸æ‰‹ã®ã‚³ãƒ©ã‚¤ãƒ€ãƒ¼</param>
	void OnCollision(const Collider* _other);

	// æš—é—‡ãƒˆãƒ©ãƒƒãƒ—ã«è¡çªã—ãŸã¨ãã®å‡¦ç†
	void HitVignetteTrap();

public: // ã‚²ãƒƒã‚¿ãƒ¼

	// ãƒ’ãƒƒãƒˆã—ãŸçž¬é–“ã®ãƒ•ãƒ©ã‚°ã®ã‚²ãƒƒã‚¿ãƒ¼
	bool IsHitMoment() const { return isHitMoment_; }

	// ç§»å‹•é€Ÿåº¦ã®ã‚²ãƒƒã‚¿ãƒ¼
	Vector3 GetVelocity() const { return moveVelocity_; }

	// ã‚ªãƒ¼ãƒˆãƒ•ãƒ©ã‚°ã®ã‚²ãƒƒã‚¿ãƒ¼
	bool IsAutoControl() const { return isAutoControl_; }

	// æ­»äº¡æ¼”å‡ºãŒã‚¢ã‚¯ãƒ†ã‚£ãƒ–ã‹ã©ã†ã‹
	bool IsDeathMotionComplete() const { return deathMotion_.isComplete; }

public: // ã‚»ãƒƒã‚¿ãƒ¼

	/// <summary>
	/// ãƒ’ãƒƒãƒˆã—ãŸçž¬é–“ã®ãƒ•ãƒ©ã‚°ã®ã‚»ãƒƒã‚¿ãƒ¼
	/// </summary>
	/// <param name="_isHitMoment">ãƒ’ãƒƒãƒˆã—ãŸçž¬é–“ã®ãƒ•ãƒ©ã‚°</param>
	void SetHitMoment(bool _isHitMoment) { isHitMoment_ = _isHitMoment; }

	/// <summary>
	/// ã‚ªãƒ¼ãƒˆãƒ•ãƒ©ã‚°ã®ã‚»ãƒƒã‚¿ãƒ¼
	/// </summary>
	/// <param name="_isAuto">ã‚ªãƒ¼ãƒˆãƒ•ãƒ©ã‚°</param>
	void SetAutoControl(bool _isAuto) { isAutoControl_ = _isAuto; }

	/// <summary>
	/// ç§»å‹•å¯èƒ½ãƒ•ãƒ©ã‚°ã®ã‚»ãƒƒã‚¿ãƒ¼
	/// </summary>
	/// <param name="_isCanMove">ç§»å‹•å¯èƒ½ãƒ•ãƒ©ã‚°</param>
	bool SetIsCanMove(bool _isCanMove) { return isCanMove_ = _isCanMove; }

private:

	// ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆãƒ•ãƒ¬ãƒ¼ãƒ ãƒ¬ãƒ¼ãƒˆ
	static constexpr float kDefaultFrameRate = 60.0f;

	// 3Dã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ
	std::unique_ptr<Object3d> object_ = nullptr;

	// å½“ãŸã‚Šåˆ¤å®šé–¢ä¿‚
	ColliderManager* colliderManager_ = nullptr;
	Collider collider_;
	AABB aabb_;
	Collider::ColliderDesc desc = {};

	// å¼¾
	std::vector<std::unique_ptr<PlayerBullet>> pBullets_ = {};

	// ç™ºå°„ã‚¯ãƒ¼ãƒ«ã‚¿ã‚¤ãƒ 
	const int kShootCoolDownFrame_ = 15;
	// å¼¾ã®ã‚¯ãƒ¼ãƒ«ã‚¿ã‚¤ãƒ 
	int countCoolDownFrame_ = 0;

	// ç§»å‹•é€Ÿåº¦
	Vector3 moveVelocity_{};
	Vector3 moveSpeed_ = { 0.1f,0.0f,0.1f };

	// ã‚¿ã‚¤ãƒˆãƒ«ç”¨ã‚ªãƒ¼ãƒˆãƒ•ãƒ©ã‚°(trueã ã£ãŸã‚‰è‡ªå‹•ã§å‹•ã å…¥åŠ›ã¯å—ã‘ä»˜ã‘ãªã„)
	bool isAutoControl_ = false;

	// ãƒ’ãƒƒãƒˆã—ãŸçž¬é–“ã®ãƒ•ãƒ©ã‚°
	bool isHitMoment_ = false;

	// æš—é—‡ãƒˆãƒ©ãƒƒãƒ—ã«å½“ãŸã£ãŸã‹ã©ã†ã‹
	bool isHitVignetteTrap_ = false;
	// æš—é—‡ã‚’å¾ã€…ã«æˆ»ã™ãƒ•ãƒ©ã‚°
	bool isFadingOut_ = false;
	// æš—é—‡åŠ¹æžœæœ€å¤§æ™‚é–“
	const uint32_t kMaxVignetteTime = 60 * 3;
	// æš—é—‡ã‚¿ã‚¤ãƒžãƒ¼
	uint32_t vignetteTime_ = kMaxVignetteTime;
	// vignetteã®å¼·ã•
	float vignetteStrength_ = 0.0f;


	// å›žé¿ãƒ•ãƒ©ã‚°
	bool isEvading_ = false;
	// å›žé¿æ™‚é–“
	uint32_t evadeTime_ = 0;
	// å›žé¿æ™‚é–“ã®æœ€å¤§å€¤
	const uint32_t kEvadeTimeMax_ = 30;
	// å›žé¿é€Ÿåº¦
	Vector3 evadeSpeed_ = { 0.2f,0.0f,0.2f };
	// å›žé¿æ–¹å‘
	Vector3 evadeDirection_ = { 0.0f,0.0f,0.0f };
	// å›žé¿ä¸­ã®ãƒ•ãƒ¬ãƒ¼ãƒ æ•°
	int32_t evadeFrame_ = 0;
	const int kEvadeDuration_ = 30; // å›žé¿ã®æŒç¶šæ™‚é–“
	// å›žé¿é€Ÿåº¦
	const float kEvadeSpeed_ = 0.2f;

	float evadeStartRotationX_ = 0.0f; // å›žé¿é–‹å§‹æ™‚ã®xè»¸è§’åº¦
	float evadeTargetRotationX_ = 0.0f; // å›žé¿ä¸­ã®ç›®æ¨™xè»¸è§’åº¦
	const float kEvadeRotateAngle_ = 3.14f * 4.0f; // 1å›žè»¢(360åº¦) 


	// ç’°å¢ƒãƒžãƒƒãƒ—
	std::string cubeMapPath_ = "";
	uint32_t cubeSrvIndex_ = 0u;
	D3D12_GPU_DESCRIPTOR_HANDLE cubeHandle_ = { 0 };
	float environmentStrength_ = 1.0f;

	// ç§»å‹•å¯èƒ½ãƒ•ãƒ©ã‚°
	bool isCanMove_ = true;

	// ç§»å‹•åˆ¶é™
	Vector2 limitMax_ = { 40.0f, 30.0f };
	Vector2 limitMin_ = { -40.0f, -30.0f };

	// ãƒ‡ã‚¹ãƒ¢ãƒ¼ã‚·ãƒ§ãƒ³ç”¨æ§‹é€ ä½“
	struct Motion
	{
		bool isActive = false;
		bool isComplete = false;
		uint32_t count = 0;           // ç¾åœ¨ãƒ•ãƒ¬ãƒ¼ãƒ ã‚«ã‚¦ãƒ³ãƒˆ
		uint32_t shakeFrames = 40;    // ã·ã‚‹ã·ã‚‹ç¶™ç¶šãƒ•ãƒ¬ãƒ¼ãƒ æ•°ï¼ˆèª¿æ•´å¯ï¼‰
		// æŒ¯å‹•ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿
		float wobbleAmplitude = 0.10f; // æŒ¯å¹…
		float wobbleFreq = 10.0f;      // å‘¨æ³¢æ•°ï¼ˆframeãƒ™ãƒ¼ã‚¹ï¼‰
		// ä¿å­˜ã—ã¦ãŠãåŸºåº•ãƒˆãƒ©ãƒ³ã‚¹ãƒ•ã‚©ãƒ¼ãƒ 
		Vector3 startPosition = { 0.0f, 0.0f, 0.0f };
		Vector3 startRotation = { 0.0f, 0.0f, 0.0f };
		Vector3 startScale = { 1.0f, 1.0f, 1.0f };
		// pop ã‚¹ã‚±ãƒ¼ãƒ«ï¼ˆã¯ã˜ã‘ã‚‹æœ€å¤§å€¤ã€ãŸã ã—ä»Šå›žã¯çž¬æ™‚æ¶ˆå¤±ã§ã‚‚å¯ï¼‰
		float popScale = 2.0f;
	};

	Motion deathMotion_;

	// ã‚¯ãƒªã‚¢ã‚·ãƒ¼ãƒ³ç”¨æ§‹é€ ä½“
	struct ClearMotion
	{
		Vector3 center = { 0.0f, 0.0f, 0.0f };
		float radius = 3.0f;
		float angleSpeed = 1.5f;
		float currentAngle = 0.0f;
		float initialAngle = 0.0f;
		bool clockwise = true;
		Vector3 position;
		Vector3 rotation;
		Vector3 scale;
	};

	ClearMotion clearMotion_;
	
};

============================================================
File Path: project/application/objects/enemy/Corruptor.cpp
============================================================
#include "Corruptor.h"

// BehaviorState
#include "behaviorState/corruptorState/CorruptorBehaviorSpawn.h"
#include "behaviorState/corruptorState/CorruptorBehaviorMove.h"
#include "behaviorState/corruptorState/CorruptorBehaviorSelfDestruct.h"

#include "TimeManager.h"

void Corruptor::Initialize()
{
	// 3Dã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆç”Ÿæˆ
	object_ = std::make_unique<Object3d>();
	object_->Initialize("bomb.obj");

	moveVelocity_ = { 0.1f,0.1f,0.1f };

	object_->SetRotate(rotation_);
	scale_ = { 1.0f,1.0f,1.0f };
	object_->SetScale(scale_);
	// ãƒ©ã‚¤ãƒˆè¨­å®š
	//object_->SetDirectionalLightEnable(true);
	object_->SetLighting(true);

	// ã‚³ãƒ©ã‚¤ãƒ€ãƒ¼è¨­å®š
	colliderManager_ = ColliderManager::GetInstance();

	objectName_ = "Corruptor";

	desc = 
	{
		.owner = this,
		.colliderID = objectName_,
		.shape = Shape::AABB,
		.shapeData = &aabb_,
		.attribute = colliderManager_->GetNewAttribute(objectName_),
		.onCollision = std::bind(&Corruptor::OnCollision, this, std::placeholders::_1),
		.onCollisionTrigger = std::bind(&Corruptor::OnCollisionTrigger, this, std::placeholders::_1),
	};
	collider_.MakeAABBDesc(desc);
	colliderManager_->RegisterCollider(&collider_);

	// ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹
	isDead_ = false;

	// è¡Œå‹•ã‚¹ãƒ†ãƒ¼ãƒˆ
	pBehaviorState_ = std::make_unique<CorruptorBehaviorSpawn>(this);

	// å‡ºç¾æ™‚ã¯ç„¡æ•µçŠ¶æ…‹
	isInvincible_ = true;

	// ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«
	ParticleEmitter::Emit("laserGroup", position_, 2);
}

void Corruptor::Finalize()
{
	colliderManager_->DeleteCollider(&collider_);
}

void Corruptor::Update()
{
	// ãƒ‡ãƒ«ã‚¿ã‚¿ã‚¤ãƒ å–å¾—
	const float dt = TimeManager::Instance().GetDeltaTime();

	// ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ãƒ•ãƒ©ã‚°
	isActive_ = !isInvincible_;

	object_->Update();

	// è¡Œå‹•ã‚¹ãƒ†ãƒ¼ãƒˆæ›´æ–°
	pBehaviorState_->Update();

	// ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã¨ã®è·é›¢æ›´æ–°
	float distanceToPlayer = position_.Distance(playerPosition_);

	// ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã¨ã®è·é›¢ãŒä¸€å®šä»¥ä¸Šã‹ã©ã†ã‹ã®ãƒ•ãƒ©ã‚°æ›´æ–°
	isFarFromPlayer_ = (distanceToPlayer < 2.5f);

	// aabbã®æ›´æ–°
	aabb_.min = position_ - object_->GetScale();
	aabb_.max = position_ + object_->GetScale();
	aabb_.max.y += 1.0f;
	collider_.SetPosition(position_);

	if (isExploded_)
	{
		// çˆ†ç™ºå¾Œã«å°‘ã—ã ã‘ã‚¹ã‚±ãƒ¼ãƒ«ã‚’å¤§ããã™ã‚‹
		scale_ += Vector3(0.1f, 0.1f, 0.1f) * dt * kDefaultFrameRate;
	}

}

void Corruptor::Draw()
{
	if (!isExploded_)
	{
		object_->Draw();
	}
}

void Corruptor::Draw2D()
{
}

void Corruptor::ImGuiDraw()
{
#ifdef USE_IMGUI

	ImGui::Begin("Corruptor");
	ImGui::Text("Position: (%.2f, %.2f, %.2f)", position_.x, position_.y, position_.z);
	ImGui::Text("Rotation: (%.2f, %.2f, %.2f)", rotation_.x, rotation_.y, rotation_.z);
	ImGui::Text("Scale: (%.2f, %.2f, %.2f)", scale_.x, scale_.y, scale_.z);
	ImGui::Text("HP: %d", hp_);
	ImGui::Text("Is Dead: %s", isDead_ ? "Yes" : "No");
	ImGui::End();

#endif // USE_IMGUI
}

void Corruptor::Move()
{
	// ãƒ‡ãƒ«ã‚¿ã‚¿ã‚¤ãƒ å–å¾—
	const float dt = TimeManager::Instance().GetDeltaTime();

	// ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼æ–¹å‘ãƒ™ã‚¯ãƒˆãƒ«è¨ˆç®—
	toPlayer_ = playerPosition_ - position_;
	Vector3 direction = Normalize(toPlayer_);
	moveVelocity_ = Normalize(moveVelocity_);

	// è¿‘ã¥ã
	moveVelocity_ = Slerp(moveVelocity_, direction, 0.1f);

	// Yè»¸å›žè»¢ã‚’é€²è¡Œæ–¹å‘ã«åˆã‚ã›ã‚‹
	rotation_.y = std::atan2(moveVelocity_.x, moveVelocity_.z);
	rotation_.x = 0.0f;

	moveVelocity_ /= 7.0f;
	moveVelocity_.y = 0.0f;
	position_ += moveVelocity_ * dt * kDefaultFrameRate;

	ObjectTransformSet(position_, rotation_, scale_);

	ParticleEmitter::Emit("enemyWalk", position_, 1);

}

void Corruptor::ChangeBehaviorState(std::unique_ptr<CorruptorBehaviorState> _pState)
{
	pBehaviorState_ = std::move(_pState);
	pBehaviorState_->Initialize();
}

void Corruptor::ObjectTransformSet(const Vector3& _position, const Vector3& _rotation, const Vector3& _scale)
{
	object_->SetPosition(_position);
	object_->SetRotate(_rotation);
	object_->SetScale(_scale);
	object_->Update();
}

void Corruptor::OnCollisionTrigger(const Collider* _other)
{
	if (_other->GetColliderID() == "PlayerBullet" && !isInvincible_)
	{
		// ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®å¼¾ã¨è¡çªã—ãŸå ´åˆ
		if (hp_ > 1)
		{
			// HPæ¸›å°‘
			hp_--;

			isHit_ = true;
		}
	}

	if (_other->GetColliderID() == "NormalEnemy" or
		_other->GetColliderID() == "TrapEnemy" or
		_other->GetColliderID() == "Corruptor")
	{

		// æ•µã®ä½ç½®
		Vector3 enemyPosition = _other->GetOwner()->GetPosition();

		// æ•µåŒå£«ãŒé‡ãªã‚‰ãªã„ã‚ˆã†ã«ã™ã‚‹
		Vector3 direction = position_ - enemyPosition;
		direction.Normalize();
		float distance = 2.5f; // æ•µåŒå£«ã®é–“ã®è·é›¢ã‚’èª¿æ•´ã™ã‚‹ãŸã‚ã®å€¤

		// äº’ã„ã«é‡ãªã‚‰ãªã„ã‚ˆã†ã«å°‘ã—ãšã¤ä½ç½®ã‚’èª¿æ•´
		if ((position_ - enemyPosition).Length() < distance)
		{
			position_ += direction * 0.1f; // å¾®èª¿æ•´ã®ãŸã‚ã®å€¤
		}
	}
}

void Corruptor::OnCollision(const Collider* _other)
{
	if (_other->GetColliderID() == "Wall" or
		_other->GetColliderID() == "Barrie")
	{
		// ç›¸æ‰‹ã®AABBã‚’å–å¾—
		const AABB* otherAABB = _other->GetAABB();

		if (otherAABB)
		{
			// è‡ªåˆ†ã®AABBã¨ä½ç½®ã‚’æ¸¡ã—ã¦è£œæ­£
			CorrectOverlap(*otherAABB, aabb_, position_);
		}
	}
}

============================================================
File Path: project/application/objects/enemy/Corruptor.h
============================================================
#pragma once

#include "../../baseObject/GameObject.h"
#include "behaviorState/corruptorState/CorruptorBehaviorState.h"
#include"../../../gameEngine/collider/ColliderManager.h"
#include "../../../gameEngine/particle/ParticleEmitter.h"

#include <Object3d.h>
#include <Sprite.h>
#include <Framework.h>

/// <summary>
/// ãƒˆãƒ©ãƒƒãƒ—ã‚¨ãƒãƒŸãƒ¼æ­»äº¡æ™‚ã«å‡ºç¾ã™ã‚‹æ•µ
/// </summary>
class Corruptor : public GameObject
{
public:

	Corruptor() = default;
	~Corruptor() = default;
	
	// åˆæœŸåŒ–
	void Initialize() override;
	
	// çµ‚äº†
	void Finalize() override;
	
	// æ›´æ–°
	void Update() override;
	
	// æç”»
	void Draw() override;
	
	// ã‚¹ãƒ—ãƒ©ã‚¤ãƒˆæç”»
	void Draw2D();
	
	// ImGui
	void ImGuiDraw();

	// ç§»å‹•
	void Move();

	/// <summary>
	/// è¡Œå‹•ã‚¹ãƒ†ãƒ¼ãƒˆåˆ‡ã‚Šæ›¿ãˆ
	/// </summary>
	/// <param name="_pState">æ–°ã—ã„ã‚¹ãƒ†ãƒ¼ãƒˆã®ãƒã‚¤ãƒ³ã‚¿</param>
	void ChangeBehaviorState(std::unique_ptr<CorruptorBehaviorState> _pState);

private: // è¡çªåˆ¤å®š

	/// <summary>
	/// è¡çªæ™‚ã®å‡¦ç†
	/// </summary>
	/// <param name="_other">è¡çªç›¸æ‰‹ã®ã‚³ãƒ©ã‚¤ãƒ€ãƒ¼</param>
	void OnCollisionTrigger(const Collider* _other);

	/// <summary>
	/// è¡çªä¸­ã®å‡¦ç†
	/// </summary>
	/// <param name="_other">è¡çªç›¸æ‰‹ã®ã‚³ãƒ©ã‚¤ãƒ€ãƒ¼</param>
	void OnCollision(const Collider* _other);

public: // ã‚²ãƒƒã‚¿ãƒ¼

	// è¢«å¼¾ãƒ•ãƒ©ã‚°
	bool IsHit() const { return isHit_; }

	// ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã¨ã®è·é›¢ãŒä¸€å®šä»¥ä¸Šã‹ã©ã†ã‹ã®ãƒ•ãƒ©ã‚°
	bool IsFarFromPlayer() const { return isFarFromPlayer_; }

public: // ã‚»ãƒƒã‚¿ãƒ¼

	/// <summary>
	/// ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®ä½ç½®ã‚’ã‚»ãƒƒãƒˆ
	/// </summary>
	/// <param name="_playerPosition">ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®ä½ç½®</param>
	Vector3 SetPlayerPosition(const Vector3& _playerPosition) { return playerPosition_ = _playerPosition; }

	/// <summary>
	/// ç„¡æ•µãƒ•ãƒ©ã‚°ã‚’ã‚»ãƒƒãƒˆ
	/// </summary>
	/// <param name="_isInvincible">ç„¡æ•µãƒ•ãƒ©ã‚°</param>
	void SetIsInvincible(bool _isInvincible) { isInvincible_ = _isInvincible; }


	/// <summary>
	/// è¢«å¼¾ãƒ•ãƒ©ã‚°ã‚’ã‚»ãƒƒãƒˆ
	/// </summary>
	/// <param name="_isHit">è¢«å¼¾ãƒ•ãƒ©ã‚°</param>
	void SetIsHit(bool _isHit) { isHit_ = _isHit; }

	/// <summary>
	/// çˆ†ç™ºã—ãŸã‹ã©ã†ã‹ã®ãƒ•ãƒ©ã‚°ã‚’ã‚»ãƒƒãƒˆ
	/// </summary>
	/// <param name="_isExploded">çˆ†ç™ºãƒ•ãƒ©ã‚°</param>
	void SetIsExploded(bool _isExploded) { isExploded_ = _isExploded; }

	/// <summary>
	/// objectã®transformã‚’ã‚»ãƒƒãƒˆ
	/// </summary>
	/// <param name="_position">ä½ç½®</param>
	/// <param name="_rotation">å›žè»¢</param>
	/// <param name="_scale">ã‚¹ã‚±ãƒ¼ãƒ«</param>
	void ObjectTransformSet(const Vector3& _position, const Vector3& _rotation, const Vector3& _scale);

	/// ä»¥ä¸‹1ã¤ã¥ã¤ã‚»ãƒƒãƒˆ ///

	// ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®positionã‚’ã‚»ãƒƒãƒˆ
	void SetObjectPosition(const Vector3& _position) { object_->SetPosition(_position); }
	// ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®rotationã‚’ã‚»ãƒƒãƒˆ
	void SetObjectRotation(const Vector3& _rotation) { object_->SetRotate(_rotation); }
	// ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®scaleã‚’ã‚»ãƒƒãƒˆ
	void SetObjectScale(const Vector3& _scale) { object_->SetScale(_scale); }

private:

	// ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆãƒ•ãƒ¬ãƒ¼ãƒ ãƒ¬ãƒ¼ãƒˆ
	static constexpr float kDefaultFrameRate = 60.0f;

	// 3Dã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ
	std::unique_ptr<Object3d> object_ = nullptr;

	// å½“ãŸã‚Šåˆ¤å®šé–¢ä¿‚
	ColliderManager* colliderManager_ = nullptr;
	Collider collider_;
	AABB aabb_;
	Collider::ColliderDesc desc = {};

	// ç§»å‹•é€Ÿåº¦
	Vector3 moveVelocity_{};
	float moveSpeed_ = 0.05f;

	// ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®ä½ç½®
	Vector3 playerPosition_{};
	Vector3 toPlayer_{};

	// è¡Œå‹•ã‚¹ãƒ†ãƒ¼ãƒˆ
	std::unique_ptr<CorruptorBehaviorState> pBehaviorState_ = nullptr;

	// ç„¡æ•µãƒ•ãƒ©ã‚°(å‡ºç¾æ™‚ç­‰æ”»æ’ƒã‚’å—ã‘ãªãã•ã›ã‚‹)
	bool isInvincible_ = true;

	// è¢«å¼¾ãƒ•ãƒ©ã‚°
	bool isHit_ = false;

	// ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã¨ã®è·é›¢ãŒä¸€å®šä»¥ä¸Šã‹ã©ã†ã‹ã®ãƒ•ãƒ©ã‚°
	bool isFarFromPlayer_ = false;

	// çˆ†ç™ºãƒ•ãƒ©ã‚°(çˆ†ç™ºå¾Œã®åˆ¤å®šç”¨ã«isDead_ã¯å–ã£ã¦ãŠããŸã„)
	bool isExploded_ = false;

};



============================================================
File Path: project/application/objects/enemy/EnemyManager.cpp
============================================================
#include "EnemyManager.h"

#include "waveState/EnemyWaveStage1.h"
#include "waveState/EnemyWaveStage2.h"

#include "TimeManager.h"

void EnemyManager::Initialize()
{
	// ã‚¨ãƒ‡ã‚£ã‚¿èª­ã¿è¾¼ã¿
	auto levelData = std::make_shared<LevelData>();
	levelData = LevelDataLoader::LoadLevelData("enemySpawn");
	SetLevelData(levelData);

	// ã‚¦ã‚§ãƒ¼ãƒ–ã‚¹ãƒ†ãƒ¼ãƒˆ
	ChangeState(std::make_unique<EnemyWaveStage1>(this));
}

void EnemyManager::Finalize()
{
	for (auto& enemy : pTrapEnemies_)
	{
		enemy->Finalize();
	}

	for (auto& enemy : pNormalEnemies_)
	{
		enemy->Finalize();
	}

	for(auto& corruptor : pCorruptors_)
	{
		corruptor->Finalize();
	}
}

void EnemyManager::Update()
{
	// ãƒ‡ãƒ«ã‚¿ã‚¿ã‚¤ãƒ å–å¾—
	const float dt = TimeManager::Instance().GetDeltaTime();
	// ã‚¢ãƒƒãƒ—ãƒ‡ãƒ¼ãƒˆã™ã‚‹ãƒ•ãƒ¬ãƒ¼ãƒ æ•°è¨ˆç®—
	const int framesThisUpdate = std::max(1, static_cast<int>(dt * 60.0f + 0.5f));

	// ãƒŽãƒ¼ãƒžãƒ«ã‚¨ãƒãƒŸãƒ¼ã®æ›´æ–°
	for (auto& enemy : pNormalEnemies_)
	{
		enemy->SetPlayerPosition(playerPosition_);
		enemy->Update();
		toPlayerDistance_.push_back(enemy->GetToPlayer());
	}

	// isDeat ãŒãŸã£ãŸã‚‰å‰Šé™¤
	pNormalEnemies_.erase(
		std::remove_if(
			pNormalEnemies_.begin(),
			pNormalEnemies_.end(),
			[this](std::unique_ptr<NormalEnemy>& enemy)
			{
				if (enemy->IsDead())
				{
					enemy->Finalize();

					// æ•µã®ã‚«ã‚¦ãƒ³ãƒˆã‚’æ¸›ã‚‰ã™
					enemyCount_--;

					return true;
				}
				return false;
			}),
		pNormalEnemies_.end()
	);

	// ãƒˆãƒ©ãƒƒãƒ—ã‚¨ãƒãƒŸãƒ¼ã®æ›´æ–°
	for (auto& enemy : pTrapEnemies_)
	{
		enemy->SetPlayerPosition(playerPosition_);
		enemy->Update();
	}

	// isDead ãŒãŸã£ãŸã‚‰å‰Šé™¤
	pTrapEnemies_.erase(
		std::remove_if(
			pTrapEnemies_.begin(),
			pTrapEnemies_.end(),
			[this](std::unique_ptr<TrapEnemy>& enemy)
			{
				if (enemy->IsDead())
				{
					// Finalize å‰ã«æ®‹ã£ã¦ã„ã‚‹ç½ ã®ä½ç½®ã‚’å–å¾—
					std::vector<Vector3> remainingTraps = enemy->GetRemainingTimeBombPositions();

					// å‡ºç¾ä½ç½®ã«Corruptorã‚’ç”Ÿæˆ
					for (const auto& trapPos : remainingTraps)
					{
						CorruptorInit(trapPos);
					}

					enemy->Finalize();
					// æ•µã®ã‚«ã‚¦ãƒ³ãƒˆã‚’æ¸›ã‚‰ã™
					enemyCount_--;
					return true;
				}
				return false;
			}),
		pTrapEnemies_.end()
	);

	// ã‚³ãƒ©ãƒ—ã‚¿ãƒ¼ã®æ›´æ–°
	for(auto& corruptor : pCorruptors_)
	{
		corruptor->SetPlayerPosition(playerPosition_);
		corruptor->Update();
	}

	// isDead ãŒãŸã£ãŸã‚‰å‰Šé™¤
	pCorruptors_.erase(
		std::remove_if(
			pCorruptors_.begin(),
			pCorruptors_.end(),
			[this](std::unique_ptr<Corruptor>& corruptor)
			{
				if (corruptor->IsDead())
				{
					corruptor->Finalize();
					// æ•µã®ã‚«ã‚¦ãƒ³ãƒˆã‚’æ¸›ã‚‰ã™
					enemyCount_--;
					return true;
				}
				return false;
			}),
		pCorruptors_.end()
	);

	// ã‚¦ã‚§ãƒ¼ãƒ–ã‚¹ãƒ†ãƒ¼ãƒˆã®æ›´æ–°
	pState_->Update();
	
	// æ•µãŒå…¨ã¦å€’ã•ã‚ŒãŸã‚‰ã‚¦ã‚§ãƒ¼ãƒ–ãƒã‚§ãƒ³ã‚¸é–‹å§‹
	if (enemyCount_ == 0)
	{
		if (waveChangeInterval_ > 0)
		{
			isWaveChange_ = false;
			waveChangeInterval_ = std::max(0, waveChangeInterval_ - framesThisUpdate);
		} 
		else
		{
			// ã‚¹ãƒ†ãƒ¼ãƒˆé·ç§»
			isWaveChange_ = true;
			waveChangeInterval_ = 120;
		}
	}
}

void EnemyManager::Draw()
{
	for (auto& enemy : pNormalEnemies_)
	{
		enemy->Draw();
	}

	for (auto& enemy : pTrapEnemies_)
	{
		enemy->Draw();
	}

	for(auto& corruptor : pCorruptors_)
	{
		corruptor->Draw();
	}

}

void EnemyManager::ImGuiDraw()
{
#ifdef USE_IMGUI

	for (auto& enemy : pNormalEnemies_)
	{
		enemy->ImGuiDraw();
	}

	for (auto& enemy : pTrapEnemies_)
	{
		enemy->ImGuiDraw();
	}

#endif // USE_IMGUI
}

void EnemyManager::TitleEnemyInit()
{
	NormalEnemyInit({ 2.0f,0.5f,-5.0f });
	TrapEnemyInit({ -2.0f,0.5f,2.0f });
	NormalEnemyInit({ -5.0f,0.5f,-2.0f });
	TrapEnemyInit({ 5.0f,0.5f,5.0f });
}

void EnemyManager::TitleEnemyUpdate()
{
	// ãƒŽãƒ¼ãƒžãƒ«ã‚¨ãƒãƒŸãƒ¼ã®æ›´æ–°
	for (auto& enemy : pNormalEnemies_)
	{
		enemy->SetPlayerPosition(playerPosition_);
		enemy->Update();
		toPlayerDistance_.push_back(enemy->GetToPlayer());
	}

	// isDeat ãŒãŸã£ãŸã‚‰å‰Šé™¤
	pNormalEnemies_.erase(
		std::remove_if(
			pNormalEnemies_.begin(),
			pNormalEnemies_.end(),
			[this](std::unique_ptr<NormalEnemy>& enemy)
			{
				if (enemy->IsDead())
				{
					enemy->Finalize();

					// æ•µã®ã‚«ã‚¦ãƒ³ãƒˆã‚’æ¸›ã‚‰ã™
					enemyCount_--;

					return true;
				}
				return false;
			}),
		pNormalEnemies_.end()
	);

	// ãƒˆãƒ©ãƒƒãƒ—ã‚¨ãƒãƒŸãƒ¼ã®æ›´æ–°
	for (auto& enemy : pTrapEnemies_)
	{
		enemy->SetPlayerPosition(playerPosition_);
		enemy->Update();
	}

	// isDead ãŒãŸã£ãŸã‚‰å‰Šé™¤
	pTrapEnemies_.erase(
		std::remove_if(
			pTrapEnemies_.begin(),
			pTrapEnemies_.end(),
			[this](std::unique_ptr<TrapEnemy>& enemy)
			{
				if (enemy->IsDead())
				{
					enemy->Finalize();
					// æ•µã®ã‚«ã‚¦ãƒ³ãƒˆã‚’æ¸›ã‚‰ã™
					enemyCount_--;
					return true;
				}
				return false;
			}),
		pTrapEnemies_.end()
	);

	// æ•µãŒå…¨ã¦å€’ã•ã‚ŒãŸã‚‰ã‚‚ã†ä¸€åº¦å‡ºç¾
	if (enemyCount_ == 0)
	{
		TitleEnemyInit();
	}
}

void EnemyManager::GameOverEnemyInit()
{
	NormalEnemyInit({ -20.0f,0.5f,0.0f });
}

void EnemyManager::GameOverEnemyUpdate()
{
	// ãƒŽãƒ¼ãƒžãƒ«ã‚¨ãƒãƒŸãƒ¼ã®æ›´æ–°
	for (auto& enemy : pNormalEnemies_)
	{
		enemy->SetPlayerPosition(playerPosition_);
		enemy->Update();
		toPlayerDistance_.push_back(enemy->GetToPlayer());
	}

	// isDeat ãŒãŸã£ãŸã‚‰å‰Šé™¤
	pNormalEnemies_.erase(
		std::remove_if(
			pNormalEnemies_.begin(),
			pNormalEnemies_.end(),
			[this](std::unique_ptr<NormalEnemy>& enemy)
			{
				if (enemy->IsDead())
				{
					enemy->Finalize();

					// æ•µã®ã‚«ã‚¦ãƒ³ãƒˆã‚’æ¸›ã‚‰ã™
					enemyCount_--;

					return true;
				}
				return false;
			}),
		pNormalEnemies_.end()
	);

	// æ•µãŒå…¨ã¦å€’ã•ã‚ŒãŸã‚‰ã‚‚ã†ä¸€åº¦å‡ºç¾
	if (enemyCount_ == 0)
	{
		GameOverEnemyInit();
	}
}

void EnemyManager::NormalEnemyInit(const Vector3& pos)
{
	// ãƒŽãƒ¼ãƒžãƒ«ã‚¨ãƒãƒŸãƒ¼
	std::unique_ptr<NormalEnemy> enemy = std::make_unique<NormalEnemy>();
	enemy->SetPosition(pos);
	enemy->Initialize();
	enemy->SetPlayerPosition(playerPosition_);
	enemy->Update();

	// æ•µã‚’ç™»éŒ²
	pNormalEnemies_.push_back(std::move(enemy));

	// æ•µã®ã‚«ã‚¦ãƒ³ãƒˆã‚’å¢—ã‚„ã™
	enemyCount_++;
}

void EnemyManager::TrapEnemyInit(const Vector3& pos)
{
	// ãƒˆãƒ©ãƒƒãƒ—ã‚¨ãƒãƒŸãƒ¼
	std::unique_ptr<TrapEnemy> trapEnemy = std::make_unique<TrapEnemy>();
	trapEnemy->SetPosition(pos);
	trapEnemy->Initialize();
	trapEnemy->SetPlayerPosition(playerPosition_);
	trapEnemy->Update();

	// æ•µã‚’ç™»éŒ²
	pTrapEnemies_.push_back(std::move(trapEnemy));

	// æ•µã®ã‚«ã‚¦ãƒ³ãƒˆã‚’å¢—ã‚„ã™
	enemyCount_++;
}

void EnemyManager::CorruptorInit(const Vector3& pos)
{
	// ã‚³ãƒ©ãƒ—ã‚¿ãƒ¼
	std::unique_ptr<Corruptor> corruptor = std::make_unique<Corruptor>();
	corruptor->SetPosition(pos);
	corruptor->Initialize();
	corruptor->SetPlayerPosition(playerPosition_);
	corruptor->Update();

	// æ•µã‚’ç™»éŒ²
	pCorruptors_.push_back(std::move(corruptor));
	
	// æ•µã®ã‚«ã‚¦ãƒ³ãƒˆã‚’å¢—ã‚„ã™
	enemyCount_++;
}

void EnemyManager::ChangeState(std::unique_ptr<EnemyWaveState> _pState)
{
	pState_ = std::move(_pState);
	pState_->Initialize();
}


============================================================
File Path: project/application/objects/enemy/EnemyManager.h
============================================================
#pragma once

#include <vector>
#include <Framework.h>

#include "NormalEnemy.h"
#include "TrapEnemy.h"
#include "Corruptor.h"
#include "waveState/EnemyWaveState.h"
#include "../../../gameEngine/level_editor/LevelDataLoader.h"

/// <summary>
/// æ•µãƒžãƒãƒ¼ã‚¸ãƒ£ãƒ¼
/// </summary>
class EnemyManager
{
public:

	EnemyManager() = default;
	~EnemyManager() = default;

	// åˆæœŸåŒ–
	void Initialize();

	// çµ‚äº†
	void Finalize();

	// æ›´æ–°
	void Update();

	// æç”»
	void Draw();

	// ImGui
	void ImGuiDraw();

	// ã‚¿ã‚¤ãƒˆãƒ«ã‚·ãƒ¼ãƒ³ç”¨ã®æ•µåˆæœŸåŒ–
	void TitleEnemyInit();

	// ã‚¿ã‚¤ãƒˆãƒ«ã‚·ãƒ¼ãƒ³ç”¨ã®æ•µæ›´æ–°
	void TitleEnemyUpdate();

	// ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼ã‚·ãƒ¼ãƒ³ç”¨ã®æ•µåˆæœŸåŒ–
	void GameOverEnemyInit();

	// ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼ã‚·ãƒ¼ãƒ³ç”¨ã®æ•µæ›´æ–°
	void GameOverEnemyUpdate();

	// æ•µã®åˆæœŸåŒ–
	/// <summary>
	/// é€šå¸¸æ•µã®åˆæœŸåŒ–
	/// </summary>
	/// <param name="pos">å‡ºç¾ä½ç½®</param>
	void NormalEnemyInit(const Vector3& pos);
	/// <summary>
	/// ãƒˆãƒ©ãƒƒãƒ—æ•µã®åˆæœŸåŒ–
	/// </summary>
	/// <param name="pos">å‡ºç¾ä½ç½®</param>
	void TrapEnemyInit(const Vector3& pos);
	/// <summary>
	/// ã‚³ãƒ©ãƒ—ã‚¿ãƒ¼ã®åˆæœŸåŒ–
	/// </summary>
	/// <param name="pos">å‡ºç¾ä½ç½®</param>
	void CorruptorInit(const Vector3& pos);

	/// <summary>
	/// æ•µã®ã‚¦ã‚§ãƒ¼ãƒ–ã‚¹ãƒ†ãƒ¼ãƒˆåˆ‡ã‚Šæ›¿ãˆ
	/// </summary>
	/// <param name="_pState">æ–°ã—ã„ã‚¹ãƒ†ãƒ¼ãƒˆ</param>
	void ChangeState(std::unique_ptr<EnemyWaveState>_pState);

public: // ã‚²ãƒƒã‚¿ãƒ¼

	// ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã¨ã®è·é›¢ã®ã‚²ãƒƒã‚¿ãƒ¼
	const std::vector<Vector3>& GetToPlayerDistance() const { return toPlayerDistance_; }

	// æ•µã®ã‚¦ã‚§ãƒ¼ãƒ–åˆ‡ã‚Šæ›¿ãˆãƒ•ãƒ©ã‚°
	bool IsWaveChange() const { return isWaveChange_; }

	// å…¨ã¦ã®ã‚¦ã‚§ãƒ¼ãƒ–ã®æ•µã‚’å€’ã—ãŸã‹ã©ã†ã‹ã®ãƒ•ãƒ©ã‚°
	bool IsAllEnemyDefeated() const { return isAllEnemyDefeated_; }

	// ãƒ¬ãƒ™ãƒ«ã‚¨ãƒ‡ã‚£ã‚¿
	std::shared_ptr<LevelData> GetLevelData() const { return levelData_; }

public: // ã‚»ãƒƒã‚¿ãƒ¼

	/// <summary>
	/// ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®ä½ç½®ã‚’ã‚»ãƒƒãƒˆ
	/// </summary>
	/// <param name="playerPosition">ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®ä½ç½®ãƒ™ã‚¯ãƒˆãƒ«</param>
	void SetPlayerPosition(const Vector3& playerPosition) { playerPosition_ = playerPosition; }

	/// <summary>
	/// å…¨ã¦ã®ã‚¦ã‚§ãƒ¼ãƒ–ã®æ•µã‚’å€’ã—ãŸã‚‰ç«‹ã¦ã‚‹ãƒ•ãƒ©ã‚°ã‚»ãƒƒãƒˆ
	/// </summary>
	/// <param name="isDefeated">ãƒ•ãƒ©ã‚°</param>
	void SetAllEnemyDefeated(bool isDefeated) { isAllEnemyDefeated_ = isDefeated; }

	/// <summary>
	/// ã‚¨ãƒ‡ã‚£ã‚¿ã‚»ãƒƒãƒˆ
	/// </summary>
	/// <param name="_levelData">ãƒ¬ãƒ™ãƒ«ãƒ‡ãƒ¼ã‚¿ãƒ­ãƒ¼ãƒ€ãƒ¼</param>
	void SetLevelData(std::shared_ptr<LevelData> _levelData) { levelData_ = _levelData; }

private:

	// ã‚¨ãƒãƒŸãƒ¼
	std::vector<std::unique_ptr<NormalEnemy>> pNormalEnemies_;
	// ãƒˆãƒ©ãƒƒãƒ—ã‚¨ãƒãƒŸãƒ¼
	std::vector<std::unique_ptr<TrapEnemy>> pTrapEnemies_;
	// ã‚³ãƒ©ãƒ—ã‚¿ãƒ¼
	std::vector<std::unique_ptr<Corruptor>> pCorruptors_;

	// æ•µã®æ•°
	uint32_t enemyCount_ = 0;

	// æ•µã®ã‚¦ã‚§ãƒ¼ãƒ–ã‚¹ãƒ†ãƒ¼ãƒˆ
	std::unique_ptr<EnemyWaveState> pState_ = nullptr;
	// æ•µã®ã‚¦ã‚§ãƒ¼ãƒ–åˆ‡ã‚Šæ›¿ãˆ
	bool isWaveChange_ = false;
	// æ•µã®ã‚¦ã‚§ãƒ¼ãƒ–åˆ‡ã‚Šæ›¿ãˆã‚¤ãƒ³ã‚¿ãƒ¼ãƒãƒ«
	int32_t waveChangeInterval_ = 250;

	// ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®ä½ç½®
	Vector3 playerPosition_{};
	// ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã¨ã®è·é›¢
	std::vector<Vector3> toPlayerDistance_;

	// å…¨ã¦ã®ã‚¦ã‚§ãƒ¼ãƒ–ã®æ•µã‚’å€’ã—ãŸã‚‰ç«‹ã¦ã‚‹ãƒ•ãƒ©ã‚°
	bool isAllEnemyDefeated_ = false;

	// ãƒ¬ãƒ™ãƒ«ãƒ‡ãƒ¼ã‚¿ãƒ­ãƒ¼ãƒ€ãƒ¼
	std::shared_ptr<LevelData> levelData_ = nullptr;

};



============================================================
File Path: project/application/objects/enemy/behaviorState/corruptorState/CorruptorBehaviorMove.cpp
============================================================
#include "CorruptorBehaviorMove.h"

#include <Ease.h>

#include "../../Corruptor.h"
#include "CorruptorBehaviorSelfDestruct.h"

CorruptorBehaviorMove::CorruptorBehaviorMove(Corruptor* _pCorruptor) : CorruptorBehaviorState("Move", _pCorruptor)
{
	motion_.isActive = true;
	motion_.count = 0;
	motion_.maxCount = 30; // ç§»å‹•ãƒ¢ãƒ¼ã‚·ãƒ§ãƒ³ã®ã‚«ã‚¦ãƒ³ãƒˆã‚’è¨­å®š
}

void CorruptorBehaviorMove::Initialize()
{
}

void CorruptorBehaviorMove::Update()
{
	// æ•µã®ãƒˆãƒ©ãƒ³ã‚¹ãƒ•ã‚©ãƒ¼ãƒ ã‚’motion_.transformã«ã‚»ãƒƒãƒˆ
	TransformUpdate(pCorruptor_);
	
	// å‹•ãå‰ã«åˆ‡ã‚Šæ›¿ãˆå‡¦ç†
	if (pCorruptor_->IsHit() or pCorruptor_->IsFarFromPlayer())
	{
		// ãƒ’ãƒƒãƒˆãƒ•ãƒ©ã‚°ã‚’ãƒªã‚»ãƒƒãƒˆ
		pCorruptor_->SetIsHit(false);

		// ç„¡æ•µåŒ–
		pCorruptor_->SetIsInvincible(true);

		// ãƒ’ãƒƒãƒˆã—ãŸã‚‰ã€è‡ªçˆ†ãƒ¢ãƒ¼ã‚·ãƒ§ãƒ³ã«åˆ‡ã‚Šæ›¿ãˆ
		pCorruptor_->ChangeBehaviorState(std::make_unique<CorruptorBehaviorSelfDestruct>(pCorruptor_));
		
		return;
	}
	else if (!motion_.isActive)
	{
		// ã‚¹ãƒ†ãƒ¼ãƒˆãŒåˆ‡ã‚Šæ›¿ã‚ã‚‰ãªã‹ã£ãŸã‚‰ã‚‚ã†ä¸€åº¦
		ResetMotion();
	}
	
	// ã‚¤ãƒ¼ã‚¸ãƒ³ã‚°é€²è¡Œåº¦ï¼ˆ0ã€œ1ï¼‰
	float t = float(motion_.count) / motion_.maxCount;

	// ãƒãƒ¨ãƒãƒ¨æ‹¡å¤§ç¸®å°ï¼ˆXãƒ»Yä¸¡æ–¹ï¼‰
	float scaleWaveX = 1.0f + std::sin(t * std::numbers::pi_v<float>) * 0.2f;
	float scaleWaveY = 1.0f + std::cos(t * std::numbers::pi_v<float>) * 0.2f;

	// ã‚¹ã‚±ãƒ¼ãƒ«ã‚’æ›´æ–°ï¼ˆXãƒ»Yä¸¡æ–¹ãƒãƒ¨ãƒãƒ¨ï¼‰
	motion_.transform.scale = Vector3(scaleWaveX, scaleWaveY, 1.0f);

	// ã‚¹ã‚±ãƒ¼ãƒ«ã‚’é©ç”¨
	pCorruptor_->SetObjectScale(motion_.transform.scale);

	// ãƒ¢ãƒ¼ã‚·ãƒ§ãƒ³ã‚«ã‚¦ãƒ³ãƒˆã‚’æ›´æ–°
	MotionCount(motion_);

	// ç§»å‹•
	pCorruptor_->Move();

}

void CorruptorBehaviorMove::ResetMotion()
{
	motion_.isActive = true;
	motion_.count = 0;
	motion_.maxCount = 30; // ç§»å‹•ãƒ¢ãƒ¼ã‚·ãƒ§ãƒ³ã®ã‚«ã‚¦ãƒ³ãƒˆã‚’è¨­å®š
}


============================================================
File Path: project/application/objects/enemy/behaviorState/corruptorState/CorruptorBehaviorMove.h
============================================================
#pragma once

#include "CorruptorBehaviorState.h"

class CorruptorBehaviorMove : public CorruptorBehaviorState
{
public:

	/// <summary>
	/// ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿
	/// </summary>
	/// <param name="_pCorruptor">ã‚³ãƒ©ãƒ—ã‚¿ãƒ¼ã®ãƒã‚¤ãƒ³ã‚¿</param>
	CorruptorBehaviorMove(Corruptor* _pCorruptor);

	// åˆæœŸåŒ–
	void Initialize() override;
	
	// æ›´æ–°
	void Update() override;
	
	// ãƒ¢ãƒ¼ã‚·ãƒ§ãƒ³ã®ãƒªã‚»ãƒƒãƒˆ
	void ResetMotion() override;

};



============================================================
File Path: project/application/objects/enemy/behaviorState/corruptorState/CorruptorBehaviorSelfDestruct.cpp
============================================================
#include "CorruptorBehaviorSelfDestruct.h"

#include <Ease.h>

#include "../../Corruptor.h"

CorruptorBehaviorSelfDestruct::CorruptorBehaviorSelfDestruct(Corruptor* _pCorruptor) : CorruptorBehaviorState("SelfDestruct", _pCorruptor)
{
	motion_.isActive = true;
	motion_.count = 0;
	motion_.maxCount = 60; // è‡ªçˆ†ãƒ¢ãƒ¼ã‚·ãƒ§ãƒ³ã®ã‚«ã‚¦ãƒ³ãƒˆã‚’è¨­å®š
}

void CorruptorBehaviorSelfDestruct::Initialize()
{
}

void CorruptorBehaviorSelfDestruct::Update()
{
	// æ•µã®ãƒˆãƒ©ãƒ³ã‚¹ãƒ•ã‚©ãƒ¼ãƒ ã‚’motion_.transformã«ã‚»ãƒƒãƒˆ
	TransformUpdate(pCorruptor_);
	
	// ã‚¤ãƒ¼ã‚¸ãƒ³ã‚°ã®é€²è¡Œåº¦
	float t = float(motion_.count) / motion_.maxCount;
	
	// ã¯ã˜ã‘ã‚‹æ¼”å‡º
	float scale = Lerp(1.0f, 2.0f, Ease::OutCubic(t));
	motion_.transform.scale = Vector3(scale, scale, scale);

	// æºã‚Œæ¼”å‡º
	Vector3 shakeOffset =
	{
	((motion_.count % 2 == 0) ? 1.0f : -1.0f) * 0.1f,
	0.0f, // Yè»¸ã¯æºã‚‰ã•ãªã„
	((motion_.count % 3 == 0) ? 1.0f : -1.0f) * 0.1f
	};

	Vector3 originPos = pCorruptor_->GetPosition();

	pCorruptor_->SetObjectPosition(originPos + shakeOffset);
	pCorruptor_->SetObjectScale(motion_.transform.scale);
	pCorruptor_->SetScale(motion_.transform.scale);

	// ãƒ¢ãƒ¼ã‚·ãƒ§ãƒ³ã‚«ã‚¦ãƒ³ãƒˆ
	MotionCount(motion_);

	if(!motion_.isActive)
	{
		// è‡ªçˆ†ã—ãŸã®ã§ãƒ‡ã‚¹ãƒ•ãƒ©ã‚°ã‚’ç«‹ã¦ã‚‹
		pCorruptor_->SetIsDead(true);

		// ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«
		ParticleEmitter::Emit("explosionGroup", motion_.transform.position, 15);
		ParticleEmitter::Emit("rupture", motion_.transform.position, 20);
		ParticleEmitter::Emit("BltReaction", motion_.transform.position, 1);
	}

}

void CorruptorBehaviorSelfDestruct::ResetMotion()
{
}


============================================================
File Path: project/application/objects/enemy/behaviorState/corruptorState/CorruptorBehaviorSelfDestruct.h
============================================================
#pragma once

#include "CorruptorBehaviorState.h"

class CorruptorBehaviorSelfDestruct : public CorruptorBehaviorState
{
public:

	/// <summary>
	/// ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿
	/// </summary>
	/// <param name="_pCorruptor">ã‚³ãƒ©ãƒ—ã‚¿ãƒ¼ã®ãƒã‚¤ãƒ³ã‚¿</param>
	CorruptorBehaviorSelfDestruct(Corruptor* _pCorruptor);

	// åˆæœŸåŒ–
	void Initialize() override;

	// æ›´æ–°
	void Update() override;

	// ãƒ¢ãƒ¼ã‚·ãƒ§ãƒ³ã®ãƒªã‚»ãƒƒãƒˆ
	void ResetMotion() override;

};



============================================================
File Path: project/application/objects/enemy/behaviorState/corruptorState/CorruptorBehaviorSpawn.cpp
============================================================
#include "CorruptorBehaviorSpawn.h"

#include <Ease.h>

#include "../../Corruptor.h"
#include "CorruptorBehaviorMove.h"

CorruptorBehaviorSpawn::CorruptorBehaviorSpawn(Corruptor* _pCorruptor) : CorruptorBehaviorState("Spawn", _pCorruptor)
{
	// ãƒ¢ãƒ¼ã‚·ãƒ§ãƒ³ã®åˆæœŸåŒ–
	motion_.isActive = true;
	motion_.count = 0;
	motion_.maxCount = 30; // ã‚¹ãƒãƒ¼ãƒ³ãƒ¢ãƒ¼ã‚·ãƒ§ãƒ³ã®ã‚«ã‚¦ãƒ³ãƒˆã‚’è¨­å®š
}

void CorruptorBehaviorSpawn::Initialize()
{
}

void CorruptorBehaviorSpawn::Update()
{
	// æ•µã®ãƒˆãƒ©ãƒ³ã‚¹ãƒ•ã‚©ãƒ¼ãƒ ã‚’motion_.transformã«ã‚»ãƒƒãƒˆ
	TransformUpdate(pCorruptor_);

	// ã‚¤ãƒ¼ã‚¸ãƒ³ã‚°ã®é€²è¡Œåº¦
	float t = float(motion_.count) / motion_.maxCount;

	// å›žè»¢
	motion_.transform.rotation.y = Lerp(0.0f, std::numbers::pi_v<float> *2.0f, Ease::OutCubic(t));

	// ãƒˆãƒ©ãƒ³ã‚¹ãƒ•ã‚©ãƒ¼ãƒ ã‚’æ•µã«åæ˜ 
	pCorruptor_->SetObjectPosition(motion_.transform.position);

	// ãƒ¢ãƒ¼ã‚·ãƒ§ãƒ³ã‚«ã‚¦ãƒ³ãƒˆã‚’æ›´æ–°
	MotionCount(motion_);

	if (!motion_.isActive)
	{
		// ç„¡æ•µçŠ¶æ…‹ã‚’è§£é™¤
		pCorruptor_->SetIsInvincible(false);

		// ã‚¹ãƒãƒ¼ãƒ³ãƒ¢ãƒ¼ã‚·ãƒ§ãƒ³ãŒçµ‚äº†ã—ãŸã‚‰ã€æ¬¡ã®çŠ¶æ…‹ã«ç§»è¡Œ
		pCorruptor_->ChangeBehaviorState(std::make_unique<CorruptorBehaviorMove>(pCorruptor_));
	}
}

void CorruptorBehaviorSpawn::ResetMotion()
{
}


============================================================
File Path: project/application/objects/enemy/behaviorState/corruptorState/CorruptorBehaviorSpawn.h
============================================================
#pragma once

#include "CorruptorBehaviorState.h"

/// <summary>
/// ã‚³ãƒ©ãƒ—ã‚¿ãƒ¼ã®å‡ºç¾çŠ¶æ…‹
/// </summary>
class CorruptorBehaviorSpawn : public CorruptorBehaviorState
{
public:

	/// <summary>
	/// ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿
	/// </summary>
	/// <param name="_pCorruptor">ã‚³ãƒ©ãƒ—ã‚¿ãƒ¼ã®ãƒã‚¤ãƒ³ã‚¿</param>
	CorruptorBehaviorSpawn(Corruptor* _pCorruptor);
	
	// åˆæœŸåŒ–
	void Initialize() override;
	
	// æ›´æ–°
	void Update() override;
	
	// ãƒ¢ãƒ¼ã‚·ãƒ§ãƒ³ã®ãƒªã‚»ãƒƒãƒˆ
	void ResetMotion() override;

};



============================================================
File Path: project/application/objects/enemy/behaviorState/corruptorState/CorruptorBehaviorState.cpp
============================================================
#include "CorruptorBehaviorState.h"

#include "../../Corruptor.h"

CorruptorBehaviorState::~CorruptorBehaviorState()
{
}

void CorruptorBehaviorState::MotionCount(Motion& _motion)
{
	if (_motion.count < _motion.maxCount)
	{
		_motion.count++;
	} else
	{
		// ãƒ¢ãƒ¼ã‚·ãƒ§ãƒ³çµ‚äº† ã‚«ã‚¦ãƒ³ãƒˆãƒªã‚»ãƒƒãƒˆ
		_motion.isActive = false;
		_motion.count = 0;
	}
}

void CorruptorBehaviorState::TransformUpdate(Corruptor* _pEnemy)
{
	if (_pEnemy)
	{
		motion_.transform.position = _pEnemy->GetPosition();
		motion_.transform.rotation = _pEnemy->GetRotation();
		motion_.transform.scale = _pEnemy->GetScale();
	}
}


============================================================
File Path: project/application/objects/enemy/behaviorState/corruptorState/CorruptorBehaviorState.h
============================================================
#pragma once

#include <sstream>
#include <Vector3.h>

// å‰æ–¹å®£è¨€
class Corruptor;

/// <summary>
/// ã‚³ãƒ©ãƒ—ã‚¿ãƒ¼è¡Œå‹•ã‚¹ãƒ†ãƒ¼ãƒˆåŸºåº•ã‚¯ãƒ©ã‚¹
/// è¡Œå‹•ã‚¹ãƒ†ãƒ¼ãƒˆã¯ä»¥ä¸‹ã®3ã¤
/// ãƒ»å‡ºç¾
/// ãƒ»ç§»å‹•
/// ãƒ»è‡ªçˆ†(æ­»äº¡æ™‚ã‚‚åŒã˜è¡Œå‹•)
/// </summary>
class CorruptorBehaviorState
{
public:

	/// <summary>
	/// ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿
	/// </summary>
	/// <param name="_name">ã‚¹ãƒ†ãƒ¼ãƒˆå</param>
	/// <param name="_corruptor">ã‚³ãƒ©ãƒ—ã‚¿ãƒ¼ã®ãƒã‚¤ãƒ³ã‚¿</param>
	CorruptorBehaviorState(const std::string& _name, Corruptor* _corruptor) : stateName_(_name), pCorruptor_(_corruptor){}
	
	virtual ~CorruptorBehaviorState();
	
	// åˆæœŸåŒ–
	virtual void Initialize() = 0;
	
	// æ›´æ–°
	virtual void Update() = 0;
	
	// ãƒ¢ãƒ¼ã‚·ãƒ§ãƒ³ãƒªã‚»ãƒƒãƒˆ
	virtual void ResetMotion() = 0;
	
protected:

	struct Transform
	{
		Vector3 position{};
		Vector3 rotation{};
		Vector3 scale{};
	};

	struct Motion
	{
		// ãƒ¢ãƒ¼ã‚·ãƒ§ãƒ³ãŒã‚¢ã‚¯ãƒ†ã‚£ãƒ–ã‹ã©ã†ã‹
		bool isActive = false;
		// ã‚«ã‚¦ãƒ³ãƒˆ
		uint32_t count = 0;
		// Maxã‚«ã‚¦ãƒ³ãƒˆ
		uint32_t maxCount = 30;
		// ãƒˆãƒ©ãƒ³ã‚¹ãƒ•ã‚©ãƒ¼ãƒ 
		Transform transform;
	};

	// ãƒ¢ãƒ¼ã‚·ãƒ§ãƒ³ã®ã‚«ã‚¦ãƒ³ãƒˆ
	void MotionCount(Motion& _motion);

	// æ•µã®ãƒˆãƒ©ãƒ³ã‚¹ãƒ•ã‚©ãƒ¼ãƒ ã‚’motion_.transformã«ã‚»ãƒƒãƒˆ
	void TransformUpdate(Corruptor* _pEnemy);

	std::string stateName_;
	Corruptor* pCorruptor_ = nullptr;

	Motion motion_;

};



============================================================
File Path: project/application/objects/enemy/behaviorState/normalEnemyState/EnemyBehaviorAttack.cpp
============================================================
#include "EnemyBehaviorAttack.h"

#include <Ease.h>

#include "../../NormalEnemy.h"
#include "EnemyBehaviorMove.h"
#include "EnemyBehaviorHitReact.h"
#include "EnemyBehaviorDead.h"

EnemyBehaviorAttack::EnemyBehaviorAttack(NormalEnemy* _pNormalEnemy) : EnemyBehaviorState("Attack", _pNormalEnemy)
{
	// ãƒ¢ãƒ¼ã‚·ãƒ§ãƒ³ã®åˆæœŸåŒ–
	motion_.count = 0;
	motion_.maxCount = 30; // æ”»æ’ƒãƒ¢ãƒ¼ã‚·ãƒ§ãƒ³ã®ã‚«ã‚¦ãƒ³ãƒˆã‚’è¨­å®š
   
}

void EnemyBehaviorAttack::Initialize()
{
    attackCooldown_ = 10;
}

void EnemyBehaviorAttack::Update()
{
	// æ•µã®ãƒˆãƒ©ãƒ³ã‚¹ãƒ•ã‚©ãƒ¼ãƒ ã‚’motion_.transformã«ã‚»ãƒƒãƒˆ
	TransformUpdate(pNormalEnemy_);

    // æºœã‚
    if (motion_.isActive)
    {
        // ãƒ¢ãƒ¼ã‚·ãƒ§ãƒ³ã‚«ã‚¦ãƒ³ãƒˆã‚’æ›´æ–°
        MotionCount(motion_);

        if (motion_.count <= 20)
        {
            float t = float(motion_.count) / 20.0f; // 0ã€œ1
            float ease = (t <= 0.5f)
                ? Ease::OutSine(t * 2.0f)               // 0ã€œ0.5  â†’ ç¸®å°
                : Ease::OutSine((1.0f - t) * 2.0f);     // 0.5ã€œ1  â†’ å…ƒã«æˆ»ã™

            float scaleValue = 1.0f - ease * 0.3f;
            motion_.transform.scale = Vector3(scaleValue, scaleValue, scaleValue);
			pNormalEnemy_->SetObjectScale(motion_.transform.scale);

            float shake = ((motion_.count % 2 == 0) ? 1 : -1) * 0.05f;
			pNormalEnemy_->SetObjectPosition(motion_.transform.position + Vector3(shake, 0, shake));
            
        }
        // æ”»æ’ƒ
        else
        {
            // æ”»æ’ƒãƒ•ãƒ©ã‚°ã‚’ãƒªã‚»ãƒƒãƒˆ
            isAttack_ = false;

            // å›žè»¢ã—ãªãŒã‚‰å¼¾ã‚’é£›ã°ã™
            if (motion_.count == 21)
            {
                // æ”»æ’ƒãƒ•ãƒ©ã‚°ã‚’ç«‹ã¦ã‚‹
                isAttack_ = true;
            }

            // Yè»¸å›žè»¢
            motion_.transform.rotation.y += 0.3f;
			pNormalEnemy_->SetRotation(motion_.transform.rotation);

        }
    }

	if (pNormalEnemy_->GetHP() <= 0)
	{
		// HPãŒ0ä»¥ä¸‹ãªã‚‰ã€æ­»äº¡ãƒ¢ãƒ¼ã‚·ãƒ§ãƒ³ã«åˆ‡ã‚Šæ›¿ãˆ
		pNormalEnemy_->ChangeBehaviorState(std::make_unique<EnemyBehaviorDead>(pNormalEnemy_));
        return;
	} 
    else if (pNormalEnemy_->IsHit())
	{
		// ãƒ’ãƒƒãƒˆãƒ•ãƒ©ã‚°ã‚’ãƒªã‚»ãƒƒãƒˆ
		pNormalEnemy_->SetIsHit(false);
        // ç„¡æ•µåŒ–
        pNormalEnemy_->SetIsInvincible(true);
		// ãƒ’ãƒƒãƒˆã—ãŸã‚‰ã€ãƒ’ãƒƒãƒˆãƒªã‚¢ã‚¯ã‚·ãƒ§ãƒ³ãƒ¢ãƒ¼ã‚·ãƒ§ãƒ³ã«åˆ‡ã‚Šæ›¿ãˆ
		pNormalEnemy_->ChangeBehaviorState(std::make_unique<EnemyBehaviorHitReact>(pNormalEnemy_));
		return;
	}
    else if (!pNormalEnemy_->IsFarFromPlayer())
	{
		// ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã¨ã®è·é›¢ãŒä¸€å®šä»¥ä¸Šã®å ´åˆã€ç§»å‹•ãƒ¢ãƒ¼ã‚·ãƒ§ãƒ³ã«åˆ‡ã‚Šæ›¿ãˆ
		pNormalEnemy_->ChangeBehaviorState(std::make_unique<EnemyBehaviorMove>(pNormalEnemy_));
        return;
	}
    else if(!motion_.isActive && motion_.count >= motion_.maxCount)
    {
        // ã‚¹ãƒ†ãƒ¼ãƒˆãŒåˆ‡ã‚Šæ›¿ã‚ã‚‰ãªã‹ã£ãŸã‚‰ã‚‚ã†ä¸€åº¦
		ResetMotion();

    }

    // ã‚¯ãƒ¼ãƒ«ãƒ€ã‚¦ãƒ³ã‚’æ¸›å°‘
    attackCooldown_--;

    // ä¸€å®šé–“éš”ã§å¼¾ã‚’ç™ºå°„
    if (attackCooldown_ <= 0)
    {
        // æ”»æ’ƒãƒ¢ãƒ¼ã‚·ãƒ§ãƒ³ã‚’é–‹å§‹
        motion_.isActive = true;
        attackCooldown_ = 60 * 3;
    }

	// ãƒ•ãƒ©ã‚°ãŒç«‹ã£ã¦ã„ã‚‹å ´åˆã€æ”»æ’ƒã‚’å®Ÿè¡Œ
    if (isAttack_)
    {
        pNormalEnemy_->Attack();
    }

}

void EnemyBehaviorAttack::ResetMotion()
{
    // ãƒ¢ãƒ¼ã‚·ãƒ§ãƒ³ã®åˆæœŸåŒ–
    motion_.count = 0;
    motion_.maxCount = 30; // æ”»æ’ƒãƒ¢ãƒ¼ã‚·ãƒ§ãƒ³ã®ã‚«ã‚¦ãƒ³ãƒˆã‚’è¨­å®š
}


============================================================
File Path: project/application/objects/enemy/behaviorState/normalEnemyState/EnemyBehaviorAttack.h
============================================================
#pragma once

#include "EnemyBehaviorState.h"

/// <summary>
/// é€šå¸¸æ•µã®æ”»æ’ƒçŠ¶æ…‹
/// </summary>
class EnemyBehaviorAttack : public EnemyBehaviorState
{
public:

	/// <summary>
	/// ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿
	/// </summary>
	/// <param name="_pNormalEnemy">é€šå¸¸æ•µãƒã‚¤ãƒ³ã‚¿</param>
	EnemyBehaviorAttack(NormalEnemy* _pNormalEnemy);
	
	// åˆæœŸåŒ–
	void Initialize() override;
	
	// æ›´æ–°
	void Update() override;

	// ãƒ¢ãƒ¼ã‚·ãƒ§ãƒ³ã®ãƒªã‚»ãƒƒãƒˆ
	void ResetMotion() override;


private:

	// æ”»æ’ƒãƒ•ãƒ©ã‚°
	bool isAttack_ = false;
	// æ”»æ’ƒã‚¯ãƒ¼ãƒ«ã‚¿ã‚¤ãƒ 
	int attackCooldown_ = 0;

};



============================================================
File Path: project/application/objects/enemy/behaviorState/normalEnemyState/EnemyBehaviorDead.cpp
============================================================
#include "EnemyBehaviorDead.h"

#include <Ease.h>

#include "../../NormalEnemy.h"

EnemyBehaviorDead::EnemyBehaviorDead(NormalEnemy* _pNormalEnemy) : EnemyBehaviorState("Dead", _pNormalEnemy)
{
	motion_.isActive = true;
	motion_.count = 0;
	motion_.maxCount = 30; // ç§»å‹•ãƒ¢ãƒ¼ã‚·ãƒ§ãƒ³ã®ã‚«ã‚¦ãƒ³ãƒˆã‚’è¨­å®š
}

void EnemyBehaviorDead::Initialize()
{
}

void EnemyBehaviorDead::Update()
{
	// æ•µã®ãƒˆãƒ©ãƒ³ã‚¹ãƒ•ã‚©ãƒ¼ãƒ ã‚’motion_.transformã«ã‚»ãƒƒãƒˆ
	TransformUpdate(pNormalEnemy_);

	float t = float(motion_.count) / motion_.maxCount;

	if (motion_.count == 0)
	{
		motion_.transform.scale = Vector3(1.8f, 1.8f, 1.8f); // åˆå›žã ã‘ä¸€æ°—ã«è†¨ã‚‰ã‚€
	}

	// å¾ã€…ã«ç¸®ã‚€æ¼”å‡º(1.8 â†’ 0.0)
	float scale = Lerp(1.8f, 0.0f, Ease::InCubic(t));
	motion_.transform.scale = (Vector3(scale, scale, scale));

	motion_.transform.position.y += Ease::OutQuad(t) * 0.1f;

	motion_.transform.rotation.y += 0.1f;
	motion_.transform.rotation.x += 0.1f;

	pNormalEnemy_->SetObjectPosition(motion_.transform.position);
	pNormalEnemy_->SetObjectRotation(motion_.transform.rotation);
	pNormalEnemy_->SetObjectScale(motion_.transform.scale);


	// ãƒ¢ãƒ¼ã‚·ãƒ§ãƒ³ã‚«ã‚¦ãƒ³ãƒˆã‚’æ›´æ–°
	MotionCount(motion_);

	if (!motion_.isActive)
	{
		// æ­»äº¡ãƒ¢ãƒ¼ã‚·ãƒ§ãƒ³ãŒçµ‚äº†ã—ãŸã‚‰ã€æ•µã‚’å‰Šé™¤
		pNormalEnemy_->SetIsDead(true);

		// ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«
		ParticleEmitter::Emit("petalGroup", motion_.transform.position, 6);
		ParticleEmitter::Emit("rupture", motion_.transform.position, 20);
	}

}

void EnemyBehaviorDead::ResetMotion()
{
}


============================================================
File Path: project/application/objects/enemy/behaviorState/normalEnemyState/EnemyBehaviorDead.h
============================================================
#pragma once

#include "EnemyBehaviorState.h"

/// <summary>
/// æ•µã®è¡Œå‹•ã‚¹ãƒ†ãƒ¼ãƒˆï¼šæ­»äº¡
/// </summary>
class EnemyBehaviorDead : public EnemyBehaviorState
{
public:

	/// <summary>
	/// ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿
	/// </summary>
	/// <param name="_pNormalEnemy">é€šå¸¸æ•µãƒã‚¤ãƒ³ã‚¿</param>
	EnemyBehaviorDead(NormalEnemy* _pNormalEnemy);
	
	// åˆæœŸåŒ–
	void Initialize() override;
	
	// æ›´æ–°
	void Update() override;

	// ãƒ¢ãƒ¼ã‚·ãƒ§ãƒ³ã®ãƒªã‚»ãƒƒãƒˆ
	void ResetMotion() override;

};



============================================================
File Path: project/application/objects/enemy/behaviorState/normalEnemyState/EnemyBehaviorHitReact.cpp
============================================================
#include "EnemyBehaviorHitReact.h"

#include <Ease.h>

#include "../../NormalEnemy.h"
#include "EnemyBehaviorMove.h"
#include "EnemyBehaviorDead.h"

EnemyBehaviorHitReact::EnemyBehaviorHitReact(NormalEnemy* _pNormalEnemy) : EnemyBehaviorState("Hit", _pNormalEnemy)
{
	motion_.isActive = true;
	motion_.count = 0;
	motion_.maxCount = 30; // ç§»å‹•ãƒ¢ãƒ¼ã‚·ãƒ§ãƒ³ã®ã‚«ã‚¦ãƒ³ãƒˆã‚’è¨­å®š
}

void EnemyBehaviorHitReact::Initialize()
{
}

void EnemyBehaviorHitReact::Update()
{
	// æ•µã®ãƒˆãƒ©ãƒ³ã‚¹ãƒ•ã‚©ãƒ¼ãƒ ã‚’motion_.transformã«ã‚»ãƒƒãƒˆ
	TransformUpdate(pNormalEnemy_);

	Vector3 shakeOffset =
	{
	((motion_.count % 2 == 0) ? 1.0f : -1.0f) * 0.1f,
	0.0f, // Yè»¸ã¯æºã‚‰ã•ãªã„
	((motion_.count % 3 == 0) ? 1.0f : -1.0f) * 0.1f
	};

	Vector3 originPos = pNormalEnemy_->GetPosition();

	pNormalEnemy_->SetObjectPosition(originPos + shakeOffset);

	// ãƒ¢ãƒ¼ã‚·ãƒ§ãƒ³ã‚«ã‚¦ãƒ³ãƒˆã‚’æ›´æ–°
	MotionCount(motion_);

	if (!motion_.isActive)
	{
		if (pNormalEnemy_->GetHP() <= 0)
		{
			// HPãŒ0ä»¥ä¸‹ãªã‚‰ã€æ­»äº¡ãƒ¢ãƒ¼ã‚·ãƒ§ãƒ³ã«åˆ‡ã‚Šæ›¿ãˆ
			pNormalEnemy_->ChangeBehaviorState(std::make_unique<EnemyBehaviorDead>(pNormalEnemy_));
			return;
		} 
		else
		{
			// ç„¡æ•µçŠ¶æ…‹ã‚’è§£é™¤
			pNormalEnemy_->SetIsInvincible(false);

			// ãƒ’ãƒƒãƒˆãƒªã‚¢ã‚¯ã‚·ãƒ§ãƒ³ãƒ¢ãƒ¼ã‚·ãƒ§ãƒ³ãŒçµ‚äº†ã—ãŸã‚‰ã€ç§»å‹•ãƒ¢ãƒ¼ã‚·ãƒ§ãƒ³ã«åˆ‡ã‚Šæ›¿ãˆ
			pNormalEnemy_->ChangeBehaviorState(std::make_unique<EnemyBehaviorMove>(pNormalEnemy_));
		}
	}

}

void EnemyBehaviorHitReact::ResetMotion()
{
}


============================================================
File Path: project/application/objects/enemy/behaviorState/normalEnemyState/EnemyBehaviorHitReact.h
============================================================
#pragma once

#include "EnemyBehaviorState.h"

/// <summary>
/// è¢«å¼¾ãƒªã‚¢ã‚¯ã‚·ãƒ§ãƒ³
/// </summary>
class EnemyBehaviorHitReact : public EnemyBehaviorState
{
public:

	/// <summary>
	/// ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿
	/// </summary>
	/// <param name="_pNormalEnemy">é€šå¸¸æ•µãƒã‚¤ãƒ³ã‚¿</param>
	EnemyBehaviorHitReact(NormalEnemy* _pNormalEnemy);
	
	// åˆæœŸåŒ–
	void Initialize() override;
	
	// æ›´æ–°
	void Update() override;

	// ãƒ¢ãƒ¼ã‚·ãƒ§ãƒ³ã®ãƒªã‚»ãƒƒãƒˆ
	void ResetMotion() override;

};



============================================================
File Path: project/application/objects/enemy/behaviorState/normalEnemyState/EnemyBehaviorMove.cpp
============================================================
#include "EnemyBehaviorMove.h"

#include <Ease.h>

#include "../../NormalEnemy.h"
#include "EnemyBehaviorAttack.h"
#include "EnemyBehaviorHitReact.h"

EnemyBehaviorMove::EnemyBehaviorMove(NormalEnemy* _pNormalEnemy) : EnemyBehaviorState("Move", _pNormalEnemy)
{
	motion_.isActive = true;
	motion_.count = 0;
	motion_.maxCount = 30; // ç§»å‹•ãƒ¢ãƒ¼ã‚·ãƒ§ãƒ³ã®ã‚«ã‚¦ãƒ³ãƒˆã‚’è¨­å®š
}

void EnemyBehaviorMove::Initialize()
{
}

void EnemyBehaviorMove::Update()
{
	// æ•µã®ãƒˆãƒ©ãƒ³ã‚¹ãƒ•ã‚©ãƒ¼ãƒ ã‚’motion_.transformã«ã‚»ãƒƒãƒˆ
	TransformUpdate(pNormalEnemy_);

	// å‹•ãå‰ã«åˆ‡ã‚Šæ›¿ãˆå‡¦ç†
	if (pNormalEnemy_->IsHit())
	{
		// ãƒ’ãƒƒãƒˆãƒ•ãƒ©ã‚°ã‚’ãƒªã‚»ãƒƒãƒˆ
		pNormalEnemy_->SetIsHit(false);

		// ç„¡æ•µåŒ–
		pNormalEnemy_->SetIsInvincible(true);

		// ãƒ’ãƒƒãƒˆã—ãŸã‚‰ã€ãƒ’ãƒƒãƒˆãƒªã‚¢ã‚¯ã‚·ãƒ§ãƒ³ãƒ¢ãƒ¼ã‚·ãƒ§ãƒ³ã«åˆ‡ã‚Šæ›¿ãˆ
		pNormalEnemy_->ChangeBehaviorState(std::make_unique<EnemyBehaviorHitReact>(pNormalEnemy_));
		return;
	}
	else if (pNormalEnemy_->IsFarFromPlayer() && !pNormalEnemy_->IsHitVignetteTrap())
	{
		// ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã¨ã®è·é›¢ãŒä¸€å®šä»¥ä¸‹ã®å ´åˆã€æ”»æ’ƒãƒ¢ãƒ¼ã‚·ãƒ§ãƒ³ã«åˆ‡ã‚Šæ›¿ãˆ
		pNormalEnemy_->ChangeBehaviorState(std::make_unique<EnemyBehaviorAttack>(pNormalEnemy_));
		return;
	}
	else
	{
		// ã‚¹ãƒ†ãƒ¼ãƒˆãŒåˆ‡ã‚Šæ›¿ã‚ã‚‰ãªã‹ã£ãŸã‚‰ã‚‚ã†ä¸€åº¦
		ResetMotion();
	}

	// ã‚¤ãƒ¼ã‚¸ãƒ³ã‚°é€²è¡Œåº¦ï¼ˆ0ã€œ1ï¼‰
	float t = float(motion_.count) / motion_.maxCount;

	// ãƒãƒ¨ãƒãƒ¨æ‹¡å¤§ç¸®å°ï¼ˆXãƒ»Yä¸¡æ–¹ï¼‰
	float scaleWaveX = 1.0f + std::sin(t * std::numbers::pi_v<float>) * 0.2f;
	float scaleWaveY = 1.0f + std::cos(t * std::numbers::pi_v<float>) * 0.2f;

	// ã‚¹ã‚±ãƒ¼ãƒ«ã‚’æ›´æ–°ï¼ˆXãƒ»Yä¸¡æ–¹ãƒãƒ¨ãƒãƒ¨ï¼‰
	motion_.transform.scale = Vector3(scaleWaveX, scaleWaveY, 1.0f);

	// ã‚¹ã‚±ãƒ¼ãƒ«ã‚’ã‚»ãƒƒãƒˆ
	pNormalEnemy_->SetScale(motion_.transform.scale);

	// ãƒ¢ãƒ¼ã‚·ãƒ§ãƒ³ã‚«ã‚¦ãƒ³ãƒˆã‚’æ›´æ–°
	MotionCount(motion_);

	// ç§»å‹•
	if (!pNormalEnemy_->IsHitVignetteTrap())
	{
		pNormalEnemy_->Move();
	}
}

void EnemyBehaviorMove::ResetMotion()
{
	motion_.isActive = true;
	motion_.count = 0;
	motion_.maxCount = 30; // ç§»å‹•ãƒ¢ãƒ¼ã‚·ãƒ§ãƒ³ã®ã‚«ã‚¦ãƒ³ãƒˆã‚’è¨­å®š
}


============================================================
File Path: project/application/objects/enemy/behaviorState/normalEnemyState/EnemyBehaviorMove.h
============================================================
#pragma once

#include "EnemyBehaviorState.h"

/// <summary>
/// æ•µã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼ã®ç§»å‹•çŠ¶æ…‹ã‚’ç®¡ç†ã™ã‚‹ã‚¯ãƒ©ã‚¹
/// </summary>
class EnemyBehaviorMove : public EnemyBehaviorState
{
public:

	/// <summary>
	/// ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿
	/// </summary>
	/// <param name="_pNormalEnemy">é€šå¸¸æ•µãƒã‚¤ãƒ³ã‚¿</param>
	EnemyBehaviorMove(NormalEnemy* _pNormalEnemy);
	
	// åˆæœŸåŒ–
	void Initialize() override;
	
	// æ›´æ–°
	void Update() override;

	// ãƒ¢ãƒ¼ã‚·ãƒ§ãƒ³ã®ãƒªã‚»ãƒƒãƒˆ
	void ResetMotion() override;

};



============================================================
File Path: project/application/objects/enemy/behaviorState/normalEnemyState/EnemyBehaviorSpawn.cpp
============================================================
#include "EnemyBehaviorSpawn.h"

#include <Ease.h>

#include "../../NormalEnemy.h"
#include "EnemyBehaviorMove.h"

EnemyBehaviorSpawn::EnemyBehaviorSpawn(NormalEnemy* _pNormalEnemy) : EnemyBehaviorState("Spawn", _pNormalEnemy)
{
	// ãƒ¢ãƒ¼ã‚·ãƒ§ãƒ³ã®åˆæœŸåŒ–
	motion_.isActive = true;
	motion_.count = 0;
	motion_.maxCount = 30; // ã‚¹ãƒãƒ¼ãƒ³ãƒ¢ãƒ¼ã‚·ãƒ§ãƒ³ã®ã‚«ã‚¦ãƒ³ãƒˆã‚’è¨­å®š
}

void EnemyBehaviorSpawn::Initialize()
{
}

void EnemyBehaviorSpawn::Update()
{
	// æ•µã®ãƒˆãƒ©ãƒ³ã‚¹ãƒ•ã‚©ãƒ¼ãƒ ã‚’motion_.transformã«ã‚»ãƒƒãƒˆ
	TransformUpdate(pNormalEnemy_);

	// ã‚¤ãƒ¼ã‚¸ãƒ³ã‚°ã®é€²è¡Œåº¦ï¼ˆ0ã€œ1ï¼‰
	float t = float(motion_.count) / motion_.maxCount;
	motion_.transform.scale.x = Ease::OutBack(t);
	motion_.transform.scale.y = Ease::OutBack(t);
	motion_.transform.scale.z = Ease::OutBack(t);
	Vector3 one(1.0f, 1.0f, 1.0f);

	pNormalEnemy_->SetObjectPosition(motion_.transform.position);
	pNormalEnemy_->SetObjectRotation(motion_.transform.rotation);
	pNormalEnemy_->SetObjectScale(one * motion_.transform.scale);

	// ãƒ¢ãƒ¼ã‚·ãƒ§ãƒ³ã‚«ã‚¦ãƒ³ãƒˆã‚’æ›´æ–°
	MotionCount(motion_);

	if (!motion_.isActive)
	{
		// ç„¡æ•µçŠ¶æ…‹ã‚’è§£é™¤
		pNormalEnemy_->SetIsInvincible(false);

		// ã‚¹ãƒãƒ¼ãƒ³ãƒ¢ãƒ¼ã‚·ãƒ§ãƒ³ãŒçµ‚äº†ã—ãŸã‚‰ã€æ¬¡ã®çŠ¶æ…‹ã«ç§»è¡Œ
		pNormalEnemy_->ChangeBehaviorState(std::make_unique<EnemyBehaviorMove>(pNormalEnemy_));
	}
}

void EnemyBehaviorSpawn::ResetMotion()
{
}


============================================================
File Path: project/application/objects/enemy/behaviorState/normalEnemyState/EnemyBehaviorSpawn.h
============================================================
#pragma once

#include "EnemyBehaviorState.h"

/// <summary>
/// æ•µã®å‡ºç¾çŠ¶æ…‹
/// </summary>
class EnemyBehaviorSpawn : public EnemyBehaviorState
{
public:

	/// <summary>
	/// ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿
	/// </summary>
	/// <param name="_pNormalEnemy">é€šå¸¸æ•µãƒã‚¤ãƒ³ã‚¿</param>
	EnemyBehaviorSpawn(NormalEnemy* _pNormalEnemy);
	
	// åˆæœŸåŒ–
	void Initialize() override;
	
	// æ›´æ–°
	void Update() override;

	// ãƒ¢ãƒ¼ã‚·ãƒ§ãƒ³ã®ãƒªã‚»ãƒƒãƒˆ
	void ResetMotion() override;

};



============================================================
File Path: project/application/objects/enemy/behaviorState/normalEnemyState/EnemyBehaviorState.cpp
============================================================
#include "EnemyBehaviorState.h"

#include "../../NormalEnemy.h"

EnemyBehaviorState::~EnemyBehaviorState()
{
}

void EnemyBehaviorState::MotionCount(Motion& _motion)
{
	if (_motion.count < _motion.maxCount)
	{
		_motion.count++;
	}
	else
	{
		// ãƒ¢ãƒ¼ã‚·ãƒ§ãƒ³çµ‚äº† ã‚«ã‚¦ãƒ³ãƒˆãƒªã‚»ãƒƒãƒˆ
		_motion.isActive = false;
		_motion.count = 0;
	}
}

void EnemyBehaviorState::TransformUpdate(NormalEnemy* _pNormalEnemy)
{
	if (_pNormalEnemy)
	{
		motion_.transform.position = _pNormalEnemy->GetPosition();
		motion_.transform.rotation = _pNormalEnemy->GetRotation();
		motion_.transform.scale = _pNormalEnemy->GetScale();
	}
}

============================================================
File Path: project/application/objects/enemy/behaviorState/normalEnemyState/EnemyBehaviorState.h
============================================================
#pragma once

#include <sstream>
#include <Vector3.h>

class NormalEnemy;

/// <summary>
/// æ•µã®è¡Œå‹•ã‚¹ãƒ†ãƒ¼ãƒˆåŸºåº•ã‚¯ãƒ©ã‚¹
/// </summary>
class EnemyBehaviorState
{
public:

	/// <summary>
	/// ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿
	/// </summary>
	/// <param name="_state">ã‚¹ãƒ†ãƒ¼ãƒˆå</param>
	/// <param name="_pNormalEnemy">é€šå¸¸æ•µãƒã‚¤ãƒ³ã‚¿</param>
	EnemyBehaviorState(const std::string& _state, NormalEnemy* _pNormalEnemy) :stateName_(_state), pNormalEnemy_(_pNormalEnemy) {};
	virtual ~EnemyBehaviorState();
	
	// åˆæœŸåŒ–
	virtual void Initialize() = 0;
	
	// æ›´æ–°
	virtual void Update() = 0;

	// ãƒ¢ãƒ¼ã‚·ãƒ§ãƒ³ã®ã‚«ã‚¦ãƒ³ãƒˆç­‰ã‚’ãƒªã‚»ãƒƒãƒˆ
	virtual void ResetMotion() = 0;

protected:

	struct Transform
	{
		Vector3 position = { 0.0f, 0.0f, 0.0f };
		Vector3 rotation = { 0.0f, 0.0f, 0.0f };
		Vector3 scale = { 1.0f, 1.0f, 1.0f };
	};

	struct Motion
	{
		// ãƒ¢ãƒ¼ã‚·ãƒ§ãƒ³ãŒã‚¢ã‚¯ãƒ†ã‚£ãƒ–ã‹ã©ã†ã‹
		bool isActive = false;
		// ã‚«ã‚¦ãƒ³ãƒˆ
		uint32_t count = 0;
		// Maxã‚«ã‚¦ãƒ³ãƒˆ
		uint32_t maxCount = 30;
		// ãƒˆãƒ©ãƒ³ã‚¹ãƒ•ã‚©ãƒ¼ãƒ 
		Transform transform;
	};

	/// <summary>
	/// ãƒ¢ãƒ¼ã‚·ãƒ§ãƒ³ã®ã‚«ã‚¦ãƒ³ãƒˆ
	/// </summary>
	/// <param name="_motion">ãƒ¢ãƒ¼ã‚·ãƒ§ãƒ³æ§‹é€ ä½“</param>
	void MotionCount(Motion& _motion);

	/// <summary>
	/// æ•µã®ãƒˆãƒ©ãƒ³ã‚¹ãƒ•ã‚©ãƒ¼ãƒ ã‚’motion_.transformã«ã‚»ãƒƒãƒˆ
	/// </summary>
	/// <param name="_pEnemy">é€šå¸¸æ•µãƒã‚¤ãƒ³ã‚¿</param>
	void TransformUpdate(NormalEnemy* _pEnemy);

	std::string stateName_;
	NormalEnemy* pNormalEnemy_ = nullptr;

	Motion motion_;

};



============================================================
File Path: project/application/objects/enemy/behaviorState/trapEnemyState/TrapEnemyBehaviorDead.cpp
============================================================
#include "TrapEnemyBehaviorDead.h"

#include <Ease.h>

#include "../../TrapEnemy.h"

TrapEnemyBehaviorDead::TrapEnemyBehaviorDead(TrapEnemy* _pTrapEnemy) : TrapEnemyBehaviorState("Dead", _pTrapEnemy)
{
	motion_.isActive = true;
	motion_.count = 0;
	motion_.maxCount = 30; // ãƒ¢ãƒ¼ã‚·ãƒ§ãƒ³ã®ã‚«ã‚¦ãƒ³ãƒˆã‚’è¨­å®š
}

void TrapEnemyBehaviorDead::Initialize()
{
}

void TrapEnemyBehaviorDead::Update()
{
	// æ•µã®ãƒˆãƒ©ãƒ³ã‚¹ãƒ•ã‚©ãƒ¼ãƒ ã‚’motion_.transformã«ã‚»ãƒƒãƒˆ
	TransformUpdate(pTrapEnemy_);

	float t = float(motion_.count) / motion_.maxCount;

	if (motion_.count == 0)
	{
		motion_.transform.scale = Vector3(1.8f, 1.8f, 1.8f); // åˆå›žã ã‘ä¸€æ°—ã«è†¨ã‚‰ã‚€
	}

	// å¾ã€…ã«ç¸®ã‚€æ¼”å‡º
	float scale = Lerp(1.8f, 0.0f, Ease::InCubic(t));
	motion_.transform.scale = (Vector3(scale, scale, scale));

	motion_.transform.position.y += Ease::OutQuad(t) * 0.1f;

	motion_.transform.rotation.y += 0.1f;
	motion_.transform.rotation.x += 0.1f;

	pTrapEnemy_->SetObjectPosition(motion_.transform.position);
	pTrapEnemy_->SetObjectRotation(motion_.transform.rotation);
	pTrapEnemy_->SetObjectScale(motion_.transform.scale);


	// ãƒ¢ãƒ¼ã‚·ãƒ§ãƒ³ã‚«ã‚¦ãƒ³ãƒˆã‚’æ›´æ–°
	MotionCount(motion_);

	if (!motion_.isActive)
	{
		// æ­»äº¡ãƒ¢ãƒ¼ã‚·ãƒ§ãƒ³ãŒçµ‚äº†ã—ãŸã‚‰ã€æ•µã‚’å‰Šé™¤
		pTrapEnemy_->SetIsDead(true);

		// ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«
		ParticleEmitter::Emit("explosionGroup", motion_.transform.position, 6);
		ParticleEmitter::Emit("rupture", motion_.transform.position, 20);
	}
}

void TrapEnemyBehaviorDead::ResetMotion()
{
}


============================================================
File Path: project/application/objects/enemy/behaviorState/trapEnemyState/TrapEnemyBehaviorSpawn.cpp
============================================================
#include "TrapEnemyBehaviorSpawn.h"

#include <Ease.h>

#include "../../TrapEnemy.h"
#include "TrapEnemyBehaviorMove.h"

TrapEnemyBehaviorSpawn::TrapEnemyBehaviorSpawn(TrapEnemy* _pTrapEnemy) : TrapEnemyBehaviorState("Spawn", _pTrapEnemy)
{
	// ãƒ¢ãƒ¼ã‚·ãƒ§ãƒ³ã®åˆæœŸåŒ–
	motion_.isActive = true;
	motion_.count = 0;
	motion_.maxCount = 30; // ã‚¹ãƒãƒ¼ãƒ³ãƒ¢ãƒ¼ã‚·ãƒ§ãƒ³ã®ã‚«ã‚¦ãƒ³ãƒˆã‚’è¨­å®š
}

void TrapEnemyBehaviorSpawn::Initialize()
{
}

void TrapEnemyBehaviorSpawn::Update()
{
	// æ•µã®ãƒˆãƒ©ãƒ³ã‚¹ãƒ•ã‚©ãƒ¼ãƒ ã‚’motion_.transformã«ã‚»ãƒƒãƒˆ
	TransformUpdate(pTrapEnemy_);

	// ã‚¤ãƒ¼ã‚¸ãƒ³ã‚°ã®é€²è¡Œåº¦
	float t = float(motion_.count) / motion_.maxCount;
	motion_.transform.scale.x = Ease::OutBack(t);
	motion_.transform.scale.y = Ease::OutBack(t);
	motion_.transform.scale.z = Ease::OutBack(t);
	Vector3 one(1.0f, 1.0f, 1.0f);

	pTrapEnemy_->SetObjectPosition(motion_.transform.position);
	pTrapEnemy_->SetObjectRotation(motion_.transform.rotation);
	pTrapEnemy_->SetObjectScale(one * motion_.transform.scale);

	// ãƒ¢ãƒ¼ã‚·ãƒ§ãƒ³ã‚«ã‚¦ãƒ³ãƒˆã‚’æ›´æ–°
	MotionCount(motion_);

	if (!motion_.isActive)
	{
		// ç„¡æ•µçŠ¶æ…‹ã‚’è§£é™¤
		pTrapEnemy_->SetIsInvincible(false);

		// ã‚¹ãƒãƒ¼ãƒ³ãƒ¢ãƒ¼ã‚·ãƒ§ãƒ³ãŒçµ‚äº†ã—ãŸã‚‰ã€æ¬¡ã®çŠ¶æ…‹ã«ç§»è¡Œ
		pTrapEnemy_->ChangeBehaviorState(std::make_unique<TrapEnemyBehaviorMove>(pTrapEnemy_));
	}
}

void TrapEnemyBehaviorSpawn::ResetMotion()
{
}


============================================================
File Path: project/application/objects/enemy/behaviorState/trapEnemyState/TrapEnemyBehaviorState.h
============================================================
#pragma once

#include <sstream>
#include <Vector3.h>

// å‰æ–¹å®£è¨€
class TrapEnemy;

/// <summary>
/// ç½ åž‹æ•µã®è¡Œå‹•ã‚¹ãƒ†ãƒ¼ãƒˆåŸºåº•ã‚¯ãƒ©ã‚¹
/// è¡Œå‹•ã‚¹ãƒ†ãƒ¼ãƒˆã¯ä»¥ä¸‹ã®5ã¤
/// ãƒ»å‡ºç¾(Spawn)
/// ãƒ»ç§»å‹•(Move)
/// ãƒ»ç½ è¨­ç½®(SetTrap)
/// ãƒ»è¢«å¼¾(HitReact)
/// ãƒ»æ­»äº¡(Dead)
/// </summary>
class TrapEnemyBehaviorState
{
public:
	
	/// <summary>
	/// ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿
	/// </summary>
	/// <param name="_name">ã‚¹ãƒ†ãƒ¼ãƒˆå</param>
	/// <param name="_trapEnemy">ç½ åž‹æ•µã®ãƒã‚¤ãƒ³ã‚¿</param>
	TrapEnemyBehaviorState(const std::string& _name, TrapEnemy* _trapEnemy) : stateName_(_name), pTrapEnemy_(_trapEnemy) {};
	
	virtual ~TrapEnemyBehaviorState();
	
	// åˆæœŸåŒ–
	virtual void Initialize() = 0;
	
	// æ›´æ–°
	virtual void Update() = 0;
	
	// ãƒ¢ãƒ¼ã‚·ãƒ§ãƒ³ã®ãƒªã‚»ãƒƒãƒˆ
	virtual void ResetMotion() = 0;

protected:

	struct Transform
	{
		Vector3 position = { 0.0f, 0.0f, 0.0f };
		Vector3 rotation = { 0.0f, 0.0f, 0.0f };
		Vector3 scale = { 1.0f, 1.0f, 1.0f };
	};

	struct Motion
	{
		// ãƒ¢ãƒ¼ã‚·ãƒ§ãƒ³ãŒã‚¢ã‚¯ãƒ†ã‚£ãƒ–ã‹ã©ã†ã‹
		bool isActive = false;
		// ã‚«ã‚¦ãƒ³ãƒˆ
		uint32_t count = 0;
		// Maxã‚«ã‚¦ãƒ³ãƒˆ
		uint32_t maxCount = 30;
		// ãƒˆãƒ©ãƒ³ã‚¹ãƒ•ã‚©ãƒ¼ãƒ 
		Transform transform;
	};

	// ãƒ¢ãƒ¼ã‚·ãƒ§ãƒ³ã®ã‚«ã‚¦ãƒ³ãƒˆ
	void MotionCount(Motion& _motion);

	// æ•µã®ãƒˆãƒ©ãƒ³ã‚¹ãƒ•ã‚©ãƒ¼ãƒ ã‚’motion_.transformã«ã‚»ãƒƒãƒˆ
	void TransformUpdate(TrapEnemy* _pEnemy);

	std::string stateName_;
	TrapEnemy* pTrapEnemy_ = nullptr;

	Motion motion_;

};



============================================================
File Path: project/application/scene/ClearScene.cpp
============================================================
#include "ClearScene.h"

void ClearScene::Initialize()
{
	// å¿…ãšå…ˆé ­ã§ã‚«ãƒ¡ãƒ©ã‚’å…¨ã‚¯ãƒªã‚¢
	cameraManager.ClearAllCameras();

	camera_ = std::make_shared<Camera>();
	camera_->SetRotate({ 0.3f,0.0f,0.0f });
	camera_->SetPosition({ 0.0f,4.0f,-40.0f });
	Object3dCommon::GetInstance()->SetDefaultCamera(camera_);
	cameraManager.AddCamera(camera_);
	cameraManager.SetActiveCamera(0);

	cameraPosition_ = { 0.0f,12.0f,-33.0f };
	cameraRotate_ = { 0.3f,0.0f,0.0f };
	camera_->SetPosition(cameraPosition_);
	camera_->SetRotate(cameraRotate_);

	//ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼
	pPlayer_ = std::make_unique<Player>();
	pPlayer_->Initialize();

	// ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰
	pField_ = std::make_unique<Field>();
	pField_->Initialize();

	// ã‚¹ãƒ—ãƒ©ã‚¤ãƒˆ
	for (uint32_t i = 0; i < spriteNum_; ++i)
	{
		auto sprite = std::make_unique<Sprite>();
		
		if (i == 0)
		{
			sprite->Initialize("clearLogo.png", { -10,0 }, { 1.0f,1.0f,1.0f,1.0f }, { 0,0 });
		} 
		else if (i == 1)
		{
			sprite->Initialize("gameOverReTry.png", { 0,620 }, { 1.0f,1.0f,1.0f,1.0f }, { 0,0 });
		} 
		else if (i == 2)
		{
			sprite->Initialize("gameOverToTitle.png", { -70,620 }, { 1.0f,1.0f,1.0f,1.0f }, { 0,0 });
		}
		
		sprites_.push_back(std::move(sprite));
	}

	// ã‚·ãƒ¼ãƒ³é–‹å§‹æ™‚ã«ãƒ•ã‚§ãƒ¼ãƒ‰ã‚¤ãƒ³
	transition_ = std::make_unique<BlockRiseTransition>(BlockRiseTransition::Mode::DropOnly);
	isTransitioning_ = true;
	transition_->Start(nullptr);

}

void ClearScene::Finalize()
{
	pPlayer_->Finalize();
	pField_->Finalize();

	cameraManager.RemoveCamera(0);
}

void ClearScene::Update()
{
	// ãƒˆãƒ©ãƒ³ã‚¸ã‚·ãƒ§ãƒ³æ›´æ–°
	if (isTransitioning_ && transition_)
	{
		transition_->Update();

		// ãƒˆãƒ©ãƒ³ã‚¸ã‚·ãƒ§ãƒ³çµ‚äº†åˆ¤å®š
		if (transition_->IsFinished())
		{
			transition_.reset();
			isTransitioning_ = false;
		}

	}

	// ã‚«ãƒ¡ãƒ©æ›´æ–°
	camera_->Update();
	camera_->SetPosition(cameraPosition_);
	camera_->SetRotate(cameraRotate_);

	// ã‚¹ãƒ—ãƒ©ã‚¤ãƒˆæ›´æ–°
	for (auto& sprite : sprites_)
	{
		sprite->Update();
	}

	// ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼æ›´æ–°
	pPlayer_->ClearSceneUpdate();

	// ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰æ›´æ–°
	pField_->Update();

	// ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«
	ParticleEmitter::Emit("goal", particlePosition_, 1);
	ParticleEmitter::Emit("petalGroup", petalPosition_, 1);


#ifdef USE_IMGUI

	// é€æ˜Žåº¦ã®æ›´æ–°

	ImGui::Begin("ClearScene");


	ImGui::SliderFloat3("cameraPosition", &cameraPosition_.x, -80.0f, 20.0f);
	ImGui::SliderFloat3("cameraRotate", &cameraRotate_.x, -3.14f, 3.14f);

	ImGui::SliderFloat3("particlePosition", &petalPosition_.x, -50.0f, 50.0f);

	ImGui::End();

#endif // USE_IMGUI


	if (Input::GetInstance()->TriggerKey(DIK_RETURN))
	{
		// ãƒˆãƒ©ãƒ³ã‚¸ã‚·ãƒ§ãƒ³é–‹å§‹
		transition_ = std::make_unique<BlockRiseTransition>();
		isTransitioning_ = true;
		transition_->Start([]
			{
				// ã‚·ãƒ¼ãƒ³åˆ‡ã‚Šæ›¿ãˆ
				SceneManager::GetInstance()->ChangeScene("TITLE");
			});
	}

	if (Input::GetInstance()->TriggerKey(DIK_R))
	{
		// ãƒˆãƒ©ãƒ³ã‚¸ã‚·ãƒ§ãƒ³é–‹å§‹
		transition_ = std::make_unique<BlockRiseTransition>();
		isTransitioning_ = true;
		transition_->Start([]
			{
				// ã‚·ãƒ¼ãƒ³åˆ‡ã‚Šæ›¿ãˆ
				SceneManager::GetInstance()->ChangeScene("GAMEPLAY");
			});
	}
}

void ClearScene::Draw()
{
	// æç”»å‰å‡¦ç†(Object)
	Object3dCommon::GetInstance()->CommonDrawSetting();

	// ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼æç”»
	pPlayer_->Draw();

	// ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰æç”»
	pField_->Draw();

	// æç”»å‰å‡¦ç†(Sprite)
	SpriteCommon::GetInstance()->CommonDrawSetting();

	for (auto& sprite : sprites_)
	{
		sprite->Draw();
	}

	// ãƒˆãƒ©ãƒ³ã‚¸ã‚·ãƒ§ãƒ³æç”»
	if (isTransitioning_ && transition_)
	{
		transition_->Draw();
	}

}


============================================================
File Path: project/application/scene/ClearScene.h
============================================================
#pragma once

#include <Framework.h>
#include <vector>
#include <memory>
#include <MyMath.h>
#include <Object3d.h>
#include <Vector3.h>

#include "../../gameEngine/baseScene/BaseScene.h"
#include "../../gameEngine/transition/BlockRiseTransition.h"
#include "../../gameEngine/particle/ParticleEmitter.h"
#include "../objects/player/Player.h"
#include "../objects/field/Field.h"

/// <summary>
/// ã‚¯ãƒªã‚¢ã‚·ãƒ¼ãƒ³
/// ã‚¯ãƒªã‚¢è¡¨ç¤ºã€ã‚¨ãƒ•ã‚§ã‚¯ãƒˆã€BGMå†ç”Ÿã€ã‚·ãƒ¼ãƒ³é·ç§»
/// </summary>
class ClearScene : public BaseScene
{
public:

	// åˆæœŸåŒ–
	void Initialize() override;

	// çµ‚äº†
	void Finalize() override;

	// æ›´æ–°
	void Update() override;

	// æç”»
	void Draw() override;

private:

	CameraManager& cameraManager = CameraManager::GetInstance();
	std::shared_ptr<Camera> camera_ = std::make_shared<Camera>();
	Vector3 cameraPosition_{};
	Vector3 cameraRotate_{};

	// 2Dã‚¹ãƒ—ãƒ©ã‚¤ãƒˆ
	std::vector<std::unique_ptr<Sprite>>sprites_ = {};
	// æç”»ã™ã‚‹ã‚¹ãƒ—ãƒ©ã‚¤ãƒˆã®æ•°
	uint32_t spriteNum_ = 3;

	// é·ç§»
	std::unique_ptr<BlockRiseTransition> transition_ = nullptr;
	bool isTransitioning_ = false;

	// ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼
	std::unique_ptr<Player> pPlayer_ = nullptr;

	// ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰
	std::unique_ptr<Field> pField_ = nullptr;

	// ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ä½ç½®
	Vector3 particlePosition_ = { 0.0f,0.0f,-3.5f };
	Vector3 petalPosition_ = { 0.0f,12.0f,-18.0f };

};



============================================================
File Path: project/application/scene/GameOverScene.cpp
============================================================
#include "GameOverScene.h"

#include <Ease.h>

void GameOverScene::Initialize()
{
	// å¿…ãšå…ˆé ­ã§ã‚«ãƒ¡ãƒ©ã‚’å…¨ã‚¯ãƒªã‚¢
	cameraManager.ClearAllCameras();

	camera_ = std::make_shared<Camera>();
	camera_->SetRotate({ 0.3f,0.0f,0.0f });
	camera_->SetPosition({ 0.0f,4.0f,-40.0f });
	Object3dCommon::GetInstance()->SetDefaultCamera(camera_);
	cameraManager.AddCamera(camera_);
	cameraManager.SetActiveCamera(0);

	cameraPosition_ = { 0.0f,20.0f,-50.0f };
	cameraRotate_ = { 0.3f,0.0f,0.0f };
	camera_->SetPosition(cameraPosition_);
	camera_->SetRotate(cameraRotate_);

	for (uint32_t i = 0; i < spriteNum_; ++i)
	{
		auto sprite = std::make_unique<Sprite>();
		
		if (i == 0)
		{
			sprite->Initialize("gameOverLogo.png", { -10,0 }, {1.0f,1.0f,1.0f,1.0f}, { 0,0 });
		}
		else if (i == 1)
		{
			sprite->Initialize("gameOverReTry.png", { 0,620 }, { 1.0f,1.0f,1.0f,1.0f }, { 0,0 });
		}
		else if (i == 2)
		{
			sprite->Initialize("gameOverToTitle.png", { -70,620 }, { 1.0f,1.0f,1.0f,1.0f }, { 0,0 });
		}

		sprites_.push_back(std::move(sprite));
	}


	// è¡çªåˆ¤å®š
	colliderManager_ = ColliderManager::GetInstance();
	colliderManager_->Initialize();

	// ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼
	pPlayer_ = std::make_unique<Player>();
	pPlayer_->Initialize();
	pPlayer_->SetPosition({ 0.0f,0.0f,0.0f });
	pPlayer_->SetIsCanMove(false); // ç§»å‹•ä¸å¯

	// ã‚¨ãƒãƒŸãƒ¼
	pEnemyManager_ = std::make_unique<EnemyManager>();
	pEnemyManager_->GameOverEnemyInit();

	// ã‚·ãƒ¼ãƒ³é–‹å§‹æ™‚ã«ãƒ•ã‚§ãƒ¼ãƒ‰ã‚¤ãƒ³
	transition_ = std::make_unique<BlockRiseTransition>(BlockRiseTransition::Mode::DropOnly);
	isTransitioning_ = true;
	transition_->Start(nullptr);
}

void GameOverScene::Finalize()
{
	pPlayer_->Finalize();
	pEnemyManager_->Finalize();

	cameraManager.RemoveCamera(0);
}

void GameOverScene::Update()
{
	// ãƒˆãƒ©ãƒ³ã‚¸ã‚·ãƒ§ãƒ³æ›´æ–°
	if (isTransitioning_ && transition_)
	{
		transition_->Update();

		// ãƒˆãƒ©ãƒ³ã‚¸ã‚·ãƒ§ãƒ³çµ‚äº†åˆ¤å®š
		if (transition_->IsFinished())
		{
			transition_.reset();
			isTransitioning_ = false;
		}

	}

	camera_->Update();
	camera_->SetPosition(cameraPosition_);
	camera_->SetRotate(cameraRotate_);	

	for (auto& sprite : sprites_)
	{
		sprite->Update();

	}

	// å½“ãŸã‚Šåˆ¤å®šãƒã‚§ãƒƒã‚¯
	colliderManager_->CheckAllCollision();

	// ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®æ›´æ–°
	pPlayer_->Update();
	// ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®ä½ç½®ã‚’ã‚¨ãƒãƒŸãƒ¼ãƒžãƒãƒ¼ã‚¸ãƒ£ãƒ¼ã«ã‚»ãƒƒãƒˆ
	pEnemyManager_->SetPlayerPosition(pPlayer_->GetPosition());

	// ã‚«ãƒ¡ãƒ©ã®æ›´æ–°(ã‚·ã‚§ã‚¤ã‚¯ã€è¿½å°¾ã€å¼•ã)
	if (!pPlayer_->IsDead())
	{
		camera_->SetRotate(cameraRotate_);
		camera_->SetPosition(cameraPosition_);
		CameraShake();
	}

	// ã‚¨ãƒãƒŸãƒ¼ã®æ›´æ–°
	pEnemyManager_->GameOverEnemyUpdate();



#ifdef USE_IMGUI

	// é€æ˜Žåº¦ã®æ›´æ–°

	ImGui::Begin("GameOverScene");

	//ImGui::SliderFloat4("transparent", &color_.x, 0.0f, 1.0f);

	ImGui::SliderFloat3("cameraPosition", &cameraPosition_.x, -50.0f, 20.0f);
	ImGui::SliderFloat3("cameraRotate", &cameraRotate_.x, -3.14f, 3.14f);

	
	ImGui::End();

	pEnemyManager_->ImGuiDraw();

#endif // USE_IMGUI


	if (Input::GetInstance()->TriggerKey(DIK_RETURN))
	{
		// ãƒˆãƒ©ãƒ³ã‚¸ã‚·ãƒ§ãƒ³é–‹å§‹
		transition_ = std::make_unique<BlockRiseTransition>();
		isTransitioning_ = true;
		transition_->Start([]
			{
				// ã‚·ãƒ¼ãƒ³åˆ‡ã‚Šæ›¿ãˆ
				SceneManager::GetInstance()->ChangeScene("TITLE");
			});
	}

	if( Input::GetInstance()->TriggerKey(DIK_R))
	{
		// ãƒˆãƒ©ãƒ³ã‚¸ã‚·ãƒ§ãƒ³é–‹å§‹
		transition_ = std::make_unique<BlockRiseTransition>();
		isTransitioning_ = true;
		transition_->Start([]
			{
				// ã‚·ãƒ¼ãƒ³åˆ‡ã‚Šæ›¿ãˆ
				SceneManager::GetInstance()->ChangeScene("GAMEPLAY");
			});
	}

}

void GameOverScene::Draw()
{
	// æç”»å‰å‡¦ç†(Object)
	Object3dCommon::GetInstance()->CommonDrawSetting();

	pPlayer_->Draw();

	pEnemyManager_->Draw();

	// æç”»å‰å‡¦ç†(Sprite)
	SpriteCommon::GetInstance()->CommonDrawSetting();

	for (auto& sprite : sprites_)
	{
		sprite->Draw();
	}


	// ãƒˆãƒ©ãƒ³ã‚¸ã‚·ãƒ§ãƒ³æç”»
	if (isTransitioning_ && transition_)
	{
		transition_->Draw();
	}
}

void GameOverScene::CameraShake()
{
	// ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ã‚«ãƒ¡ãƒ©ã®æƒ…å ±ã‚’å–å¾—
	auto activeCamera = cameraManager.GetActiveCamera();
	if (activeCamera)
	{
		auto viewMatrix = activeCamera->GetViewMatrix();
	}

	// ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ãŒãƒ’ãƒƒãƒˆã—ãŸå ´åˆã«ã‚«ãƒ¡ãƒ©ã‚’ã‚·ã‚§ã‚¤ã‚¯
	if (pPlayer_->IsHitMoment())
	{
		// ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ãªã‚«ãƒ¡ãƒ©ã‚’å–å¾—
		if (activeCamera)
		{
			// ã‚«ãƒ¡ãƒ©ã‚’ã‚·ã‚§ã‚¤ã‚¯ (æŒç¶šæ™‚é–“,æŒ¯å¹…)
			activeCamera->StartShake(0.3f, 0.6f);

			// ãƒ’ãƒƒãƒˆãƒ•ãƒ©ã‚°ã‚’ãƒªã‚»ãƒƒãƒˆ
			pPlayer_->SetHitMoment(false);
		}
	}

	// ã‚·ã‚§ã‚¤ã‚¯
	if (activeCamera)
	{
		activeCamera->UpdateShake(1.0f / 60.0f);
	}
}

============================================================
File Path: project/application/scene/GameOverScene.h
============================================================
#pragma once

#include <Framework.h>
#include <vector>
#include <memory>
#include <MyMath.h>
#include <Object3d.h>
#include <Vector3.h>

#include "../../gameEngine/baseScene/BaseScene.h"
#include "../../gameEngine/transition/BlockRiseTransition.h"
#include "../../application/objects/player/Player.h"
#include "../../application/objects/enemy/EnemyManager.h"
#include "../../gameEngine/collider/ColliderManager.h"

/// <summary>
/// ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼ã‚·ãƒ¼ãƒ³
/// ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼è¡¨ç¤ºã€ã‚¨ãƒ•ã‚§ã‚¯ãƒˆã€BGMå†ç”Ÿã€ã‚·ãƒ¼ãƒ³é·ç§»
/// </summary>
class GameOverScene : public BaseScene
{
public:

	// åˆæœŸåŒ–
	void Initialize() override;

	// çµ‚äº†
	void Finalize() override;

	// æ›´æ–°
	void Update() override;

	// æç”»
	void Draw() override;

private:

	// ã‚«ãƒ¡ãƒ©ã‚·ã‚§ã‚¤ã‚¯
	void CameraShake();

private:

	CameraManager& cameraManager = CameraManager::GetInstance();
	std::shared_ptr<Camera> camera_ = std::make_shared<Camera>();
	Vector3 cameraPosition_{};
	Vector3 cameraRotate_{};

	// 2Dã‚¹ãƒ—ãƒ©ã‚¤ãƒˆ
	std::vector<std::unique_ptr<Sprite>>sprites_ = {};
	// æç”»ã™ã‚‹ã‚¹ãƒ—ãƒ©ã‚¤ãƒˆã®æ•°
	uint32_t spriteNum_ = 3;

	// é·ç§»
	std::unique_ptr<BlockRiseTransition> transition_ = nullptr;
	bool isTransitioning_ = false;

	// è¡çªåˆ¤å®š
	ColliderManager* colliderManager_ = nullptr;

	// ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼
	std::unique_ptr<Player> pPlayer_ = nullptr;

	// ã‚¨ãƒãƒŸãƒ¼
	std::unique_ptr<EnemyManager> pEnemyManager_ = nullptr;

};



============================================================
File Path: project/application/scene/GamePlayScene.cpp
============================================================
#include "GamePlayScene.h"

#include <ModelManager.h>
#include <Ease.h>
#include <corecrt_math_defines.h>

void GamePlayScene::Initialize()
{
	// å¿…ãšå…ˆé ­ã§ã‚«ãƒ¡ãƒ©ã‚’å…¨ã‚¯ãƒªã‚¢
	cameraManager.ClearAllCameras();

	// ã‚«ãƒ¡ãƒ©ã®ä½œæˆ
	camera = std::make_shared<Camera>();

	cameraRotate = camera->GetRotate();
	cameraPosition = camera->GetPosition();
	cameraPosition.y = 70.0f;
	cameraPosition.z = -15.0f;
	cameraRotate.x = 1.2f;

	camera->SetPosition(camStart_);
	camera->SetRotate(camStartRot_);

	// ã‚«ãƒ¡ãƒ©ã®è¿½åŠ 
	cameraManager.AddCamera(camera);

	// ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ã‚«ãƒ¡ãƒ©ã®è¨­å®š
	cameraManager.SetActiveCamera(0);
	activeIndex = cameraManager.GetActiveIndex();

	Object3dCommon::GetInstance()->SetDefaultCamera(cameraManager.GetActiveCamera());

	// è¡çªåˆ¤å®š
	colliderManager_ = ColliderManager::GetInstance();
	colliderManager_->Initialize();

	// ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼
	pPlayer_ = std::make_unique<Player>();
	pPlayer_->Initialize();

	// ã‚¨ãƒãƒŸãƒ¼
	pEnemyManager_ = std::make_unique<EnemyManager>();
	pEnemyManager_->Initialize();

	// ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰
	pField_ = std::make_unique<Field>();
	pField_->Initialize();

	// ã‚´ãƒ¼ãƒ«ã®åˆæœŸåŒ–
	pGoal_ = std::make_unique<Goal>();
	pGoal_->Initialize();

	// è¿½å°¾ã®åˆæœŸåŒ–
	cameraIsResting_ = true;
	cameraRestCenter_ = pPlayer_->GetPosition() + Vector3{ 0.0f,70.0f,-20.0f };

	// ã‚¹ãƒ—ãƒ©ã‚¤ãƒˆ
	for (uint32_t i = 0; i < spriteNum_; ++i)
	{
		auto sprite = std::make_unique<Sprite>();

		if (i == 0)
		{
			sprite->Initialize("playUI.png", { 0,600 }, color_, { 0,0 });
		}
		else if (i == 1)
		{
			sprite->Initialize("uvChecker.png", { 0,0 }, color_, { 0.5f,0.5f });
			sprite->SetSize({ 100.0f, 20.0f });
		}

		sprites_.push_back(std::move(sprite));
	}

	// ãƒ¬ãƒ™ãƒ«ãƒ‡ãƒ¼ã‚¿ã®èª­ã¿è¾¼ã¿
	levelData_ = LevelDataLoader::LoadLevelData("wallSetting");
	if (levelData_)
	{
		// ãƒ¬ãƒ™ãƒ«ãƒ‡ãƒ¼ã‚¿ã«åŸºã¥ã„ã¦å£ã‚’é…ç½®
		for (const auto& wallData : levelData_->walls)
		{
			auto wall = std::make_unique<Wall>();
			wall->Initialize();
			wall->SetPosition(wallData.position);
			wall->SetRotation(wallData.rotation);
			wall->SetScale(wallData.scale);
			pWalls_.push_back(std::move(wall));
		}
	}

	// ã‚·ãƒ¼ãƒ³é–‹å§‹æ™‚é·ç§»æ¼”å‡º
	blockTransition_ = std::make_unique<BlockRiseTransition>(BlockRiseTransition::Mode::DropOnly);
	isTransitioning_ = true;
	blockTransition_->Start(nullptr);

	// ã‚¹ã‚¿ãƒ¼ãƒˆã‚«ãƒ¡ãƒ©æ¼”å‡º
	isStartCamera_ = true;
	cameraStartTimer_ = 0.0f;

	// ãƒ‡ã‚¹ã‚«ãƒ¡ãƒ©ãƒ•ãƒ©ã‚°åˆæœŸåŒ–
	isDeathCamera_ = false;
	isDeadCameraPlayer_ = false;

	// ã‚¯ãƒªã‚¢ã‚«ãƒ¡ãƒ©ãƒ•ãƒ©ã‚°åˆæœŸåŒ–
	isClearMoment_ = false;
	isClearCamera_ = false;
	isClearFadeStart_ = false;

}

void GamePlayScene::Finalize()
{
	pPlayer_->Finalize();
	pEnemyManager_->Finalize();
	pField_->Finalize();
	for (auto& wall : pWalls_)
	{
		wall->Finalize();
	}
	pGoal_->Finalize();

	// ã‚«ãƒ¡ãƒ©è§£æ”¾
	cameraManager.RemoveCamera(0);
}

void GamePlayScene::Update()
{
	// ãƒˆãƒ©ãƒ³ã‚¸ã‚·ãƒ§ãƒ³æ›´æ–°
	if (isTransitioning_ && blockTransition_)
	{
		blockTransition_->Update();

		// ãƒˆãƒ©ãƒ³ã‚¸ã‚·ãƒ§ãƒ³çµ‚äº†åˆ¤å®š
		if (blockTransition_->IsFinished())
		{
			blockTransition_.reset();
			isTransitioning_ = false;
		}

	}

	if(isTransitioning_ && fadeTransition_)
	{
		fadeTransition_->Update();
		// ãƒˆãƒ©ãƒ³ã‚¸ã‚·ãƒ§ãƒ³çµ‚äº†åˆ¤å®š
		if (fadeTransition_->IsFinished())
		{
			fadeTransition_.reset();
			isTransitioning_ = false;
		}
	}
	
	// ã‚¹ã‚¿ãƒ¼ãƒˆã‚«ãƒ¡ãƒ©æ¼”å‡º
	StartCamera();

	// ã‚«ãƒ¡ãƒ©ãƒžãƒãƒ¼ã‚¸ãƒ£ãƒ¼ã®æ›´æ–°
	cameraManager.UpdateAll();

	// å½“ãŸã‚Šåˆ¤å®šãƒã‚§ãƒƒã‚¯
	colliderManager_->CheckAllCollision();

	// ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®æ›´æ–°
	pPlayer_->Update();
	// ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®ä½ç½®ã‚’ã‚¨ãƒãƒŸãƒ¼ãƒžãƒãƒ¼ã‚¸ãƒ£ãƒ¼ã«ã‚»ãƒƒãƒˆ
	pEnemyManager_->SetPlayerPosition(pPlayer_->GetPosition());

	// ã‚«ãƒ¡ãƒ©ã®æ›´æ–°(ã‚·ã‚§ã‚¤ã‚¯ã€è¿½å°¾ã€å¼•ã)
	if (!isStartCamera_ && !pPlayer_->IsDead())
	{
		camera->SetRotate(cameraRotate);
		camera->SetPosition(cameraPosition);
		CameraUpdate();
	}

	// ã‚¨ãƒãƒŸãƒ¼ã®æ›´æ–°
	pEnemyManager_->Update();

	// ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã®æ›´æ–°
	pField_->Update();

	// å£ã®æ›´æ–°
	for (auto& wall : pWalls_)
	{
		wall->Update();
	}

	// ã‚´ãƒ¼ãƒ«ã®æ›´æ–°
	pGoal_->Update();
	pGoal_->SetBarrierDestroyed(pEnemyManager_->IsAllEnemyDefeated());

	// è¿½å°¾ã‚¹ãƒ—ãƒ©ã‚¤ãƒˆã®æ›´æ–°
	auto activeCamera = cameraManager.GetActiveCamera();
	if (activeCamera)
	{
		// ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã«ã‚ªãƒ•ã‚»ãƒƒãƒˆ
		Vector3 worldHeadPos = pPlayer_->GetPosition() + Vector3{ 0.0f, 1.6f, 1.5f };
		Vector2 screen = activeCamera->WorldToScreen(worldHeadPos);
		sprites_[1]->SetPosition(screen);
	}

	// ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ãŒæ­»ã‚“ã ã‚‰ãƒ‡ã‚¹ã‚«ãƒ¡ãƒ©ã‚’é–‹å§‹(1å›žã ã‘)
	if (pPlayer_->IsDead() && !pPlayer_->IsAutoControl() && !isTransitioning_ && !isDeadCameraPlayer_)
	{
		if (!isDeathCamera_)
		{
			StartDeathCamera();
		}
	}

	// DeathCameraæ›´æ–°(StartDeathCameraãŒå‘¼ã°ã‚Œã¦ã„ã‚‹å ´åˆ)
	if (isDeathCamera_)
	{
		UpdateDeathCamera(1.0f / 60.0f);
	}

	// ã‚¯ãƒªã‚¢æ›´æ–°
	ClearUpdate();

	// ã‚¹ãƒ—ãƒ©ã‚¤ãƒˆã®æ›´æ–°
	for (auto& sprite : sprites_)
	{
		sprite->Update();

		sprite->SetColor(color_);
	}


#ifdef USE_IMGUI

	AllImGui();

#endif // USE_IMGUI


	if (Input::GetInstance()->TriggerKey(DIK_UP) or (isClearFadeStart_ && !isTransitioning_))
	{
		// ãƒˆãƒ©ãƒ³ã‚¸ã‚·ãƒ§ãƒ³é–‹å§‹
		fadeTransition_ = std::make_unique<FadeTransition>();
		isTransitioning_ = true;
		fadeTransition_->Start([]
			{
			// ã‚·ãƒ¼ãƒ³åˆ‡ã‚Šæ›¿ãˆ
			SceneManager::GetInstance()->ChangeScene("CLEAR");
			});
	}
	if (Input::GetInstance()->TriggerKey(DIK_DOWN) or (pPlayer_->IsDeathMotionComplete() && !isTransitioning_))
	{
		// ãƒˆãƒ©ãƒ³ã‚¸ã‚·ãƒ§ãƒ³é–‹å§‹
		blockTransition_ = std::make_unique<BlockRiseTransition>();
		isTransitioning_ = true;
		blockTransition_->Start([]
			{
				// ã‚·ãƒ¼ãƒ³åˆ‡ã‚Šæ›¿ãˆ
				SceneManager::GetInstance()->ChangeScene("GAMEOVER");
			});
	}
}

void GamePlayScene::Draw()
{
	// æç”»å‰å‡¦ç†(Object)
	Object3dCommon::GetInstance()->CommonDrawSetting();

	pPlayer_->Draw();

	pEnemyManager_->Draw();

	pField_->Draw();

	for (auto& wall : pWalls_)
	{
		wall->Draw();
	}

	pGoal_->Draw();


	// æç”»å‰å‡¦ç†(Sprite)
	SpriteCommon::GetInstance()->CommonDrawSetting();

	for (auto& sprite : sprites_)
	{
		sprite->Draw();
	}

	pPlayer_->Draw2D();

	// ãƒˆãƒ©ãƒ³ã‚¸ã‚·ãƒ§ãƒ³æç”»
	if (isTransitioning_ && blockTransition_)
	{
		blockTransition_->Draw();
	}
	if (isTransitioning_ && fadeTransition_)
	{
		fadeTransition_->Draw();
	}
}

void GamePlayScene::AllImGui()
{
#ifdef USE_IMGUI

	ImGui::Begin("PlayScene");


	// é€æ˜Žåº¦ã®æ›´æ–°
	ImGui::SliderFloat4("SpriteColor", &color_.x, 0.0f, 1.0f);

	// camera
	Vector3 cam1Pos = camera->GetPosition();
	Vector3 cam1Rot = camera->GetRotate();
	if (ImGui::SliderFloat3("cameraPosition", &cam1Pos.x, -100.0f, 100.0f))
	{
		camera->SetPosition(cam1Pos);
	}
	if (ImGui::SliderFloat3("cameraRotate", &cam1Rot.x, -10.0f, 10.0f))
	{
		camera->SetRotate(cam1Rot);
	}


	ImGui::End();

	pPlayer_->ImGuiDraw();
	pEnemyManager_->ImGuiDraw();
	pField_->ImGuiDraw();
	for (auto& wall : pWalls_)
	{
		wall->ImGuiDraw();
	}
	pGoal_->ImGuiDraw();


#endif // USE_IMGUI
}

void GamePlayScene::CameraUpdate()
{
	// ã‚«ãƒ¡ãƒ©ã®ã‚·ã‚§ã‚¤ã‚¯
	CameraShake();

	// ã‚«ãƒ¡ãƒ©ã®è¿½å¾“
	CameraFollow();

}

void GamePlayScene::CameraShake()
{
	// ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ã‚«ãƒ¡ãƒ©ã®æƒ…å ±ã‚’å–å¾—
	auto activeCamera = cameraManager.GetActiveCamera();
	if (activeCamera)
	{
		auto viewMatrix = activeCamera->GetViewMatrix();
	}

	// ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ãŒãƒ’ãƒƒãƒˆã—ãŸå ´åˆã«ã‚«ãƒ¡ãƒ©ã‚’ã‚·ã‚§ã‚¤ã‚¯
	if (pPlayer_->IsHitMoment())
	{
		// ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ãªã‚«ãƒ¡ãƒ©ã‚’å–å¾—
		if (activeCamera)
		{
			// ã‚«ãƒ¡ãƒ©ã‚’ã‚·ã‚§ã‚¤ã‚¯ (æŒç¶šæ™‚é–“,æŒ¯å¹…)
			activeCamera->StartShake(0.3f, 1.2f);

			// ãƒ’ãƒƒãƒˆãƒ•ãƒ©ã‚°ã‚’ãƒªã‚»ãƒƒãƒˆ
			pPlayer_->SetHitMoment(false);
		}
	}

	// ã‚·ã‚§ã‚¤ã‚¯
	if (activeCamera)
	{
		activeCamera->UpdateShake(1.0f / 60.0f);
	}
}

void GamePlayScene::CameraFollow()
{
	if (!camera or !pPlayer_) 
	{
		return;
	}

	Vector3 playerPos = pPlayer_->GetPosition();

	// å›ºå®šã®ã‚ªãƒ•ã‚»ãƒƒãƒˆï¼ˆãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‹ã‚‰è¦‹ãŸã‚«ãƒ¡ãƒ©ä½ç½®ï¼‰
	Vector3 offset = { 0.0f, 80.0f, -20.0f };  // Y: é«˜ã•ã€Z: å¾Œæ–¹

	// è¿½å¾“å…ˆã®ä½ç½®ãƒ»å›žè»¢
	Vector3 targetPos = playerPos + offset;
	Vector3 targetRot = { 2.0f, 0.0f, 0.0f };  // ã‚„ã‚„ä¸‹å‘ã

	// æ»‘ã‚‰ã‹ã«è£œé–“ã—ã¦è¿½å¾“
	Vector3 currentPos = camera->GetPosition();
	Vector3 nextPos;
	nextPos.Lerp(currentPos, targetPos, 0.8f);

	Vector3 currentRot = camera->GetRotate();
	Vector3 nextRot;
	nextRot.Lerp(currentRot, targetRot, 0.25f);

	camera->SetPosition(nextPos);
	camera->SetRotate(nextRot);
}

void GamePlayScene::StartCamera()
{
	if (isStartCamera_ && !isTransitioning_)
	{
		cameraStartTimer_ += 1.0f / 60.0f;
		float t = std::clamp(cameraStartTimer_ / cameraStartDuration_, 0.0f, 1.0f);
		float t_eased = Ease::InOutQuad(t);

		// è£œé–“
		Vector3 camPos = Bezier3(camStart_, camControl1_, camControl2_, camEnd_, t_eased);
		Vector3 camRot = Lerp(camStartRot_, camEndRot_, t_eased);
		camera->SetPosition(camPos);
		camera->SetRotate(camRot);

		if (t >= 1.0f)
		{
			isStartCamera_ = false; // çµ‚äº†
			camera->SetPosition(camEnd_);
			camera->SetRotate(camEndRot_);
		}
	}

}

void GamePlayScene::StartDeathCamera()
{
	if (!camera or !pPlayer_)
	{
		return;
	}

	// ä¸€åº¦ã ã‘ãƒ•ãƒ©ã‚°
	isDeadCameraPlayer_ = true;

	isDeathCamera_ = true;
	deathCameraTimer_ = 0.0f;

	// ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ä½ç½®ã¨ç¾ã‚«ãƒ¡ãƒ©ä½ç½®ã‹ã‚‰é–‹å§‹è§’åº¦ãƒ»åŠå¾„ãƒ»é«˜ã•ã‚’ç®—å‡º
	Vector3 playerPos = pPlayer_->GetPosition();
	Vector3 camPos = camera->GetPosition();

	float dx = camPos.x - playerPos.x;
	float dz = camPos.z - playerPos.z;
	// startAngle ã‚’ atan2(dx, dz)ã®é †ã§å–ã‚‹(Bezierç­‰ã§ä½¿ã£ãŸã®ã¨æ•´åˆã‚’å–ã‚‹)
	deathStartAngle_ = std::atan2(dx, dz);
	deathStartRadius_ = std::sqrt(dx * dx + dz * dz);
	deathStartHeight_ = camPos.y - playerPos.y;

	// æœ€çµ‚çš„ã«ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®æ­£é¢ã¯ 0 ã«
	deathTargetAngleOffset_ = 0.0f;
}

void GamePlayScene::UpdateDeathCamera(float deltaTime)
{
	if (!isDeathCamera_ or (!camera || !pPlayer_))
	{
		return;
	}

	deathCameraTimer_ += deltaTime;
	float t = std::clamp(deathCameraTimer_ / deathCameraDuration_, 0.0f, 1.0f);

	// ã‚¤ãƒ¼ã‚¸ãƒ³ã‚°
	float t_eased = Ease::InOutQuad(t);

	// è§’åº¦ã¯ start -> target ã‚’çµŒç”±ã—ã¦ rotations å‘¨å›žã•ã›ã‚‹
	// targetAngle = deathTargetAngleOffset_0: ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼å‰æ–¹
	float targetAngle = deathTargetAngleOffset_;
	// å·®åˆ†ã‚’ç¬¦å·ä»˜ãã§æ­£è¦åŒ–ã—ã¦ãŠãã€ã•ã‚‰ã«å‘¨å›žåˆ†ã‚’è¿½åŠ 
	float delta = targetAngle - deathStartAngle_;
	// normalize delta to [-pi, pi]
	while (delta > (float)M_PI) delta -= 2.0f * (float)M_PI;
	while (delta < (float) - M_PI) delta += 2.0f * (float)M_PI;
	float totalAngularTravel = delta + deathCameraRotations_ * 2.0f * (float)M_PI;
	float angle = deathStartAngle_ + totalAngularTravel * t_eased;

	// åŠå¾„ã¨é«˜ã•ã‚’è£œé–“(start -> end)
	float radius = std::lerp(deathStartRadius_, deathEndRadius_, t_eased);
	float height = std::lerp(deathStartHeight_, deathEndHeight_, t_eased);

	// ã‚«ãƒ¡ãƒ©ä½ç½®ã‚’è¨ˆç®—(playerã‚’ä¸­å¿ƒã«æ¥µåº§æ¨™ã‹ã‚‰)
	Vector3 playerPos = pPlayer_->GetPosition();
	Vector3 camPos;
	camPos.x = playerPos.x + std::sin(angle) * radius;
	camPos.z = playerPos.z + std::cos(angle) * radius;
	camPos.y = playerPos.y + height;

	camera->SetPosition(camPos);

	// ã‚«ãƒ¡ãƒ©ã®å›žè»¢ï¼šãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚’è¦‹ã‚‹æ–¹å‘ã«å‘ã‘ã‚‹
	Vector3 dir = (playerPos - camPos);
	// yaw: yè»¸å›žè»¢(å·¦å³)ã‚’ atan2(dir.x, dir.z)
	float yaw = std::atan2(dir.x, dir.z);
	// pitch: xè»¸å›žè»¢(ä¸Šä¸‹)ã‚’ atan2(-dir.y, sqrt(x^2+z^2))
	float horizontalDist = std::sqrt(dir.x * dir.x + dir.z * dir.z);
	float pitch = std::atan2(-dir.y, horizontalDist);

	Vector3 camRot = { pitch, yaw, 0.0f };
	camera->SetRotate(camRot);

	// çµ‚äº†åˆ¤å®š
	if (t >= 1.0f)
	{
		isDeathCamera_ = false;
		// æœ€çµ‚çš„ã«ã´ã£ãŸã‚Šæ­£é¢ä½ç½®ã«ã‚»ãƒƒãƒˆã—ã¦çµ‚äº†
		Vector3 finalPos;
		finalPos.x = playerPos.x + std::sin(targetAngle) * deathEndRadius_;
		finalPos.z = playerPos.z + std::cos(targetAngle) * deathEndRadius_;
		finalPos.y = playerPos.y + deathEndHeight_;
		camera->SetPosition(finalPos);

		Vector3 finalDir = (playerPos - finalPos);
		float finalYaw = std::atan2(finalDir.x, finalDir.z);
		float finalH = std::sqrt(finalDir.x * finalDir.x + finalDir.z * finalDir.z);
		float finalPitch = std::atan2(-finalDir.y, finalH);
		camera->SetRotate({ finalPitch, finalYaw, 0.0f });

		// ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼æ­»äº¡æ¼”å‡º
		pPlayer_->StartDeathMotion();

	}
}

void GamePlayScene::ClearUpdate()
{
	if (pGoal_->IsCleared() && !isTransitioning_ && !isClearMoment_)
	{
		// ä¸€åº¦ã ã‘ãƒ•ãƒ©ã‚°
		isClearMoment_ = true;

		isClearCamera_ = true;
		clearCameraTimer_ = -2.0f;

		// ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ä½ç½®ã¨ç¾ã‚«ãƒ¡ãƒ©ä½ç½®ã‹ã‚‰é–‹å§‹è§’åº¦ãƒ»åŠå¾„ãƒ»é«˜ã•ã‚’ç®—å‡º
		Vector3 playerPos = pPlayer_->GetPosition();
		Vector3 camPos = camera->GetPosition();

		float dx = camPos.x - playerPos.x;
		float dz = camPos.z - playerPos.z;
		// startAngle ã‚’ atan2(dx, dz)ã®é †ã§å–ã‚‹(Bezierç­‰ã§ä½¿ã£ãŸã®ã¨æ•´åˆã‚’å–ã‚‹)
		clearStartAngle_ = std::atan2(dx, dz);
		clearStartRadius_ = std::sqrt(dx * dx + dz * dz);
		clearStartHeight_ = camPos.y - playerPos.y;

		// æœ€çµ‚çš„ã«ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®æ­£é¢ã¯ 0 ã«
		clearTargetAngleOffset_ = 0.0f;
	}


	if (isClearCamera_)
	{
		if (clearCameraTimer_ >= 0.0f)
		{

			clearCameraTimer_ += 1.0f / 60.0f;
			float t = std::clamp(clearCameraTimer_ / clearCameraDuration_, 0.0f, 1.0f);

			// ã‚¤ãƒ¼ã‚¸ãƒ³ã‚°
			float t_eased = Ease::InOutQuad(t);

			// --- å›žè»¢é€Ÿåº¦ã‚’ã•ã‚‰ã«è½ã¨ã™ä¿‚æ•° å°ã•ãã™ã‚‹ã»ã©é…ãå›žã‚‹ ---
			const float rotationSpeedMultiplier = 0.12f; // èª¿æ•´å¯
			// --- ã‚«ãƒ¡ãƒ©ã‚’ä¸Šæ˜‡ã•ã›ã‚‹é‡ ---
			const float clearHeightRise = 30.0f; // èª¿æ•´å¯ æ­£ã®å€¤ã§ä¸Šæ˜‡

			// è§’åº¦ã¯ start -> target ã‚’çµŒç”±ã—ã¦ rotations å‘¨å›žã•ã›ã‚‹
			float targetAngle = clearTargetAngleOffset_;
			float delta = targetAngle - clearStartAngle_;
			// normalize delta to [-pi, pi]
			while (delta > (float)M_PI) delta -= 2.0f * (float)M_PI;
			while (delta < (float)-M_PI) delta += 2.0f * (float)M_PI;

			// å‘¨å›žæ•°ã« multiplier ã‚’ã‹ã‘ã¦å®ŸåŠ¹çš„ãªå›žè»¢é‡ã‚’æ¸›ã‚‰ã™ï¼ˆæ€¥æ¿€ãªå›žè»¢ã‚’æŠ‘åˆ¶ï¼‰
			float rotationsScaled = clearCameraRotations_ * rotationSpeedMultiplier;
			float totalAngularTravel = delta + rotationsScaled * 2.0f * (float)M_PI;
			float angle = clearStartAngle_ + totalAngularTravel * t_eased;

			// åŠå¾„ã¯åŽç¸®ã•ã›ãªã„ï¼ˆé–‹å§‹æ™‚ã®åŠå¾„ã‚’ç¶­æŒï¼‰
			const float radius = clearStartRadius_;

			// é«˜ã•ã¯é–‹å§‹é«˜ã•ã‹ã‚‰å¾ã€…ã«ä¸Šæ˜‡
			float height = clearStartHeight_ + clearHeightRise * t_eased;

			// ã‚«ãƒ¡ãƒ©ä½ç½®ã‚’è¨ˆç®—(playerã‚’ä¸­å¿ƒã«æ¥µåº§æ¨™ã‹ã‚‰)
			Vector3 playerPos = pPlayer_->GetPosition();
			Vector3 camPos;
			camPos.x = playerPos.x + std::sin(angle) * radius;
			camPos.z = playerPos.z + std::cos(angle) * radius;
			camPos.y = playerPos.y + height;

			camera->SetPosition(camPos);

			// ã‚«ãƒ¡ãƒ©ã®å›žè»¢ï¼šãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚’è¦‹ã‚‹æ–¹å‘ã«å‘ã‘ã‚‹
			Vector3 dir = (playerPos - camPos);
			// yaw: yè»¸å›žè»¢(å·¦å³)ã‚’ atan2(dir.x, dir.z)
			float yaw = std::atan2(dir.x, dir.z);
			// pitch: xè»¸å›žè»¢(ä¸Šä¸‹)ã‚’ atan2(-dir.y, sqrt(x^2+z^2))
			float horizontalDist = std::sqrt(dir.x * dir.x + dir.z * dir.z);
			float pitch = std::atan2(-dir.y, horizontalDist);

			Vector3 camRot = { pitch, yaw, 0.0f };
			camera->SetRotate(camRot);

			// çµ‚äº†ä»•åˆ‡ã‚‹å‰ã«ãƒ•ã‚§ãƒ¼ãƒ‰é–‹å§‹åˆ¤å®š
			if (t >= 0.4f)
			{
				// é·ç§»æ¼”å‡ºé–‹å§‹
				isClearFadeStart_ = true;
			}
		}
		else
		{
			clearCameraTimer_ += 1.0f / 60.0f;
		}
	}
}


============================================================
File Path: project/application/scene/GamePlayScene.h
============================================================
#pragma once

#include <Framework.h>

#include "../../gameEngine/baseScene/BaseScene.h"
#include "../../application/objects/player/Player.h"
#include "../../application/objects/enemy/EnemyManager.h"
#include "../../application/objects/field/Field.h"
#include "../../application/objects/field/Wall.h"
#include "../../application/objects/field/Goal.h"
#include "../../gameEngine/collider/ColliderManager.h"
#include "../../gameEngine/level_editor/LevelDataLoader.h"

#include "../../gameEngine/transition/BlockRiseTransition.h"
#include "../../gameEngine/transition/FadeTransition.h"

/// <summary>
///	ã‚²ãƒ¼ãƒ ãƒ—ãƒ¬ã‚¤ã‚·ãƒ¼ãƒ³
/// ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼æ“ä½œã€æ•µå‡ºç¾ã€ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã€ã‚´ãƒ¼ãƒ«ã€è¡çªåˆ¤å®šã€ã‚·ãƒ¼ãƒ³é·ç§»
/// </summary>
class GamePlayScene : public BaseScene
{
public:

	// åˆæœŸåŒ–
	void Initialize() override;

	// çµ‚äº†
	void Finalize() override;

	// æ›´æ–°
	void Update() override;

	// æç”»
	void Draw() override;

private:

	// ã“ã®ã‚·ãƒ¼ãƒ³ã§å‡ºã™å…¨ã¦ã®ImGui
	void AllImGui();

	// ã‚«ãƒ¡ãƒ©æ›´æ–°
	void CameraUpdate();

	// ã‚«ãƒ¡ãƒ©ã‚·ã‚§ã‚¤ã‚¯
	void CameraShake();

	// ã‚«ãƒ¡ãƒ©è¿½å°¾
	void CameraFollow();

	/// <summary>
	/// ã‚¹ã‚¿ãƒ¼ãƒˆã‚«ãƒ¡ãƒ©
	///	</summary>
	void StartCamera();

	/// <summary>
	/// ãƒ‡ã‚¹ã‚«ãƒ¡ãƒ©
	/// </summary>
	void StartDeathCamera();

	/// <summary>
	/// ãƒ‡ã‚¹ã‚«ãƒ¡ãƒ©æ›´æ–°
	/// </summary>
	/// <param name="deltaTime">ãƒ‡ãƒ«ã‚¿ã‚¿ã‚¤ãƒ </param>
	void UpdateDeathCamera(float deltaTime);

	/// <summary>
	/// ã‚¯ãƒªã‚¢æ›´æ–°
	/// </summary>
	void ClearUpdate();


private:

	CameraManager& cameraManager = CameraManager::GetInstance();
	std::shared_ptr<Camera> camera = nullptr;
    
    uint32_t activeIndex = 0;
	Vector3 cameraRotate = { -0.9f,0.0f,0.0f};
	Vector3 cameraPosition = { 0.0f,-20.0f,0.0f };

	// 2Dã‚¹ãƒ—ãƒ©ã‚¤ãƒˆ
	std::vector<std::unique_ptr<Sprite>>sprites_ = {};
	Vector4 color_ = { 1.0f,1.0f,1.0f,1.0f };
	// æç”»ã™ã‚‹ã‚¹ãƒ—ãƒ©ã‚¤ãƒˆã®æ•°
	uint32_t spriteNum_ = 2;

	// é·ç§»
	std::unique_ptr<BlockRiseTransition> blockTransition_ = nullptr;
	std::unique_ptr<FadeTransition> fadeTransition_ = nullptr;
	bool isTransitioning_ = false;

	// è¡çªåˆ¤å®š
	ColliderManager* colliderManager_ = nullptr;

	// ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼
	std::unique_ptr<Player> pPlayer_ = nullptr;

	// ã‚¨ãƒãƒŸãƒ¼
	std::unique_ptr<EnemyManager> pEnemyManager_ = nullptr;

	// ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰
	std::unique_ptr<Field> pField_ = nullptr;

	// å£
	std::vector<std::unique_ptr<Wall>> pWalls_;

	// ã‚´ãƒ¼ãƒ«
	std::unique_ptr<Goal> pGoal_ = nullptr;
	
	// ã‚«ãƒ¡ãƒ©ãŒé™æ­¢æ™‚ã«è¿½å¾“ã™ã‚‹åŸºæº–ä½ç½®
	Vector3 cameraRestCenter_; 
	// ã‚«ãƒ¡ãƒ©ãŒç¾åœ¨é™æ­¢ãƒ¢ãƒ¼ãƒ‰ã‹ã©ã†ã‹
	bool cameraIsResting_ = true;

	// ãƒ¬ãƒ™ãƒ«ãƒ‡ãƒ¼ã‚¿ãƒ­ãƒ¼ãƒ€ãƒ¼
	std::unique_ptr<LevelData> levelData_ = nullptr;

	// ã‚¹ã‚¿ãƒ¼ãƒˆã‚«ãƒ¡ãƒ©æ¼”å‡ºå¤‰æ•°
	bool isStartCamera_ = false;
	float cameraStartTimer_ = 0.0f;
	float cameraStartDuration_ = 1.5f;
	Vector3 camStart_ = { 0.16f, 5.0f, 8.0f };
	Vector3 camControl1_ = { 0.16f, 5.0f, -8.0f };
	Vector3 camControl2_ = { 0.16f, 50.0f, -20.0f };
	Vector3 camEnd_ = { 0.16f, 78.5f, -19.8f };
	Vector3 camStartRot_ = { 0.0f, 0.0f, 0.0f };
	Vector3 camEndRot_ = { 1.4f, 0.0f, 0.0f };

	// æ­»äº¡ã‚«ãƒ¡ãƒ©æ¼”å‡ºå¤‰æ•°
	bool isDeathCamera_ = false;
	bool isDeadCameraPlayer_ = false;
	float deathCameraTimer_ = 0.0f;
	float deathCameraDuration_ = 3.0f;
	float deathCameraRotations_ = 2.0f;
	float deathStartAngle_ = 0.0f;
	float deathStartRadius_ = 0.0f;
	float deathEndRadius_ = 12.0f;
	float deathStartHeight_ = 0.0f;
	float deathEndHeight_ = 12.0f;
	float deathTargetAngleOffset_ = 0.0f;

	// ã‚¯ãƒªã‚¢æ™‚ã‚«ãƒ¡ãƒ©æ¼”å‡ºå¤‰æ•°
	bool isClearMoment_ = false;
	bool isClearCamera_ = false;
	bool isClearFadeStart_ = false;
	float clearCameraTimer_ = 0.0f;
	float clearCameraDuration_ = 3.0f;
	float clearCameraRotations_ = 20.0f;
	float clearStartAngle_ = 0.0f;
	float clearStartRadius_ = 20.0f;
	float clearEndRadius_ = 5.0f;
	float clearStartHeight_ = 10.0f;
	float clearEndHeight_ = 3.0f;
	float clearTargetAngleOffset_ = 0.0f;

};

============================================================
File Path: project/application/scene/SceneFactory.cpp
============================================================
#include "SceneFactory.h"

#include <memory>

#include "../../application/scene/TitleScene.h"
#include "../../application/scene/GamePlayScene.h"
#include "../../application/scene/GameOverScene.h"
#include "../../application/scene/ClearScene.h"

std::unique_ptr<BaseScene> SceneFactory::CreateScene(const std::string& sceneName)
{
	if (sceneName == "TITLE")
	{
		return std::make_unique<TitleScene>();
	}
	else if (sceneName == "GAMEPLAY")
	{
		return std::make_unique<GamePlayScene>();
	}
	else if (sceneName == "GAMEOVER")
	{
		return std::make_unique<GameOverScene>();
	}
	else if (sceneName == "CLEAR")
	{
		return std::make_unique<ClearScene>();
	}

	return nullptr;
}


============================================================
File Path: project/application/scene/SceneFactory.h
============================================================
#pragma once

#include "../../../gameEngine/baseScene/AbstractSceneFactory.h"

/// <summary>
/// ã‚·ãƒ¼ãƒ³ãƒ•ã‚¡ã‚¯ãƒˆãƒª
/// ã‚·ãƒ¼ãƒ³ã®ç”Ÿæˆã‚’è¡Œã†
/// </summary>
class SceneFactory : public AbstractSceneFactory
{
public:

	/// <summary>
	/// ã‚·ãƒ¼ãƒ³ç”Ÿæˆ
	/// </summary>
	/// <param name="sceneName">ç”Ÿæˆã—ãŸã„ã‚·ãƒ¼ãƒ³ã®åå‰</param>
	/// <returns>ç”Ÿæˆã•ã‚ŒãŸã‚·ãƒ¼ãƒ³ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹</returns>
	std::unique_ptr<BaseScene> CreateScene(const std::string& sceneName) override;
};

============================================================
File Path: project/application/scene/TitleScene.cpp
============================================================
#include "TitleScene.h"

#include <cmath>
#include <ModelManager.h>

void TitleScene::Initialize()
{
	// å¿…ãšå…ˆé ­ã§ã‚«ãƒ¡ãƒ©ã‚’å…¨ã‚¯ãƒªã‚¢
	cameraManager.ClearAllCameras();

	camera_ = std::make_shared<Camera>();

	cameraPosition_ = camera_->GetRotate();
	cameraRotate_ = camera_->GetPosition();
	cameraPosition_.y = 70.0f;
	cameraPosition_.z = -15.0f;
	cameraRotate_.x = 1.2f;

	cameraManager.AddCamera(camera_);
	cameraManager.SetActiveCamera(0);
	Object3dCommon::GetInstance()->SetDefaultCamera(camera_);


	// è¡çªåˆ¤å®š
	colliderManager_ = ColliderManager::GetInstance();
	colliderManager_->Initialize();

	// ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼
	pPlayer_ = std::make_unique<Player>();
	pPlayer_->Initialize();
	pPlayer_->SetAutoControl(true); // ãƒ‡ãƒ¢ãƒ¢ãƒ¼ãƒ‰ã«è¨­å®š

	// ã‚¨ãƒãƒŸãƒ¼
	pEnemyManager_ = std::make_unique<EnemyManager>();
	pEnemyManager_->TitleEnemyInit();

	// ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰
	pField_ = std::make_unique<Field>();
	pField_->Initialize();


	// --- 2Dã‚¹ãƒ—ãƒ©ã‚¤ãƒˆ ---
	for (uint32_t i = 0; i < spriteNum_; ++i)
	{
		auto sprite = std::make_unique<Sprite>();

		if (i == 0)
		{
			
			sprite->Initialize("titleUI.png", { 0,0 }, color_, { 0,0 });
		}
		sprites_.push_back(std::move(sprite));

	}

	// --- ã‚µã‚¦ãƒ³ãƒ‰ ---
	soundData_ = Audio::GetInstance()->LoadWav("fanfare.wav");
	//Audio::GetInstance()->PlayWave(soundData_, false, 0.2f);
	soundData2_ = Audio::GetInstance()->LoadWav("BGM.wav");
	//Audio::GetInstance()->PlayWave(soundData2_, true, 0.2f);


	// ç’°å¢ƒãƒžãƒƒãƒ—
	cubeMapPath_ = "resources/images/studio.dds";
	TextureManager::GetInstance()->LoadTexture(cubeMapPath_);
	cubeSrvIndex_ = TextureManager::GetInstance()->GetTextureIndexByFilePath(cubeMapPath_);
	cubeHandle_ = TextureManager::GetInstance()->GetSrvManager()->GetGPUDescriptorHandle(cubeSrvIndex_);
	
		
	// ã‚·ãƒ¼ãƒ³é–‹å§‹æ™‚ã«ãƒ•ã‚§ãƒ¼ãƒ‰ã‚¤ãƒ³
	transition_ = std::make_unique<BlockRiseTransition>(BlockRiseTransition::Mode::DropOnly);
	isTransitioning_ = true;
	transition_->Start(nullptr);
}

void TitleScene::Finalize()
{
	pPlayer_->Finalize();
	pEnemyManager_->Finalize();
	pField_->Finalize();

	Audio::GetInstance()->SoundUnload(Audio::GetInstance()->GetXAudio2(), &soundData_);
	Audio::GetInstance()->SoundUnload(Audio::GetInstance()->GetXAudio2(), &soundData2_);

	cameraManager.RemoveCamera(0);
}

void TitleScene::Update()
{
	// ãƒˆãƒ©ãƒ³ã‚¸ã‚·ãƒ§ãƒ³æ›´æ–°
	if (isTransitioning_ && transition_) 
	{
		transition_->Update();

		// ãƒˆãƒ©ãƒ³ã‚¸ã‚·ãƒ§ãƒ³çµ‚äº†åˆ¤å®š
		if (transition_->IsFinished())
		{
			transition_.reset();
			isTransitioning_ = false;
		}
	
	}

	camera_->Update();
	camera_->SetPosition(cameraPosition_);
	camera_->SetRotate(cameraRotate_);

	// å½“ãŸã‚Šåˆ¤å®šãƒã‚§ãƒƒã‚¯
	colliderManager_->CheckAllCollision();

	// ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼
	pPlayer_->Update();
	// ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®ä½ç½®ã‚’ã‚¨ãƒãƒŸãƒ¼ãƒžãƒãƒ¼ã‚¸ãƒ£ãƒ¼ã«ã‚»ãƒƒãƒˆ
	pEnemyManager_->SetPlayerPosition(pPlayer_->GetPosition());

	// ã‚«ãƒ¡ãƒ©ã®æ›´æ–°(ã‚·ã‚§ã‚¤ã‚¯ã€è¿½å°¾ã€å¼•ã)
	CameraUpdate();
	
	// ã‚¨ãƒãƒŸãƒ¼
	pEnemyManager_->TitleEnemyUpdate();
	
	// ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰
	pField_->Update();


	for (auto& sprite : sprites_)
	{
		sprite->Update();

		sprite->SetColor(color_);

	}



#ifdef USE_IMGUI

	// é€æ˜Žåº¦ã®æ›´æ–°

	ImGui::Begin("TitleScene");

	ImGui::SliderFloat4("transparent", &color_.x, 0.0f, 1.0f);

	ImGui::SliderFloat3("cameraPosition", &cameraPosition_.x, -70.0f, 20.0f);
	ImGui::SliderFloat3("cameraRotate", &cameraRotate_.x, -3.14f, 3.14f);

	if (ImGui::Button("Terrain Draw"))
	{
		isTerrainDraw = !isTerrainDraw;
	}

	// ãƒ©ã‚¤ãƒˆã®è¨­å®š
	ImGui::Checkbox("Enable Lighting", &enableLighting);

	ImGui::Checkbox("Directional Light", &enableDirectionalLight);
	if (enableDirectionalLight)
	{
		ImGui::ColorEdit3("Directional Light Color", &directionalLightColor.x);
		ImGui::SliderFloat3("Directional Light Direction", &directionalLightDirection.x, -1.0f, 1.0f);
		ImGui::SliderFloat("Directional Light Intensity", &directionalLightIntensity, 0.0f, 10.0f);
	}

	ImGui::Checkbox("Point Light", &enablePointLight);
	if (enablePointLight)
	{
		ImGui::ColorEdit3("Point Light Color", &pointLightColor.x);
		ImGui::SliderFloat3("Point Light Position", &pointLightPosition.x, -20.0f, 20.0f);
		ImGui::SliderFloat("Point Light Intensity", &pointLightIntensity, 0.0f, 1.0f);
		ImGui::SliderFloat("Point Light Radius", &pointLightRadius, 0.0f, 50.0f);
		ImGui::SliderFloat("Point Light Decay", &pointLightDecay, 0.0f, 1.0f);
	}

	ImGui::Checkbox("Spot Light", &enableSpotLight);
	if (enableSpotLight)
	{
		ImGui::ColorEdit3("Spot Light Color", &spotLightColor.x);
		ImGui::SliderFloat3("Spot Light Position", &spotLightPosition.x, -20.0f, 20.0f);
		ImGui::SliderFloat3("Spot Light Direction", &spotLightDirection.x, -1.0f, 1.0f);
		ImGui::SliderFloat("Spot Light Intensity", &spotLightIntensity, 0.0f, 1.0f);
		ImGui::SliderFloat("Spot Light Distance", &spotLightDistance, 0.0f, 50.0f);
		ImGui::SliderFloat("Spot Light Decay", &spotLightDecay, 0.0f, 1.0f);
		ImGui::SliderFloat("Spot Light Cons Angle", &spotLightConsAngle, 0.0f, 10.0f);
		ImGui::SliderFloat("Spot Light Cos FalloffStart", &spotLightCosFalloffStart, 0.0f, 1.0f);
	}

	ImGui::Checkbox("Enable Environment", &enableEnvironment);
	if (enableEnvironment)
	{
		ImGui::SliderFloat("Environment Strength", &environmentStrength_, 0.0f, 1.0f);
	}


	ImGui::End();

	pPlayer_->ImGuiDraw();
	pEnemyManager_->ImGuiDraw();
	pField_->ImGuiDraw();

#endif // USE_IMGUI

	

	if (Input::GetInstance()->TriggerKey(DIK_RETURN))
	{
		// ãƒˆãƒ©ãƒ³ã‚¸ã‚·ãƒ§ãƒ³é–‹å§‹
		transition_ = std::make_unique<BlockRiseTransition>();
		isTransitioning_ = true;
		transition_->Start([]
			{
				// ãƒ•ã‚§ãƒ¼ãƒ‰ã‚¢ã‚¦ãƒˆå¾Œã«ã‚·ãƒ¼ãƒ³åˆ‡ã‚Šæ›¿ãˆ
				SceneManager::GetInstance()->ChangeScene("GAMEPLAY");
			});
	}

	if (Input::GetInstance()->TriggerKey(DIK_Q))
	{
		Audio::GetInstance()->SoundStop(soundData_);
	}
	if (Input::GetInstance()->TriggerKey(DIK_E))
	{
		Audio::GetInstance()->SoundStop(soundData2_);
	}
}

void TitleScene::Draw()
{
	// æç”»å‰å‡¦ç†(Object)
	Object3dCommon::GetInstance()->CommonDrawSetting();

	// ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼
	pPlayer_->Draw();
	// ã‚¨ãƒãƒŸãƒ¼
	pEnemyManager_->Draw();
	// ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰
	pField_->Draw();

	// æç”»å‰å‡¦ç†(Sprite)
	SpriteCommon::GetInstance()->CommonDrawSetting();

	for (auto& sprite : sprites_)
	{
		sprite->Draw();
	}

	// ãƒˆãƒ©ãƒ³ã‚¸ã‚·ãƒ§ãƒ³æç”»
	if (isTransitioning_ && transition_) 
	{
		transition_->Draw();
	}
	
}

void TitleScene::CameraUpdate()
{
	// ã‚«ãƒ¡ãƒ©ã®ã‚·ã‚§ã‚¤ã‚¯
	CameraShake();

	// ã‚«ãƒ¡ãƒ©ã®è¿½å¾“
	CameraFollow();
}

void TitleScene::CameraShake()
{
	// ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ã‚«ãƒ¡ãƒ©ã®æƒ…å ±ã‚’å–å¾—
	auto activeCamera = cameraManager.GetActiveCamera();
	if (activeCamera)
	{
		auto viewMatrix = activeCamera->GetViewMatrix();
	}

	// ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ãŒãƒ’ãƒƒãƒˆã—ãŸå ´åˆã«ã‚«ãƒ¡ãƒ©ã‚’ã‚·ã‚§ã‚¤ã‚¯
	if (pPlayer_->IsHitMoment())
	{
		// ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ãªã‚«ãƒ¡ãƒ©ã‚’å–å¾—
		if (activeCamera)
		{
			// ã‚«ãƒ¡ãƒ©ã‚’ã‚·ã‚§ã‚¤ã‚¯ (æŒç¶šæ™‚é–“,æŒ¯å¹…)
			activeCamera->StartShake(0.3f, 0.5f);

			// ãƒ’ãƒƒãƒˆãƒ•ãƒ©ã‚°ã‚’ãƒªã‚»ãƒƒãƒˆ
			pPlayer_->SetHitMoment(false);
		}
	}

	// ã‚·ã‚§ã‚¤ã‚¯
	if (activeCamera)
	{
		activeCamera->UpdateShake(1.0f / 60.0f);
	}
}

void TitleScene::CameraFollow()
{
	if (!camera_ or !pPlayer_)
	{
		return;
	}

	Vector3 playerPos = pPlayer_->GetPosition();

	// å›ºå®šã®ã‚ªãƒ•ã‚»ãƒƒãƒˆï¼ˆãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‹ã‚‰è¦‹ãŸã‚«ãƒ¡ãƒ©ä½ç½®ï¼‰
	Vector3 offset = { 0.0f, 80.0f, -20.0f };  // Y: é«˜ã•ã€Z: å¾Œæ–¹

	// è¿½å¾“å…ˆã®ä½ç½®ãƒ»å›žè»¢
	Vector3 targetPos = playerPos + offset;
	Vector3 targetRot = { 2.0f, 0.0f, 0.0f };  // ã‚„ã‚„ä¸‹å‘ã

	// æ»‘ã‚‰ã‹ã«è£œé–“ã—ã¦è¿½å¾“
	Vector3 currentPos = camera_->GetPosition();
	Vector3 nextPos;
	nextPos.Lerp(currentPos, targetPos, 0.8f);

	Vector3 currentRot = camera_->GetRotate();
	Vector3 nextRot;
	nextRot.Lerp(currentRot, targetRot, 0.25f);

	camera_->SetPosition(nextPos);
	camera_->SetRotate(nextRot);

}



============================================================
File Path: project/application/scene/TitleScene.h
============================================================
#pragma once

#include <Framework.h>
#include <vector>
#include <memory>
#include <MyMath.h>
#include <Object3d.h>
#include <Vector3.h>

#include "../../gameEngine/baseScene/BaseScene.h"
#include "../../gameEngine/particle/ParticleEmitter.h"

#include "../../application/objects/player/Player.h"
#include "../../application/objects/enemy/EnemyManager.h"
#include "../../application/objects/field/Field.h"

#include "../../gameEngine/transition/BlockRiseTransition.h"

/// <summary>
/// ã‚¿ã‚¤ãƒˆãƒ«ã‚·ãƒ¼ãƒ³
/// ã‚¿ã‚¤ãƒˆãƒ«ãƒ­ã‚´è¡¨ç¤ºã€ã‚¨ãƒ•ã‚§ã‚¯ãƒˆã€BGMå†ç”Ÿã€ã‚·ãƒ¼ãƒ³é·ç§»
/// </summary>
class TitleScene : public BaseScene
{
public:

	// åˆæœŸåŒ–
	void Initialize() override;
	
	// çµ‚äº†
	void Finalize() override;
	
	// æ›´æ–°
	void Update() override;
	
	// æç”»
	void Draw() override;

private: // å†…éƒ¨å‡¦ç†

	// ã‚«ãƒ¡ãƒ©æ›´æ–°
	void CameraUpdate();

	// ã‚«ãƒ¡ãƒ©ã‚·ã‚§ã‚¤ã‚¯
	void CameraShake();

	// ã‚«ãƒ¡ãƒ©è¿½å°¾
	void CameraFollow();


private:

	// ã‚«ãƒ¡ãƒ©
	CameraManager& cameraManager = CameraManager::GetInstance();
	std::shared_ptr<Camera> camera_ = std::make_shared<Camera>();
	Vector3 cameraPosition_{};
	Vector3 cameraRotate_{};

	// é·ç§»
	std::unique_ptr<BlockRiseTransition> transition_ = nullptr;
	bool isTransitioning_ = false;

	// 2Dã‚¹ãƒ—ãƒ©ã‚¤ãƒˆ
	std::vector<std::unique_ptr<Sprite>>sprites_ = {};
	// æç”»ã™ã‚‹ã‚¹ãƒ—ãƒ©ã‚¤ãƒˆã®æ•°
	uint32_t spriteNum_ = 1;

	// è¡çªåˆ¤å®š
	ColliderManager* colliderManager_ = nullptr;

	// ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼
	std::unique_ptr<Player> pPlayer_ = nullptr;

	// ã‚¨ãƒãƒŸãƒ¼
	std::unique_ptr<EnemyManager> pEnemyManager_ = nullptr;

	// ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰
	std::unique_ptr<Field> pField_ = nullptr;


	// é€æ˜Žãƒã‚§ãƒƒã‚¯
	Vector4 color_ = { 1.0f,1.0f,1.0f,1.0f };

	// ã‚µã‚¦ãƒ³ãƒ‰
	SoundData soundData_;
	SoundData soundData2_;

	bool isTerrainDraw = false;
	bool enableLighting = false;
	bool enableDirectionalLight = false;
	bool enablePointLight = false;
	bool enableSpotLight = false;
	bool enableEnvironment = false;

	// ãƒ©ã‚¤ãƒˆã®è©³ç´°è¨­å®šç”¨å¤‰æ•°
	Vector3 directionalLightColor = { 1.0f, 1.0f, 1.0f };
	Vector3 directionalLightDirection = { 0.0f, -1.0f, 0.0f };
	float directionalLightIntensity = 1.0f;

	Vector3 pointLightColor = { 1.0f, 1.0f, 1.0f };
	Vector3 pointLightPosition = { 0.0f, 2.0f, 0.0f };
	float pointLightIntensity = 1.0f;
	float pointLightRadius = 10.0f;
	float pointLightDecay = 1.0f;

	Vector3 spotLightColor = { 1.0f, 1.0f, 1.0f };
	Vector3 spotLightPosition = { 2.0f, 1.25f, 0.0f };
	Vector3 spotLightDirection = Normalize({ 1.0f, 1.0f, 0.0f });
	float spotLightIntensity = 4.0f;
	float spotLightDistance = 7.0f;
	float spotLightDecay = 2.0f;
	float spotLightConsAngle = std::cos(std::numbers::pi_v<float> / 3.0f);
	float spotLightCosFalloffStart = 1.0f;

	// ç’°å¢ƒãƒžãƒƒãƒ—
    std::string cubeMapPath_ = "";
	uint32_t cubeSrvIndex_ = 0u;
	D3D12_GPU_DESCRIPTOR_HANDLE cubeHandle_ = { 0 };
	float environmentStrength_ = 1.0f;


	// ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ç”¨å¤‰æ•°
	float time_ = 0.0f;

};

============================================================
File Path: project/gameEngine/2d/Sprite.cpp
============================================================
#include "Sprite.h"

#include "SpriteCommon.h"

#include <fstream>

void Sprite::Initialize(std::string textureFilePath,
	Vector2 position, Vector4 color, Vector2 anchorpoint)
{
	spriteCommon_ = SpriteCommon::GetInstance();

	std::ifstream file;
	// åŸºæœ¬ãƒ‘ã‚¹ã‚’æŒ‡å®šï¼ˆ"Resources/images/"ï¼‰
	std::string basePath = "resources/images/";
	std::string fullPath = basePath + textureFilePath;
	textureFilePath_ = fullPath;

	vertexResource_ = spriteCommon_->GetDxCommon()->CreateBufferResource(sizeof(VertexData) * 4);
	indexResource_ = spriteCommon_->GetDxCommon()->CreateBufferResource(sizeof(uint32_t) * 6);
	materialResource_ = spriteCommon_->GetDxCommon()->CreateBufferResource(sizeof(Material));
	transformationMatrixResource_ = spriteCommon_->GetDxCommon()->CreateBufferResource(sizeof(TransformationMatrix));

	TextureManager::GetInstance()->LoadTexture(textureFilePath_);
	//ãƒªã‚½ãƒ¼ã‚¹ã®å…ˆé ­ã‚¢ãƒ‰ãƒ¬ã‚¹ã‹ã‚‰ä½¿ã†
	vertexBufferView_.BufferLocation = vertexResource_->GetGPUVirtualAddress();
	//ä½¿ç”¨ã™ã‚‹ãƒªã‚½ãƒ¼ã‚¹ã®ã‚µã‚¤ã‚ºã¯é ‚ç‚¹ï¼–ã¤åˆ†ã®ã‚µã‚¤ã‚º
	vertexBufferView_.SizeInBytes = sizeof(VertexData) * 4;
	//1é ‚ç‚¹å½“ãŸã‚Šã®ã‚µã‚¤ã‚º
	vertexBufferView_.StrideInBytes = sizeof(VertexData);

	//ãƒªã‚½ãƒ¼ã‚¹ã®å…ˆé ­ã®ã‚¢ãƒ‰ãƒ¬ã‚¹ã‹ã‚‰ä½¿ã†
	indexBufferView_.BufferLocation = indexResource_->GetGPUVirtualAddress();
	//ä½¿ç”¨ã™ã‚‹ãƒªã‚½ãƒ¼ã‚¹ã®ã‚µã‚¤ã‚ºã‚’ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹6ã¤åˆ†ã®ã‚µã‚¤ã‚º
	indexBufferView_.SizeInBytes = sizeof(uint32_t) * 6;
	//ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã¯uint32_tã¨ã™ã‚‹
	indexBufferView_.Format = DXGI_FORMAT_R32_UINT;


	vertexResource_->Map(0, nullptr, reinterpret_cast<void**>(&vertexData_));


	//IndexResourceã«ãƒ‡ãƒ¼ã‚¿ã‚’æ›¸ãè¾¼ã‚€
	indexResource_->Map(0, nullptr, reinterpret_cast<void**>(&indexData_));

	//æ›¸ãè¾¼ã‚€ãŸã‚ã®ã‚¢ãƒ‰ãƒ¬ã‚¹ã‚’å–å¾—
	materialResource_->Map(0, nullptr, reinterpret_cast<void**>(&materialData_));


	// ãƒžãƒ†ãƒªã‚¢ãƒ«ãƒ‡ãƒ¼ã‚¿ã«ãƒ‡ãƒ¼ã‚¿ã®åˆæœŸå€¤ã‚’æ›¸ãè¾¼ã‚€
	materialData_->color = Vector4(1.0f, 1.0f, 1.0f, 1.0f);
	materialData_->uvTransform = MakeIdentity4x4();

	//æ›¸ãè¾¼ã‚€ãŸã‚ã®ã‚¢ãƒ‰ãƒ¬ã‚¹
	transformationMatrixResource_->Map(0, nullptr, reinterpret_cast<void**>(&transformationMatrixData_));
	//å˜ä½è¡Œåˆ—ã‚’æ›¸ãè¾¼ã‚“ã§ãŠã
	transformationMatrixData_->World = MakeIdentity4x4();
	transformationMatrixData_->WVP = MakeIdentity4x4();

	transform_ = {
		{1.0f,1.0f,1.0f},
		{0.0f,0.0f,0.0f},
		{0.0f,0.0f,0.0f}
	};

	// å˜ä½è¡Œåˆ—ã‚’æ›¸ãè¾¼ã‚“ã§ãŠã
	textureIndex = TextureManager::GetInstance()->GetTextureIndexByFilePath(textureFilePath_);

	AdjustTextureSize();

	SetPosition(position);
	SetColor(color);
	SetAnchorPoint(anchorpoint);

	color_ = color;
}

void Sprite::Update()
{
	// ã‚¹ã‚¯ãƒªãƒ¼ãƒ³è¿½å¾“ãƒ¢ãƒ¼ãƒ‰ FollowWorldPosition
	if (followWorldPositionPtr_ != nullptr && worldToScreenFunc_)
	{
		Vector3 worldPosWithOffset = {
			followWorldPositionPtr_->x + followWorldOffset_.x,
			followWorldPositionPtr_->y + followWorldOffset_.y,
			followWorldPositionPtr_->z + followWorldOffset_.z
		};
		// worldToScreenFunc_ ã¯ã‚¹ã‚¯ãƒªãƒ¼ãƒ³åº§æ¨™ã‚’è¿”ã™
		Vector2 screenPos = worldToScreenFunc_(worldPosWithOffset);
		position_.x = screenPos.x;
		position_.y = screenPos.y;
	}
	// è¦ªè¡Œåˆ—è¿½å¾“ãƒ¢ãƒ¼ãƒ‰ FollowParentWorldMatrix
	else if (parentWorldMatrixPtr_ != nullptr)
	{
		// local transform ã‚’ä½œã‚‹
		Transform localTransform = transform_;
		localTransform.translate = parentLocalOffset_;
		// ãƒ­ãƒ¼ã‚«ãƒ«è¡Œåˆ—ã‚’ä½œã‚‹
		Matrix4x4 localWorld = MakeAffineMatrix(localTransform.scale, localTransform.rotate, localTransform.translate);
		// è¦ªãƒ¯ãƒ¼ãƒ«ãƒ‰è¡Œåˆ—ã¨åˆæˆ
		Matrix4x4 composedWorld = Multiply(*parentWorldMatrixPtr_, localWorld);
		// World è¡Œåˆ—ã‚’ç›´æŽ¥ã‚»ãƒƒãƒˆ
		transformationMatrixData_->World = composedWorld;
		// viewProjPtr_ ãŒã‚»ãƒƒãƒˆã•ã‚Œã¦ã„ã‚Œã° WVP ã‚’è¨ˆç®—
		if (viewProjPtr_ != nullptr)
		{
			transformationMatrixData_->WVP = Multiply(composedWorld, *viewProjPtr_);
		}
	}

	float left = 0.0f - anchorPoint_.x;
	float right = 1.0f - anchorPoint_.x;
	float top = 0.0f - anchorPoint_.y;
	float bottom = 1.0f - anchorPoint_.y;

	// å·¦å³åè»¢
	if (isFlipX_)
	{
		left = -left;
		right = -right;
	}

	// ä¸Šä¸‹åè»¢
	if (isFlipY_)
	{
		top = -top;
		bottom = -bottom;
	}

	// è‰²ã¨é€æ˜Žåº¦ã‚’æ›´æ–°
	if (materialData_ != nullptr)
	{
		materialData_->color = color_;
	}

	const DirectX::TexMetadata& metadata = TextureManager::GetInstance()->GetMetaData(textureFilePath_);
	float tex_left = textureLeftTop_.x / metadata.width;
	float tex_right = (textureLeftTop_.x + textureSize_.x) / metadata.width;
	float tex_top = textureLeftTop_.y / metadata.height;
	float tex_bottom = (textureLeftTop_.y + textureSize_.y) / metadata.height;

	if (tex_right > 1.0f)
	{
		tex_right = 1.0f;
	}

	vertexData_[0].position = { left,bottom,0.0f,1.0f };
	vertexData_[0].texcoord = { tex_left,tex_bottom };
	vertexData_[0].normal = { 0.0f,0.0f,-1.0f };

	vertexData_[1].position = { left,top,0.0f,1.0f };
	vertexData_[1].texcoord = { tex_left,tex_top };
	vertexData_[1].normal = { 0.0f,0.0f,-1.0f };

	vertexData_[2].position = { right,bottom,0.0f,1.0f };
	vertexData_[2].texcoord = { tex_right,tex_bottom };
	vertexData_[2].normal = { 0.0f,0.0f,-1.0f };

	vertexData_[3].position = { right,top,0.0f,1.0f };
	vertexData_[3].texcoord = { tex_right,tex_top };
	vertexData_[3].normal = { 0.0f,0.0f,-1.0f };

	indexData_[0] = 0;		indexData_[1] = 1;		indexData_[2] = 2;
	indexData_[3] = 1;		indexData_[4] = 3;		indexData_[5] = 2;


	transform_.translate = { position_.x,position_.y ,0.0f };
	transform_.rotate = { 0.0f,0.0f,rotation_ };
	transform_.scale = { size_.x,size_.y,1.0f };

	// è¦ªè¡Œåˆ—è¿½å¾“ã§ãªã„å ´åˆã¯é€šå¸¸é€šã‚Š WVP ã‚’ä½œã‚‹
	if (parentWorldMatrixPtr_ == nullptr)
	{
		Matrix4x4 worldMatrixSprite = MakeAffineMatrix(transform_.scale, transform_.rotate, transform_.translate);
		Matrix4x4 viewMatrixSprite = MakeIdentity4x4();
		Matrix4x4 projectionMatrixSprite = MakeOrthographicMatrix(0.0f, 0.0f, float(WinApp::kClientWidth), float(WinApp::kClientHeight), 0.0f, 100.0f);
		Matrix4x4 worldViewProjectionMatrixSprite = Multiply(worldMatrixSprite, Multiply(viewMatrixSprite, projectionMatrixSprite));
		transformationMatrixData_->WVP = worldViewProjectionMatrixSprite;
		transformationMatrixData_->World = worldMatrixSprite;
	}

}

void Sprite::Draw()
{

	// Spriteã®æç”»ã€‚å¤‰æ›´ãŒå¿…è¦ãªã‚‚ã®ã ã‘å¤‰æ›´ã™ã‚‹
	spriteCommon_->GetDxCommon()->GetCommandList()->IASetVertexBuffers(0, 1, &vertexBufferView_);
	// IBVã‚’è¨­å®š
	spriteCommon_->GetDxCommon()->GetCommandList()->IASetIndexBuffer(&indexBufferView_);


	// ãƒžãƒ†ãƒªã‚¢ãƒ«CBufferã®å ´æ‰€ã‚’è¨­å®š
	spriteCommon_->GetDxCommon()->GetCommandList()->SetGraphicsRootConstantBufferView(0, materialResource_->GetGPUVirtualAddress());
	// TransformationMatrixCBufferã®å ´æ‰€ã‚’è¨­å®š
	spriteCommon_->GetDxCommon()->GetCommandList()->SetGraphicsRootConstantBufferView(1, transformationMatrixResource_->GetGPUVirtualAddress());

	// SRVã®DescriptorTableã®å…ˆé ­ã‚’è¨­å®šã€‚2ã¯rootPatameter[2]ã§ã‚ã‚‹ã€‚
	spriteCommon_->GetDxCommon()->GetCommandList()->SetGraphicsRootDescriptorTable(2, TextureManager::GetInstance()->GetSrvHandleGPU(textureFilePath_));
	// ã‚¹ãƒ—ãƒ©ã‚¤ãƒˆã®æç”»(DrawCall//ãƒ‰ãƒ­ãƒ¼ã‚³ãƒ¼ãƒ«)
	spriteCommon_->GetDxCommon()->GetCommandList()->DrawIndexedInstanced(6, 1, 0, 0, 0);


}

void Sprite::FollowWorldPosition(const Vector3* worldPosPtr, Vector3 offset)
{
	// ãƒ¯ãƒ¼ãƒ«ãƒ‰åº§æ¨™ãƒã‚¤ãƒ³ã‚¿ã‚’ä¿å­˜
	followWorldPositionPtr_ = worldPosPtr;
	// ã‚ªãƒ•ã‚»ãƒƒãƒˆã‚’ä¿å­˜
	followWorldOffset_ = offset;
}

void Sprite::FollowParentWorldMatrix(const Matrix4x4* parentWorldPtr, bool followRotation, Vector3 localOffset)
{
	// è¦ªã®ãƒ¯ãƒ¼ãƒ«ãƒ‰è¡Œåˆ—ãƒã‚¤ãƒ³ã‚¿ã‚’ä¿å­˜
	parentWorldMatrixPtr_ = parentWorldPtr;
	// å›žè»¢è¿½å¾“ãƒ•ãƒ©ã‚°ã‚’ä¿å­˜		
	parentFollowRotation_ = followRotation;
	// ãƒ­ãƒ¼ã‚«ãƒ«ã‚ªãƒ•ã‚»ãƒƒãƒˆã‚’ä¿å­˜
	parentLocalOffset_ = localOffset;
}

void Sprite::StopFollowing()
{
	// è¿½å¾“ãƒã‚¤ãƒ³ã‚¿ã‚’nullptrã«è¨­å®š
	followWorldPositionPtr_ = nullptr;
	parentWorldMatrixPtr_ = nullptr;
	worldToScreenFunc_ = nullptr;
}

void Sprite::SetColorChange(const Vector4& color)
{
	color_ = color;
	if (materialData_ != nullptr)
	{
		materialData_->color = color_;
	}
}

void Sprite::AdjustTextureSize()
{
	// ãƒ†ã‚¯ã‚¹ãƒãƒ£ãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿ã‚’å–å¾—
	const DirectX::TexMetadata& metadata = TextureManager::GetInstance()->GetMetaData(textureFilePath_);

	//textureSize_.x = static_cast<float>(metadata.width);
	//textureSize_.y = static_cast<float>(metadata.height);
	
	textureLeftTop_ = { 0.0f,0.0f };
	textureSize_ = { static_cast<float>(metadata.width), static_cast<float>(metadata.height) };
	
	// ç”»åƒã‚µã‚¤ã‚ºã‚’ãƒ†ã‚¯ã‚¹ãƒãƒ£ã‚µã‚¤ã‚ºã«åˆã‚ã›ã‚‹
	size_ = textureSize_;
}

============================================================
File Path: project/gameEngine/2d/Sprite.h
============================================================

#pragma once

#include <d3d12.h>
#include <dxgi1_6.h>
#include <functional>

#include "../../externals/DirectXTex/DirectXTex.h"
#include "../../externals/DirectXTex/d3dx12.h"

#include "MyMath.h"
#include "TextureManager.h"

class SpriteCommon;


/// <summary>
/// ã‚¹ãƒ—ãƒ©ã‚¤ãƒˆ
/// </summary>
class Sprite
{
public:

	/// <summary>
	/// åˆæœŸåŒ–
	/// </summary>
	/// <param name="textureFilePath">ãƒ†ã‚¯ã‚¹ãƒãƒ£ãƒ•ã‚¡ã‚¤ãƒ«ãƒ‘ã‚¹</param>
	/// <param name="position">åº§æ¨™</param>
	/// <param name="color">è‰²</param>
	/// <param name="anchorpoint">ã‚¢ãƒ³ã‚«ãƒ¼ãƒã‚¤ãƒ³ãƒˆ</param>
	void Initialize(std::string textureFilePath,Vector2 position, Vector4 color = { (1) , (1), (1), (1) }, Vector2 anchorpoint = { 0.0f,0.0f });

	// æ›´æ–°
	void Update();

	// æç”»
	void Draw();

	/// <summary>
	/// ãƒ¯ãƒ¼ãƒ«ãƒ‰åº§æ¨™è¿½å¾“
	/// </summary>
	/// <param name="worldPosPtr">ãƒ¯ãƒ¼ãƒ«ãƒ‰åº§æ¨™ãƒã‚¤ãƒ³ã‚¿</param>
	/// <param name="offset">ã‚ªãƒ•ã‚»ãƒƒãƒˆ</param>
	void FollowWorldPosition(const Vector3* worldPosPtr,Vector3 offset = {0,0,0});

	/// <summary>
	/// è¦ªã®ãƒ¯ãƒ¼ãƒ«ãƒ‰è¡Œåˆ—è¿½å¾“
	/// </summary>
	/// <param name="parentWorldMatrix">è¦ªã®ãƒ¯ãƒ¼ãƒ«ãƒ‰è¡Œåˆ—ãƒã‚¤ãƒ³ã‚¿</param>
	/// <param name="followRotation">å›žè»¢è¿½å¾“ãƒ•ãƒ©ã‚°</param>
	/// <param name="localOffset">ãƒ­ãƒ¼ã‚«ãƒ«ã‚ªãƒ•ã‚»ãƒƒãƒˆ</param>
	void FollowParentWorldMatrix(const Matrix4x4* parentWorldPtr, bool followRotation = true, Vector3 localOffset = { 0,0,0 });

	// è¿½å¾“ã‚’åœæ­¢ã™ã‚‹
	void StopFollowing();

public:// ã‚²ãƒƒã‚¿ãƒ¼

	// åº§æ¨™å–å¾—
	const Vector2& GetPosition()const { return position_; }
	// å›žè»¢å–å¾—
	float GetRotation() const { return rotation_; }
	// è‰²å–å¾—
	const Vector4& GetColor() const { return materialData_->color; }
	// ã‚µã‚¤ã‚ºå–å¾—
	const Vector2& GetSize()const { return size_; }
	// ã‚¢ãƒ³ã‚«ãƒ¼ãƒã‚¤ãƒ³ãƒˆå–å¾—
	const Vector2& GetAnchorPoint()const { return anchorPoint_; }
	// ãƒ•ãƒªãƒƒãƒ—Xå–å¾—
	const bool& IsFlipX()const { return isFlipX_; }
	// ãƒ•ãƒªãƒƒãƒ—Yå–å¾—
	const bool& IsFlipY()const { return isFlipY_; }
	// ãƒ†ã‚¯ã‚¹ãƒãƒ£å·¦ä¸Šåº§æ¨™å–å¾—
	const Vector2& GetTextureLeftTop()const { return textureLeftTop_; }
	// ãƒ†ã‚¯ã‚¹ãƒãƒ£åˆ‡ã‚Šå‡ºã—ã‚µã‚¤ã‚ºå–å¾—
	const Vector2& GetTextureSize()const { return textureSize_; }

public:// ã‚»ãƒƒã‚¿ãƒ¼

	/// <summary>
	/// åº§æ¨™è¨­å®š
	/// </summary>
	/// <param name="position">åº§æ¨™</param>
	void SetPosition(const Vector2& position) { position_ = position; }
	
	/// <summary>
	/// å›žè»¢è¨­å®š
	/// </summary>
	///	<param name="rotation">å›žè»¢è§’</param>
	void SetRotation(float rotation) { rotation_ = rotation; }

	/// <summary>
	/// è‰²è¨­å®š
	/// </summary>
	/// <param name="color">è‰²</param>
	void SetColor(const Vector4& color) { materialData_->color = color; }

	/// <summary>
	/// è‰²å¤‰æ›´è¨­å®š
	/// </summary>
	/// <param name="color">è‰²å¤‰æ›´é‡</param>
	void SetColorChange(const Vector4& color);

	/// <summary>
	/// ã‚µã‚¤ã‚ºè¨­å®š
	/// </summary>
	/// <param name="size">ã‚µã‚¤ã‚º</param>
	void SetSize(const Vector2& size) { size_ = size; }

	/// <summary>
	/// ã‚¢ãƒ³ã‚«ãƒ¼ãƒã‚¤ãƒ³ãƒˆè¨­å®š
	/// </summary>
	/// <param name="anchorPoint">ã‚¢ãƒ³ã‚«ãƒ¼ãƒã‚¤ãƒ³ãƒˆ</param>
	void SetAnchorPoint(const Vector2& anchorPoint) { anchorPoint_ = anchorPoint; }

	/// <summary>
	/// ãƒ•ãƒªãƒƒãƒ—Xè¨­å®š
	/// </summary>
	/// <param name="IsFlipX">ãƒ•ãƒªãƒƒãƒ—Xãƒ•ãƒ©ã‚°</param>
	void SetFlipX(const bool& IsFlipX) { isFlipX_ = IsFlipX; }
	
	/// <summary>
	/// ãƒ•ãƒªãƒƒãƒ—Yè¨­å®š
	/// </summary>
	/// <param name="IsFlipY">ãƒ•ãƒªãƒƒãƒ—Yãƒ•ãƒ©ã‚°</param>
	void SetFlipY(const bool& IsFlipY) { isFlipY_ = IsFlipY; }

	/// <summary>
	/// ãƒ†ã‚¯ã‚¹ãƒãƒ£å·¦ä¸Šåº§æ¨™è¨­å®š
	/// </summary>
	/// <param name="textureLeftTop">ãƒ†ã‚¯ã‚¹ãƒãƒ£å·¦ä¸Šåº§æ¨™</param>
	void SetTextureLeftTop(const Vector2& textureLeftTop) { textureLeftTop_ = textureLeftTop; }
	
	/// <summary>
	/// ãƒ†ã‚¯ã‚¹ãƒãƒ£åˆ‡ã‚Šå‡ºã—ã‚µã‚¤ã‚ºè¨­å®š
	/// </summary>
	/// 
	void SetTextureSize(const Vector2& textureSize) { textureSize_ = textureSize; }

	/// <summary>
	/// ãƒ¯ãƒ¼ãƒ«ãƒ‰åº§æ¨™ã‚’ã‚¹ã‚¯ãƒªãƒ¼ãƒ³åº§æ¨™ã«å¤‰æ›ã™ã‚‹é–¢æ•°ã®è¨­å®š
	/// </summary>
	/// <param name="func">å¤‰æ›é–¢æ•°</param>
	void SetWorldToScreenFunc(std::function<Vector2(const Vector3&)> func) { worldToScreenFunc_ = func; }

	/// <summary>
	///	ãƒ“ãƒ¥ãƒ¼å°„å½±è¡Œåˆ—ãƒã‚¤ãƒ³ã‚¿è¨­å®š
	/// </summary>
	/// <param name="viewProjPtr">ãƒ“ãƒ¥ãƒ¼å°„å½±è¡Œåˆ—ãƒã‚¤ãƒ³ã‚¿</param>
	void SetViewProjectionMatrixPtr(const Matrix4x4* viewProjPtr) { viewProjPtr_ = viewProjPtr; }

private: // å†…éƒ¨é–¢æ•°

	// ãƒ†ã‚¯ã‚¹ãƒãƒ£ã‚µã‚¤ã‚ºã‚’ã‚¤ãƒ¡ãƒ¼ã‚¸ã«åˆã‚ã›ã‚‹
	void AdjustTextureSize();

private: // æ§‹é€ ä½“ã€é–¢æ•°

	struct Transform
	{
		Vector3 scale;
		Vector3 rotate;
		Vector3 translate;
	};

	struct VertexData
	{
		Vector4 position;
		Vector2 texcoord;
		Vector3 normal;
	};

	struct Material
	{
		Vector4 color;
		Matrix4x4 uvTransform;
	};

	struct TransformationMatrix
	{
		Matrix4x4 WVP;
		Matrix4x4 World;
	};


private:

	// spriteCommon
	SpriteCommon* spriteCommon_ = nullptr;
	std::string textureFilePath_;

	// å®šæ•°ãƒãƒƒãƒ•ã‚¡ã®å®£è¨€
	Microsoft::WRL::ComPtr<ID3D12Resource> constantBuffer_;

	// ãƒãƒƒãƒ•ã‚¡ãƒªã‚½ãƒ¼ã‚¹
	//ã‚¹ãƒ—ãƒ©ã‚¤ãƒˆç”¨ã®é ‚ç‚¹ãƒªã‚½ãƒ¼ã‚¹ã‚’ä½œã‚‹
	Microsoft::WRL::ComPtr<ID3D12Resource> vertexResource_{};
	//IndexResourceã‚’ç”Ÿæˆã™ã‚‹
	Microsoft::WRL::ComPtr<ID3D12Resource> indexResource_{};
	// ãƒžãƒ†ãƒªã‚¢ãƒ«ãƒªã‚½ãƒ¼ã‚¹
	Microsoft::WRL::ComPtr<ID3D12Resource> materialResource_{};
	//VertexShaderã§åˆ©ç”¨ã™ã‚‹TransformationMatrixç”¨ã®Resourceã‚’ä½œã‚‹
	Microsoft::WRL::ComPtr<ID3D12Resource> transformationMatrixResource_{};

	// ãƒãƒƒãƒ•ã‚¡ãƒªã‚½ãƒ¼ã‚¹å†…ã®ãƒ‡ãƒ¼ã‚¿ã‚’æŒ‡ã™ãƒã‚¤ãƒ³ã‚¿
	VertexData* vertexData_ = nullptr;
	uint32_t* indexData_ = nullptr;
	Material* materialData_ = nullptr;
	TransformationMatrix* transformationMatrixData_ = nullptr;
	// ãƒãƒƒãƒ•ã‚¡ãƒªã‚½ãƒ¼ã‚¹ã®ä½¿ã„é“ã‚’è£œè¶³ã™ã‚‹ãƒãƒƒãƒ•ã‚¡ãƒ“ãƒ¥ãƒ¼
	D3D12_VERTEX_BUFFER_VIEW vertexBufferView_;
	D3D12_INDEX_BUFFER_VIEW indexBufferView_;

	Microsoft::WRL::ComPtr<ID3D12Resource> textureResource_;
	Microsoft::WRL::ComPtr<ID3D12Resource> intermediateResource_;

	D3D12_SHADER_RESOURCE_VIEW_DESC srvDesc_{};

	// ãƒ†ã‚¯ã‚¹ãƒãƒ£ç•ªå·
	uint32_t textureIndex = 0;

	Transform transform_;

	Vector2 position_ = { 0.0f,50.0f };
	float rotation_ = 0.0f;

	Vector2 size_ = { 640.0f,360.0f };

	// ã‚¢ãƒ³ã‚«ãƒ¼ãƒã‚¤ãƒ³ãƒˆ
	Vector2 anchorPoint_ = { 0.0f,0.0f };

	// å·¦å³ãƒ•ãƒªãƒƒãƒ—
	bool isFlipX_ = false;
	// ä¸Šä¸‹ãƒ•ãƒªãƒƒãƒ—
	bool isFlipY_ = false;

	// ãƒ†ã‚¯ã‚¹ãƒãƒ£å·¦ä¸Šåº§æ¨™
	Vector2 textureLeftTop_ = { 0.0f,0.0f };
	// ãƒ†ã‚¯ã‚¹ãƒãƒ£åˆ‡ã‚Šå‡ºã—ã‚µã‚¤ã‚º
	Vector2 textureSize_ = { 100.0f,100.0f };

	Vector4 color_{};

	// ãƒ¯ãƒ¼ãƒ«ãƒ‰åº§æ¨™è¿½å¾“
	const Vector3* followWorldPositionPtr_ = nullptr;
	Vector3 followWorldOffset_ = { 0,0,0 };
	std::function<Vector2(const Vector3&)> worldToScreenFunc_; // å¤–éƒ¨ã‹ã‚‰æ¸¡ã™

	// è¦ªãƒ¯ãƒ¼ãƒ«ãƒ‰è¡Œåˆ—è¿½å¾“
	const Matrix4x4* parentWorldMatrixPtr_ = nullptr;
	Vector3 parentLocalOffset_ = { 0,0,0 };
	bool parentFollowRotation_ = true;

	// è¦ªè¡Œåˆ—è¿½å¾“ã®ãŸã‚ã« viewProjection ã‚’å¤–éƒ¨ã‹ã‚‰æ¸¡ã™ï¼ˆWVP ã®è¨ˆç®—ã«å¿…è¦ï¼‰
	const Matrix4x4* viewProjPtr_ = nullptr;

};


============================================================
File Path: project/gameEngine/2d/SpriteCommon.cpp
============================================================
#include "SpriteCommon.h"

#include <cassert>

SpriteCommon* SpriteCommon::GetInstance()
{
	static SpriteCommon instance;
	return &instance;
}

void SpriteCommon::Finalize(){}

void SpriteCommon::Initialize(DirectXCommon* dxCommon)
{
	dxCommon_ = dxCommon;
	device_ = dxCommon_->GetDevice();
	commandList_ = dxCommon_->GetCommandList();

	//ãƒ‡ã‚£ã‚¹ã‚¯ãƒªãƒ—ã‚¿ãƒ¬ãƒ³ã‚¸ã®ç”Ÿæˆ
	descriptorRange_[0].BaseShaderRegister = 0;
	descriptorRange_[0].NumDescriptors = 1;
	descriptorRange_[0].RangeType = D3D12_DESCRIPTOR_RANGE_TYPE_SRV;
	descriptorRange_[0].OffsetInDescriptorsFromTableStart = D3D12_DESCRIPTOR_RANGE_OFFSET_APPEND;


	//DepthStencilStateã®è¨­å®š
	//Depthã®æ©Ÿèƒ½ã‚’æœ‰åŠ¹åŒ–ã™ã‚‹
	depthStencilDesc_.DepthEnable = true;
	//æ›¸ãè¾¼ã¿ã—ã¾ã™
	depthStencilDesc_.DepthWriteMask = D3D12_DEPTH_WRITE_MASK_ZERO;//D3D12_DEPTH_WRITE_MASK_ALL;
	//æ¯”è¼ƒé–¢æ•°ã¯LessEqualã€‚ã¤ã¾ã‚Šã€è¿‘ã‘ã‚Œã°æç”»ã•ã‚Œã‚‹
	depthStencilDesc_.DepthFunc = D3D12_COMPARISON_FUNC_LESS_EQUAL;


	//InputLayout
	D3D12_INPUT_ELEMENT_DESC inputElementDescs[3] = {};
	inputElementDescs[0].SemanticName = "POSITION";
	inputElementDescs[0].SemanticIndex = 0;
	inputElementDescs[0].Format = DXGI_FORMAT_R32G32B32A32_FLOAT;
	inputElementDescs[0].AlignedByteOffset = D3D12_APPEND_ALIGNED_ELEMENT;

	inputElementDescs[1].SemanticName = "TEXCOORD";
	inputElementDescs[1].SemanticIndex = 0;
	inputElementDescs[1].Format = DXGI_FORMAT_R32G32_FLOAT;
	inputElementDescs[1].AlignedByteOffset = D3D12_APPEND_ALIGNED_ELEMENT;

	inputElementDescs[2].SemanticName = "NORMAL";
	inputElementDescs[2].SemanticIndex = 0;
	inputElementDescs[2].Format = DXGI_FORMAT_R32G32B32_FLOAT;
	inputElementDescs[2].AlignedByteOffset = D3D12_APPEND_ALIGNED_ELEMENT;

	inputLayoutDesc_.pInputElementDescs = inputElementDescs;
	inputLayoutDesc_.NumElements = _countof(inputElementDescs);


	//BlendStateã®è¨­å®š
	//ã™ã¹ã¦ã®è‰²è¦ç´ ã‚’æ›¸ãè¾¼ã‚€
	blendDesc_.RenderTarget[0].RenderTargetWriteMask = D3D12_COLOR_WRITE_ENABLE_ALL;
	blendDesc_.RenderTarget[0].BlendEnable = TRUE;
	blendDesc_.RenderTarget[0].SrcBlend = D3D12_BLEND_SRC_ALPHA;
	blendDesc_.RenderTarget[0].BlendOp = D3D12_BLEND_OP_ADD;
	blendDesc_.RenderTarget[0].DestBlend = D3D12_BLEND_INV_SRC_ALPHA;
	blendDesc_.RenderTarget[0].SrcBlendAlpha = D3D12_BLEND_ONE;
	blendDesc_.RenderTarget[0].BlendOpAlpha = D3D12_BLEND_OP_ADD;
	blendDesc_.RenderTarget[0].DestBlendAlpha = D3D12_BLEND_ZERO;


	//RasterizerStateã®è¨­å®š
	//è£é¢(æ™‚è¨ˆå›žã‚Š)ã‚’è¡¨ç¤ºã—ãªã„
	rasterizerDesc_.CullMode = D3D12_CULL_MODE_NONE;//D3D12_CULL_MODE_BACK;
	//ä¸‰è§’å½¢ã®ä¸­ã‚’å¡—ã‚Šã¤ã¶ã™
	rasterizerDesc_.FillMode = D3D12_FILL_MODE_SOLID;


	//shaderã‚’ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ã™ã‚‹
	vertexShaderBlob_ = dxCommon->CompileShader(L"resources/shaders/Sprite.VS.hlsl", L"vs_6_0");
	assert(vertexShaderBlob_ != nullptr);

	pixelShaderBlob_ = dxCommon->CompileShader(L"resources/shaders/Sprite.PS.hlsl", L"ps_6_0");
	assert(pixelShaderBlob_ != nullptr);


	CreateGraphicsPipeline();
}

void SpriteCommon::CreateRootSignature()
{
	HRESULT result = S_FALSE;


	D3D12_ROOT_SIGNATURE_DESC descriptionRootSignature{};
	descriptionRootSignature.Flags = D3D12_ROOT_SIGNATURE_FLAG_ALLOW_INPUT_ASSEMBLER_INPUT_LAYOUT;

	//RootParameterä½œæˆã€‚è¤‡æ•°è¨­å®šã§ãã‚‹ã®ã§é…åˆ—ã€‚ä»Šå›žã¯çµæžœï¼‘ã¤ã ã‘ãªã®ã§é•·ã•ï¼‘ã®é…åˆ—
	D3D12_ROOT_PARAMETER rootParameters[4] = {};
	rootParameters[0].ParameterType = D3D12_ROOT_PARAMETER_TYPE_CBV;		//CBVã‚’ä½¿ã†
	rootParameters[0].ShaderVisibility = D3D12_SHADER_VISIBILITY_PIXEL;		//PixelShaderã§ä½¿ã†
	rootParameters[0].Descriptor.ShaderRegister = 0;						//ãƒ¬ã‚¸ã‚¹ã‚¿ç•ªå·ï¼ã¨ãƒã‚¤ãƒ³ãƒ‰

	rootParameters[1].ParameterType = D3D12_ROOT_PARAMETER_TYPE_CBV;
	rootParameters[1].ShaderVisibility = D3D12_SHADER_VISIBILITY_VERTEX;
	rootParameters[1].Descriptor.ShaderRegister = 0;

	rootParameters[2].ParameterType = D3D12_ROOT_PARAMETER_TYPE_DESCRIPTOR_TABLE;			//DescriptorTableã‚’ä½¿ã†
	rootParameters[2].ShaderVisibility = D3D12_SHADER_VISIBILITY_PIXEL;						//PixelShaderã§ä½¿ã†
	rootParameters[2].DescriptorTable.pDescriptorRanges = descriptorRange_; 				//Tableã®ä¸­èº«ã®é…åˆ—ã‚’æŒ‡å®š
	rootParameters[2].DescriptorTable.NumDescriptorRanges = _countof(descriptorRange_);		//Tableã§åˆ©ç”¨ã™ã‚‹æ•°

	rootParameters[3].ParameterType = D3D12_ROOT_PARAMETER_TYPE_CBV;
	rootParameters[3].ShaderVisibility = D3D12_SHADER_VISIBILITY_PIXEL;
	rootParameters[3].Descriptor.RegisterSpace = 0;
	rootParameters[3].Descriptor.ShaderRegister = 1;


	//Smaplerã®è¨­å®š
	D3D12_STATIC_SAMPLER_DESC staticSamplers[1] = {};
	staticSamplers[0].Filter = D3D12_FILTER_MIN_MAG_MIP_LINEAR;				//ãƒã‚¤ãƒªãƒ‹ã‚¢ãƒ•ã‚£ãƒ«ã‚¿
	staticSamplers[0].AddressU = D3D12_TEXTURE_ADDRESS_MODE_WRAP;			//0ï½ž1ã®ç¯„å›²å¤–ã‚’ãƒªãƒ”ãƒ¼ãƒˆ
	staticSamplers[0].AddressV = D3D12_TEXTURE_ADDRESS_MODE_WRAP;
	staticSamplers[0].AddressW = D3D12_TEXTURE_ADDRESS_MODE_WRAP;
	staticSamplers[0].ComparisonFunc = D3D12_COMPARISON_FUNC_NEVER;			//æ¯”è¼ƒã—ãªã„
	staticSamplers[0].MaxLOD = D3D12_FLOAT32_MAX;							//ã‚ã‚Šã£ãŸã‘ã®Mipmapã‚’ä½¿ã†
	staticSamplers[0].ShaderRegister = 0;									//ãƒ¬ã‚¸ã‚¹ã‚¿ç•ªå·0ã‚’ä½¿ã†
	staticSamplers[0].ShaderVisibility = D3D12_SHADER_VISIBILITY_PIXEL;		//PixelShaderã‚’ä½¿ã†
	descriptionRootSignature.pStaticSamplers = staticSamplers;
	descriptionRootSignature.NumStaticSamplers = _countof(staticSamplers);

	descriptionRootSignature.pParameters = rootParameters;					//ãƒ«ãƒ¼ãƒˆãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿é…åˆ—ã¸ã®ãƒã‚¤ãƒ³ã‚¿
	descriptionRootSignature.NumParameters = _countof(rootParameters);		//é…åˆ—ã®é•·ã•

	//ã‚·ãƒªã‚¢ãƒ©ã‚¤ã‚ºã—ã¦ãƒã‚¤ãƒŠãƒªã™ã‚‹
	ID3DBlob* signatureBlob = nullptr;
	ID3DBlob* errorBlob = nullptr;
	result = D3D12SerializeRootSignature(&descriptionRootSignature, D3D_ROOT_SIGNATURE_VERSION_1, &signatureBlob, &errorBlob);
	if (FAILED(result))
	{
		Logger::Log(reinterpret_cast<char*>(errorBlob->GetBufferPointer()));
		assert(false);
	}
	//ãƒã‚¤ãƒŠãƒªã‚’ã‚‚ã¨ã«ç”Ÿæˆ
	result = device_->CreateRootSignature(0, signatureBlob->GetBufferPointer(), signatureBlob->GetBufferSize(), IID_PPV_ARGS(&rootSignature_));
	assert(SUCCEEDED(result));

}

void SpriteCommon::CreateGraphicsPipeline()
{
	HRESULT result = S_FALSE;

	CreateRootSignature();


	D3D12_GRAPHICS_PIPELINE_STATE_DESC graphicsPipelineStateDesc{};
	graphicsPipelineStateDesc.pRootSignature = rootSignature_.Get();
	graphicsPipelineStateDesc.InputLayout = inputLayoutDesc_;
	graphicsPipelineStateDesc.VS = { vertexShaderBlob_->GetBufferPointer(),vertexShaderBlob_->GetBufferSize() };
	graphicsPipelineStateDesc.PS = { pixelShaderBlob_->GetBufferPointer(),pixelShaderBlob_->GetBufferSize() };
	graphicsPipelineStateDesc.BlendState = blendDesc_;
	graphicsPipelineStateDesc.RasterizerState = rasterizerDesc_;
	//DepthStencilã®è¨­å®š
	graphicsPipelineStateDesc.DepthStencilState = depthStencilDesc_;
	graphicsPipelineStateDesc.DSVFormat = DXGI_FORMAT_D24_UNORM_S8_UINT;

	//æ›¸ãè¾¼ã‚€RTVã®æƒ…å ±
	graphicsPipelineStateDesc.NumRenderTargets = 1;
	graphicsPipelineStateDesc.RTVFormats[0] = DXGI_FORMAT_R8G8B8A8_UNORM_SRGB;
	//åˆ©ç”¨ã™ã‚‹ãƒˆãƒãƒ­ã‚¸ï¼ˆå½¢çŠ¶ï¼‰ã®ã‚¿ã‚¤ãƒ—ã€‚ä¸‰è§’å½¢
	graphicsPipelineStateDesc.PrimitiveTopologyType = D3D12_PRIMITIVE_TOPOLOGY_TYPE_TRIANGLE;
	//ã©ã®ã‚ˆã†ã«ç”»é¢ã«è‰²ã‚’æ‰“ã¡è¾¼ã‚€ã‹ã®è¨­å®šï¼ˆæ°—ã«ã—ãªãã¦ã„ã„ï¼‰
	graphicsPipelineStateDesc.SampleDesc.Count = 1;
	graphicsPipelineStateDesc.SampleMask = D3D12_DEFAULT_SAMPLE_MASK;

	//å®Ÿéš›ã«ç”Ÿæˆ
	result = device_->CreateGraphicsPipelineState(&graphicsPipelineStateDesc, IID_PPV_ARGS(&graphicsPipelineState_));
	assert(SUCCEEDED(result));

	// ã‚«ãƒªãƒ³ã‚°ã—ãªã„ï¼ˆè£é¢ã‚‚è¡¨ç¤ºã•ã›ã‚‹ï¼‰
	rasterizerDesc_.CullMode = D3D12_CULL_MODE_NONE;
}

void SpriteCommon::CommonDrawSetting()
{
	//RootSignatureã‚’è¨­å®šã€‚PSOã«è¨­å®šã—ã¦ã„ã‚‹ã‘ã©åˆ¥é€”è¨­å®šãŒå¿…è¦
	commandList_->SetGraphicsRootSignature(rootSignature_.Get());
	commandList_->SetPipelineState(graphicsPipelineState_.Get());
	//å½¢çŠ¶ã‚’è¨­å®šã€‚PSOã«è¨­å®šã—ã¦ã„ã‚‹ã‚‚ã®ã¨ã¯ã¾ãŸåˆ¥ã€‚åŒã˜ã‚‚ã®ã‚’è¨­å®šã™ã‚‹ã¨è€ƒãˆã¦ãŠã‘ã°ã‚ˆã„
	commandList_->IASetPrimitiveTopology(D3D_PRIMITIVE_TOPOLOGY_TRIANGLELIST);
}

============================================================
File Path: project/gameEngine/2d/SpriteCommon.h
============================================================

#pragma once
#include <d3d12.h>
#include "../../externals/DirectXTex/d3dx12.h"

#include "DirectXCommon.h"
#include "Logger.h"

/// <summary>
/// ã‚¹ãƒ—ãƒ©ã‚¤ãƒˆå…±é€šã‚¯ãƒ©ã‚¹
/// </summary>
class SpriteCommon
{
#pragma region ã‚·ãƒ³ã‚°ãƒ«ãƒˆãƒ³ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹
private:

	SpriteCommon() = default;
	~SpriteCommon() = default;
	SpriteCommon(SpriteCommon&) = delete;
	SpriteCommon& operator = (SpriteCommon&) = delete;

public:
	// ã‚·ãƒ³ã‚°ãƒ«ãƒˆãƒ³ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã®å–å¾—
	static SpriteCommon* GetInstance();
	// çµ‚äº†
	void Finalize();
#pragma endregion ã‚·ãƒ³ã‚°ãƒ«ãƒˆãƒ³ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹

public:

	/// <summary>
	/// åˆæœŸåŒ–
	/// </summary>
	/// <param name="dxCommon">DirectXCommonã®ãƒã‚¤ãƒ³ã‚¿</param>
	void Initialize(DirectXCommon* dxCommon);

	// ãƒ«ãƒ¼ãƒˆã‚·ã‚°ãƒã‚¤ãƒãƒ£ã®ä½œæˆ
	void CreateRootSignature();

	// ã‚°ãƒ©ãƒ•ã‚£ãƒƒã‚¯ã‚¹ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³ã®ç”Ÿæˆ
	void CreateGraphicsPipeline();

	// å…±é€šæç”»è¨­å®š
	void CommonDrawSetting();

public: // ã‚²ãƒƒã‚¿ãƒ¼

	/// <summary>
	/// DirectXCommonã®ãƒã‚¤ãƒ³ã‚¿ã‚’å–å¾—
	/// </summary>
	/// <returns>DirectXCommonã®ãƒã‚¤ãƒ³ã‚¿</returns>
	DirectXCommon* GetDxCommon() const { return dxCommon_; }

private:

	DirectXCommon* dxCommon_;

	// ãƒ‡ãƒã‚¤ã‚¹
	Microsoft::WRL::ComPtr<ID3D12Device> device_ = nullptr;
	// ã‚³ãƒžãƒ³ãƒ‰ãƒªã‚¹ãƒˆ
	Microsoft::WRL::ComPtr<ID3D12GraphicsCommandList> commandList_ = nullptr;

	//ãƒ‡ã‚£ã‚¹ã‚¯ãƒªãƒ—ã‚¿ãƒ¬ãƒ³ã‚¸ã®ç”Ÿæˆ
	D3D12_DESCRIPTOR_RANGE descriptorRange_[1]{};
	//DepthStencilStateã®è¨­å®š
	D3D12_DEPTH_STENCIL_DESC depthStencilDesc_{};
	//InputLayout
	D3D12_INPUT_LAYOUT_DESC inputLayoutDesc_{};
	//BlendStateã®è¨­å®š
	D3D12_BLEND_DESC blendDesc_{};
	//RasterizerStateã®è¨­å®š
	D3D12_RASTERIZER_DESC rasterizerDesc_{};

	//shaderã‚’ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ã™ã‚‹
	Microsoft::WRL::ComPtr<IDxcBlob> vertexShaderBlob_ = nullptr;
	Microsoft::WRL::ComPtr<IDxcBlob> pixelShaderBlob_ = nullptr;

	//RootSignatureä½œæˆ
	Microsoft::WRL::ComPtr<ID3D12RootSignature> rootSignature_ = nullptr;

	//PSOã‚’ç”Ÿæˆã™ã‚‹
	Microsoft::WRL::ComPtr<ID3D12PipelineState> graphicsPipelineState_ = nullptr;

};


============================================================
File Path: project/gameEngine/3d/Camera.cpp
============================================================
#include "Camera.h"
#include "WinApp.h"

Camera::Camera()
	: transform_({ {1.0f,1.0f,1.0f},{0.0f,0.0f,0.0f},{0.0f,0.0f,0.0f} })
	, fovY_(0.45f)
	, aspectRatio_(float(WinApp::kClientWidth) / float(WinApp::kClientHeight))
	, nearClip_(0.1f)
	, farClip_(100.0f)
	, worldMatrix_(MakeAffineMatrix(transform_.scale, transform_.rotate, transform_.translate))
	, viewMatrix_(Inverse(worldMatrix_))
	, projectionMatrix_(MakePerspectiveFovMatrix(fovY_, aspectRatio_, nearClip_, farClip_))
	, viewProjectionMatrix_(viewMatrix_* projectionMatrix_)
{}

void Camera::Update()
{
	worldMatrix_= MakeAffineMatrix(transform_.scale, transform_.rotate, transform_.translate);
	viewMatrix_ = Inverse(worldMatrix_);
	projectionMatrix_ = MakePerspectiveFovMatrix(fovY_, aspectRatio_, nearClip_, farClip_);
	viewProjectionMatrix_ = viewMatrix_ * projectionMatrix_;
}

void Camera::StartShake(float duration, float magnitude)
{
	isShaking_ = true;
	shakeDuration_ = duration;
	shakeMagnitude_ = magnitude;
	shakeTimeElapsed_ = 0.0f;
	randomDistribution_ = std::uniform_real_distribution<float>(-1.0f, 1.0f);
}

void Camera::UpdateShake(float deltaTime)
{
	if (!isShaking_) return;

	shakeTimeElapsed_ += deltaTime;
	if (shakeTimeElapsed_ >= shakeDuration_)
	{
		isShaking_ = false;
		return;
	}

	float offsetX = randomDistribution_(randomEngine_) * shakeMagnitude_;
	float offsetY = randomDistribution_(randomEngine_) * shakeMagnitude_;
	float offsetZ = randomDistribution_(randomEngine_) * shakeMagnitude_;

	// ã‚«ãƒ¡ãƒ©ã®ä½ç½®ã‚’ã‚·ã‚§ã‚¤ã‚¯
	Vector3 originalPosition = GetPosition();
	SetPosition(originalPosition + Vector3(offsetX, offsetY, offsetZ));
}

Vector2 Camera::WorldToScreen(const Vector3& worldPos) const
{
	// ãƒ¯ãƒ¼ãƒ«ãƒ‰åº§æ¨™ã‚’ã‚¯ãƒªãƒƒãƒ—åº§æ¨™ã«å¤‰æ›
	float x = worldPos.x;
	float y = worldPos.y;
	float z = worldPos.z;
	float w = 1.0f;

	// ãƒ“ãƒ¥ãƒ¼ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ã‚·ãƒ§ãƒ³è¡Œåˆ—ã‚’ã‹ã‘ã‚‹
	Vector4 clip;
	const Matrix4x4& m = viewProjectionMatrix_;
	clip.x = x * m.m[0][0] + y * m.m[1][0] + z * m.m[2][0] + w * m.m[3][0];
	clip.y = x * m.m[0][1] + y * m.m[1][1] + z * m.m[2][1] + w * m.m[3][1];
	clip.z = x * m.m[0][2] + y * m.m[1][2] + z * m.m[2][2] + w * m.m[3][2];
	clip.w = x * m.m[0][3] + y * m.m[1][3] + z * m.m[2][3] + w * m.m[3][3];

	// é€è¦–é™¤ç®—
	if (fabs(clip.w) < 1e-6f) return Vector2(-10000.0f, -10000.0f);

	Vector3 ndc = { clip.x / clip.w, clip.y / clip.w, clip.z / clip.w };

	// NDCã‚’ã‚¹ã‚¯ãƒªãƒ¼ãƒ³åº§æ¨™ã«å¤‰æ›d
	float sx = (ndc.x * 0.5f + 0.5f) * float(WinApp::kClientWidth);
	float sy = (-ndc.y * 0.5f + 0.5f) * float(WinApp::kClientHeight);

	return Vector2(sx, sy);
}


============================================================
File Path: project/gameEngine/3d/Camera.h
============================================================
#pragma once

#include "MyMath.h"

#include <random>

/// <summary>
/// ã‚«ãƒ¡ãƒ©ã‚¯ãƒ©ã‚¹
/// ã‚«ãƒ¡ãƒ©ã®ä½ç½®ã€å‘ãã€å°„å½±å¤‰æ›è¡Œåˆ—ã‚’ç®¡ç†
/// </summary>
class Camera
{
public:

	Camera();
	
	/// <summary>
	/// æ›´æ–°
	/// </summary>
	void Update();

	/// <summary>
	/// ã‚·ã‚§ã‚¤ã‚¯é–‹å§‹
	/// </summary>
	/// <param name="duration">ã‚·ã‚§ã‚¤ã‚¯ã®æŒç¶šæ™‚é–“</param>
	/// <param name="magnitude">ã‚·ã‚§ã‚¤ã‚¯ã®å¼·ã•</param>
	void StartShake(float duration, float magnitude);

	/// <summary>
	/// ã‚·ã‚§ã‚¤ã‚¯æ›´æ–°
	/// </summary>
	/// <param name="deltaTime">å‰ãƒ•ãƒ¬ãƒ¼ãƒ ã‹ã‚‰ã®çµŒéŽæ™‚é–“</param>
	void UpdateShake(float deltaTime);

	Vector2 WorldToScreen(const Vector3& worldPos) const;

public: // ã‚»ãƒƒã‚¿ãƒ¼

	/// <summary>
	/// å›žè»¢ã‚’è¨­å®š
	/// </summary>
	/// <param name="rotate">å›žè»¢</param>
	void SetRotate(Vector3 rotate) { transform_.rotate = rotate; }
	
	/// <summary>
	/// ä½ç½®ã‚’è¨­å®š
	/// </summary>
	/// <param name="translate">ä½ç½®</param>
	void SetPosition(Vector3 translate) { transform_.translate = translate; }
	
	/// <summary>
	/// è¦–é‡Žè§’ã‚’è¨­å®š
	/// </summary>
	/// <param name="fovY">è¦–é‡Žè§’</param>
	void SetFovY(float fovY) { fovY_ = fovY; }
	
	/// <summary>
	/// ã‚¢ã‚¹ãƒšã‚¯ãƒˆæ¯”ã‚’è¨­å®š
	/// </summary>
	/// <param name="aspectRatio">ã‚¢ã‚¹ãƒšã‚¯ãƒˆæ¯”</param>
	void SetAspectRatio(float aspectRatio) { aspectRatio_ = aspectRatio; }
	
	/// <summary>
	/// ãƒ‹ã‚¢ã‚¯ãƒªãƒƒãƒ—è·é›¢ã‚’è¨­å®š
	/// </summary>
	/// <param name="nearClip">ãƒ‹ã‚¢ã‚¯ãƒªãƒƒãƒ—è·é›¢</param>
	void SetNearClip(float nearClip) { nearClip_ = nearClip; }

	/// <summary>
	/// ãƒ•ã‚¡ãƒ¼ã‚¯ãƒªãƒƒãƒ—è·é›¢ã‚’è¨­å®š
	/// </summary>
	/// <param name="farClip">ãƒ•ã‚¡ãƒ¼ã‚¯ãƒªãƒƒãƒ—è·é›¢</param>
	void SetFarClip(float farClip) { farClip_ = farClip; }

public: // ã‚²ãƒƒã‚¿ãƒ¼

	// å„ç¨®è¡Œåˆ—ã€æƒ…å ±ã®å–å¾—
	const Vector3& GetRotate() const { return transform_.rotate; }

	// ä½ç½®ã®å–å¾—
	const Vector3& GetPosition() const { return transform_.translate; }

	// ãƒ¯ãƒ¼ãƒ«ãƒ‰è¡Œåˆ—ã®å–å¾—
	const Matrix4x4& GetWorldMatrix() const { return worldMatrix_; }
	
	// ãƒ“ãƒ¥ãƒ¼è¡Œåˆ—ã®å–å¾—
	const Matrix4x4& GetViewMatrix() const { return viewMatrix_; }
	
	// é€è¦–æŠ•å½±è¡Œåˆ—ã®å–å¾—
	const Matrix4x4& GetProjectionMatrix() const { return projectionMatrix_; }
	
	// ãƒ“ãƒ¥ãƒ¼ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ã‚·ãƒ§ãƒ³è¡Œåˆ—ã®å–å¾—
	const Matrix4x4& GetViewProjectionMatrix() const { return viewProjectionMatrix_; }

	// ã‚·ã‚§ã‚¤ã‚¯ä¸­ã‹ã©ã†ã‹å–å¾—
	bool IsShaking() const { return isShaking_; }

private:

	struct Transform
	{
		Vector3 scale;
		Vector3 rotate;
		Vector3 translate;
	};

private:

	Transform transform_{};
	Matrix4x4 worldMatrix_{};
	Matrix4x4 viewMatrix_{};

	Matrix4x4 projectionMatrix_{};
	float fovY_;			// æ°´å¹³æ–¹å‘è¦–é‡Žè§’
	float aspectRatio_;     // ã‚¢ã‚¹ãƒšã‚¯ãƒˆæ¯”
	float nearClip_;		// ãƒ‹ã‚¢ã‚¯ãƒªãƒƒãƒ—è·é›¢
	float farClip_;		    // ãƒ•ã‚¡ãƒ¼ã‚¯ãƒªãƒƒãƒ—è·é›¢

	Matrix4x4 viewProjectionMatrix_{};

	// ã‚·ã‚§ã‚¤ã‚¯ã®ãŸã‚ã®å¤‰æ•°
	bool isShaking_ = false;
	float shakeDuration_ = 0.0f;
	float shakeMagnitude_ = 0.0f;
	float shakeTimeElapsed_ = 0.0f;
	std::default_random_engine randomEngine_;
	std::uniform_real_distribution<float> randomDistribution_;
};

============================================================
File Path: project/gameEngine/3d/CameraManager.cpp
============================================================
#include "CameraManager.h"

void CameraManager::AddCamera(std::shared_ptr<Camera> camera)
{
    cameras_.push_back(camera);
    if (activeCameraIndex_ == std::numeric_limits<uint32_t>::max()) 
    {
        activeCameraIndex_ = 0;  // æœ€åˆã®ã‚«ãƒ¡ãƒ©ã‚’ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ã«ã™ã‚‹
    }
}

void CameraManager::RemoveCamera(uint32_t index) 
{
    if (index < cameras_.size()) 
    {
        cameras_.erase(cameras_.begin() + index);
        if (index == activeCameraIndex_)
        {
            activeCameraIndex_ = cameras_.empty() ? std::numeric_limits<uint32_t>::max() : 0;
        }
        else if (index < activeCameraIndex_) 
        {
            --activeCameraIndex_;
        }
    }
}

void CameraManager::SetActiveCamera(uint32_t index) 
{
    if (index < cameras_.size()) 
    {
        activeCameraIndex_ = index;
    }
}

std::shared_ptr<Camera> CameraManager::GetActiveCamera() const
{
    if (activeCameraIndex_ < cameras_.size()) 
    {
        return cameras_[activeCameraIndex_];
    }
    return nullptr;
}

void CameraManager::UpdateAll(float deltaTime)
{
    for (auto& camera : cameras_)
    {
        if (deltaTime > 0.0f)
        {
            camera->UpdateShake(deltaTime);
        }
        camera->Update();
    }
}

void CameraManager::ShakeSpecificCamera(uint32_t index, float duration, float magnitude)
{
    if (index < cameras_.size())
    {
        cameras_[index]->StartShake(duration, magnitude);
    }
}

void CameraManager::StartShakeActiveCamera(float duration, float magnitude)
{
    ShakeSpecificCamera(activeCameraIndex_, duration, magnitude);
}

void CameraManager::ClearAllCameras()
{
    cameras_.clear();
    activeCameraIndex_ = std::numeric_limits<uint32_t>::max();
}

============================================================
File Path: project/gameEngine/3d/CameraManager.h
============================================================
#pragma once

#include "Camera.h"
#include <vector>
#include <memory>

#include <limits>

#undef max
#undef min

/// <summary>
/// ã‚«ãƒ¡ãƒ©ãƒžãƒãƒ¼ã‚¸ãƒ£ãƒ¼
/// è¤‡æ•°ã®ã‚«ãƒ¡ãƒ©ã‚’ç®¡ç†ã—ã€ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ãªã‚«ãƒ¡ãƒ©ã‚’åˆ‡ã‚Šæ›¿ãˆãŸã‚Šã€å…¨ã‚«ãƒ¡ãƒ©ã®æ›´æ–°ã‚’è¡Œã£ãŸã‚Šã™ã‚‹
/// </summary>
class CameraManager
{
public:
    // ã‚·ãƒ³ã‚°ãƒ«ãƒˆãƒ³ãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’ä½¿ã„ãŸã„å ´åˆ
    static CameraManager& GetInstance() 
    {
        static CameraManager instance;
        return instance;
    }

    /// <summary>
    /// ã‚«ãƒ¡ãƒ©ã®è¿½åŠ 
    /// </summary>
    /// <param name="camera">è¿½åŠ ã™ã‚‹Cameraã®å…±æœ‰ãƒã‚¤ãƒ³ã‚¿</param>
    void AddCamera(std::shared_ptr<Camera> camera);

    /// <summary>
    /// ã‚«ãƒ¡ãƒ©ã®å‰Šé™¤
    /// ã‚·ãƒ¼ãƒ³ã®å¤‰æ›´æ™‚ç­‰ã«å‘¼ã³å‡ºã™
    /// </summary>
    /// <param name="index">å‰Šé™¤ã™ã‚‹ã‚«ãƒ¡ãƒ©ã®ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹</param>
    void RemoveCamera(uint32_t index);

    /// <summary>
    /// ã‚¢ãƒƒãƒ—ãƒ‡ãƒ¼ãƒˆ(å…¨ã‚«ãƒ¡ãƒ©ã®æ›´æ–°å‡¦ç†ã‚’å®Ÿè¡Œ)
    /// </summary>
    /// <param name="deltaTime">ãƒ‡ãƒ«ã‚¿ã‚¿ã‚¤ãƒ </param>
    void UpdateAll(float deltaTime = 0.0f);

    /// <summary>
    /// ç‰¹å®šã®ã‚«ãƒ¡ãƒ©ã®ã‚·ã‚§ã‚¤ã‚¯ã‚’é–‹å§‹
    /// </summary>
    /// <param name="index">ã‚·ã‚§ã‚¤ã‚¯ã‚’é–‹å§‹ã™ã‚‹ã‚«ãƒ¡ãƒ©ã®ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹</param>
    /// <param name="duration">ã‚·ã‚§ã‚¤ã‚¯ã®æŒç¶šæ™‚é–“(ç§’)</param>
    /// <param name="magnitude">ã‚·ã‚§ã‚¤ã‚¯ã®å¼·ã•</param>
    void ShakeSpecificCamera(uint32_t index, float duration, float magnitude);

    // ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ã‚«ãƒ¡ãƒ©ã®ã‚·ã‚§ã‚¤ã‚¯ã‚’é–‹å§‹
    // è»½ã„è¡æ’ƒã®ã‚·ã‚§ã‚¤ã‚¯
    // cameraManager.StartShakeActiveCamera(0.2f, 0.3f);
    // ä¸­è¦æ¨¡ã®çˆ†ç™ºã®ã‚·ã‚§ã‚¤ã‚¯
    // cameraManager.StartShakeActiveCamera(0.5f, 0.8f);
    // å¤§è¦æ¨¡ãªçˆ†ç™ºã®ã‚·ã‚§ã‚¤ã‚¯
    // cameraManager.StartShakeActiveCamera(1.0f, 1.5f);

    /// <summary>
    /// ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ã‚«ãƒ¡ãƒ©ã®ã‚·ã‚§ã‚¤ã‚¯ã‚’é–‹å§‹
    /// è»½ã„è¡æ’ƒã®ã‚·ã‚§ã‚¤ã‚¯
    /// cameraManager.StartShakeActiveCamera(0.2f, 0.3f);
    /// ä¸­è¦æ¨¡ã®çˆ†ç™ºã®ã‚·ã‚§ã‚¤ã‚¯
    /// cameraManager.StartShakeActiveCamera(0.5f, 0.8f);
    /// å¤§è¦æ¨¡ãªçˆ†ç™ºã®ã‚·ã‚§ã‚¤ã‚¯
    /// cameraManager.StartShakeActiveCamera(1.0f, 1.5f);
    /// </summary>
    /// <param name="duration">ã‚·ã‚§ã‚¤ã‚¯ã®æŒç¶šæ™‚é–“(ç§’)</param>
    /// <param name="magnitude">ã‚·ã‚§ã‚¤ã‚¯ã®å¼·ã•</param>
    void StartShakeActiveCamera(float duration, float magnitude);

    /// <summary>
    /// å…¨ã¦ã®ã‚«ãƒ¡ãƒ©ã‚’å‰Šé™¤
    /// </summary>
    void ClearAllCameras();

public: // ã‚²ãƒƒã‚¿ãƒ¼

	// ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ã‚«ãƒ¡ãƒ©ã®ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹å–å¾—
    uint32_t GetActiveIndex()const { return activeCameraIndex_; }

    // ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ã‚«ãƒ¡ãƒ©ã®å–å¾—
    std::shared_ptr<Camera> GetActiveCamera() const;

	// ã‚«ãƒ¡ãƒ©ã®æ•°ã‚’å–å¾—
	uint32_t GetCameraCount() const { return static_cast<uint32_t>(cameras_.size()); }

public: // ã‚»ãƒƒã‚¿ãƒ¼

    /// <summary>
    /// ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ã‚«ãƒ¡ãƒ©ã‚’è¨­å®š
    /// </summary>
    /// <param name="index">ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ã«ã—ãŸã„ã‚«ãƒ¡ãƒ©ã®ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹</param>
    void SetActiveCamera(uint32_t index);

private:
    CameraManager() = default;
    ~CameraManager() = default;

    CameraManager(const CameraManager&) = delete;
    CameraManager& operator=(const CameraManager&) = delete;

private:
    std::vector<std::shared_ptr<Camera>> cameras_;  // ã‚«ãƒ¡ãƒ©ã®ãƒªã‚¹ãƒˆ
    uint32_t activeCameraIndex_ = ::std::numeric_limits<uint32_t>::max();  // ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ãªã‚«ãƒ¡ãƒ©ã®ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ (ç„¡åŠ¹å€¤ã‚’è¨­å®š)
};




============================================================
File Path: project/gameEngine/3d/Model.cpp
============================================================

#include "Model.h"

#include <fstream>
#include <sstream>

#include "ModelCommon.h"

void Model::Initialize(ModelCommon* modelCommon, const std::string& directorypath, const std::string& filename)
{
	modelCommon_ = modelCommon;

	//ãƒ¢ãƒ‡ãƒ«èª­ã¿è¾¼ã¿
	modelData_ = LoadObjFile(directorypath, filename);

	// VertexResourceã‚’ä½œã‚‹
	CreateVertexData();

	// ãƒžãƒ†ãƒªã‚¢ãƒ«ãƒªã‚½ãƒ¼ã‚¹ã‚’ä½œã‚‹
	CreateMaterialData();

	// .objã®å‚ç…§ã—ã¦ã„ã‚‹ãƒ†ã‚¯ã‚¹ãƒãƒ£ãƒ•ã‚¡ã‚¤ãƒ«èª­ã¿è¾¼ã¿
	TextureManager::GetInstance()->LoadTexture(modelData_.material.textureFilePath);
	// èª­ã¿è¾¼ã‚“ã ãƒ†ã‚¯ã‚¹ãƒãƒ£ã®ç•ªå·ã‚’å–å¾—
	modelData_.material.textureIndex = TextureManager::GetInstance()->GetTextureIndexByFilePath(modelData_.material.textureFilePath);

}

void Model::UpData()
{
}

void Model::Draw()
{
	// VertexBufferViewã‚’è¨­å®š
	modelCommon_->GetDxCommon()->GetCommandList()->IASetVertexBuffers(0, 1, &vertexBufferView_);

	// ãƒžãƒ†ãƒªã‚¢ãƒ«CBufferã®å ´æ‰€ã‚’è¨­å®š
	modelCommon_->GetDxCommon()->GetCommandList()->SetGraphicsRootConstantBufferView(0, materialResource_->GetGPUVirtualAddress());


	// SRVã®DescriptorTableã®å…ˆé ­ã‚’è¨­å®šã€‚2ã¯rootPatameter[2]ã§ã‚ã‚‹ã€‚
	modelCommon_->GetDxCommon()->GetCommandList()->SetGraphicsRootDescriptorTable(2, TextureManager::GetInstance()->GetSrvHandleGPU(modelData_.material.textureFilePath));


	//æç”»ï¼
	modelCommon_->GetDxCommon()->GetCommandList()->DrawInstanced(UINT(modelData_.vertices.size()), 1, 0, 0);
}

Model::MaterialData Model::LoadMaterialTemplateFile(const std::string& directoryPath, const std::string& filename)
{
	MaterialData materialData;
	std::string line;
	std::ifstream file(directoryPath + "/" + filename);
	assert(file.is_open());

	while (std::getline(file, line))
	{
		std::string identifier;
		std::istringstream s(line);
		s >> identifier;

		//identifierã«å¿œã˜ãŸå‡¦ç†
		if (identifier == "map_Kd")
		{
			std::string textureFilename;
			s >> textureFilename;

			//é€£çµã—ã¦ãƒ•ã‚¡ã‚¤ãƒ«ãƒ‘ã‚¹ã«ã™ã‚‹
			materialData.textureFilePath = directoryPath + "/" + textureFilename;
		}
	}

	return materialData;
}

Model::ModelData Model::LoadObjFile(const std::string& directoryPath, const std::string& filename)
{
	//ä¸­ã§å¿…è¦ã¨ãªã‚‹å¤‰æ•°ã®å®£è¨€
	ModelData modelData; //æ§‹ç¯‰ã™ã‚‹ModelData
	

	Assimp::Importer importer;
	std::string fullPath = directoryPath + "/" + filename;
	const aiScene* scene = importer.ReadFile(fullPath.c_str(), aiProcess_FlipWindingOrder | aiProcess_FlipUVs);
	assert(scene->HasMeshes()); // ãƒ¡ãƒƒã‚·ãƒ¥ãŒãªã„å ´åˆã¯ã‚¨ãƒ©ãƒ¼

	for (uint32_t meshIndex = 0; meshIndex < scene->mNumMeshes; ++meshIndex)
	{
		aiMesh* mesh = scene->mMeshes[meshIndex];
		assert(mesh->HasNormals()); // æ³•ç·šãŒãªã„å ´åˆã¯ã‚¨ãƒ©ãƒ¼
		assert(mesh->HasTextureCoords(0)); // TexCoordãŒãªã„å ´åˆã¯ã‚¨ãƒ©ãƒ¼

		for (uint32_t faceIndex = 0; faceIndex < mesh->mNumFaces; ++faceIndex)
		{
			aiFace& face = mesh->mFaces[faceIndex];
			assert(face.mNumIndices == 3); // ä¸‰è§’å½¢ä»¥å¤–ã¯ã‚¨ãƒ©ãƒ¼

			for (uint32_t element = 0; element < face.mNumIndices; ++element)
			{
				uint32_t vertexIndex = face.mIndices[element];
				aiVector3D& position = mesh->mVertices[vertexIndex];
				aiVector3D& normal = mesh->mNormals[vertexIndex];
				aiVector3D& texcoord = mesh->mTextureCoords[0][vertexIndex];
				VertexData vertex;
				vertex.position = { position.x, position.y, position.z, 1.0f };
				vertex.normal = { normal.x, normal.y, normal.z };
				vertex.texcoord = { texcoord.x, texcoord.y };
				// aiProcess_MakeLeftHandedã¯z*=-1ã§ã€å³æ‰‹->å·¦æ‰‹ã«å¤‰æ›ã™ã‚‹ã®ã§æ‰‹å‹•ã§å¯¾å‡¦
				vertex.position.x *= -1.0f;
				vertex.normal.x *= -1.0f;
				modelData.vertices.push_back(vertex);
			}

			for (uint32_t materialIndex = 0; materialIndex < scene->mNumMaterials; ++materialIndex)
			{
				aiMaterial* material = scene->mMaterials[materialIndex];
				if (material->GetTextureCount(aiTextureType_DIFFUSE) != 0)
				{
					aiString textureFilePath;
					material->GetTexture(aiTextureType_DIFFUSE, 0, &textureFilePath);
					modelData.material.textureFilePath = directoryPath + "/" + textureFilePath.C_Str();

				}
			}
		}

	}

	// ãƒŽãƒ¼ãƒ‰ã®æƒ…å ±ã‚’å–å¾—
	modelData.rootNode = ReadNode(scene->mRootNode);

	//ModelDataã‚’è¿”ã™
	return modelData;
}

void Model::CreateVertexData()
{
	// VertexResourceã‚’ä½œã‚‹
	vertexResource_ = modelCommon_->GetDxCommon()->CreateBufferResource(sizeof(VertexData) * modelData_.vertices.size());
	// VertexBufferViewã‚’ä½œæˆã™ã‚‹(å€¤ã‚’è¨­å®šã™ã‚‹ã ã‘)
	vertexBufferView_.BufferLocation = vertexResource_->GetGPUVirtualAddress();				//ãƒªã‚½ãƒ¼ã‚¹ã®å…ˆé ­ã®ã‚¢ãƒ‰ãƒ¬ã‚¹ã‹ã‚‰ä½¿ã†
	vertexBufferView_.SizeInBytes = UINT(sizeof(VertexData) * modelData_.vertices.size());	//ä½¿ç”¨ã™ã‚‹ãƒªã‚½ãƒ¼ã‚¹ã®ã‚µã‚¤ã‚ºã¯é ‚ç‚¹ã®ã‚µã‚¤ã‚º
	vertexBufferView_.StrideInBytes = sizeof(VertexData);		//ï¼‘é ‚ç‚¹å½“ãŸã‚Šã®ã‚µã‚¤ã‚º
	// VertexResourceã«ãƒ‡ãƒ¼ã‚¿ã‚’æãã“ã‚€ãŸã‚ã®ã‚¢ãƒ‰ãƒ¬ã‚¹ã‚’å–å¾—ã— vertexDataã«å‰²ã‚Šå½“ã¦ã‚‹
	vertexResource_->Map(0, nullptr, reinterpret_cast<void**>(&vertexData_));
	std::memcpy(vertexData_, modelData_.vertices.data(), sizeof(VertexData) * modelData_.vertices.size());

}

void Model::CreateMaterialData()
{
	// ãƒžãƒ†ãƒªã‚¢ãƒ«ãƒªã‚½ãƒ¼ã‚¹ã‚’ä½œã‚‹
	materialResource_ = modelCommon_->GetDxCommon()->CreateBufferResource(sizeof(Material));
	// ãƒžãƒ†ãƒªã‚¢ãƒ«ãƒªã‚½ãƒ¼ã‚¹ã«ãƒ‡ãƒ¼ã‚¿ã‚’æãã“ã‚€ãŸã‚ã®ã‚¢ãƒ‰ãƒ¬ã‚¹ã‚’å–å¾—ã— ãƒžãƒ†ãƒªã‚¢ãƒ«ãƒªã‚½ãƒ¼ã‚¹ã«å‰²ã‚Šå½“ã¦ã‚‹
	materialResource_->Map(0, nullptr, reinterpret_cast<void**>(&materialData_));
	// ãƒžãƒ†ãƒªã‚¢ãƒ«ãƒ‡ãƒ¼ã‚¿ã®åˆæœŸå€¤ã‚’æãæ¥ã‚€
	materialData_->color = Vector4(1.0f, 1.0f, 1.0f, 1.0f);
	materialData_->enableLighting = false;
	materialData_->uvTransform = MakeIdentity4x4();
	materialData_->shininess = 50.0f;
	materialData_->phongReflection = false;
	materialData_->halfphongReflection = false;
	materialData_->pointLight = false;
	materialData_->spotLight = false;
}

Model::Node Model::ReadNode(aiNode* node)
{
	Node result;
	aiMatrix4x4 aiLocalMatrix = node->mTransformation; // nodeã®localMatrixã‚’å–å¾—
	aiLocalMatrix.Transpose(); // è¡Œåˆ—ã‚’è»¢ç½®ã™ã‚‹
	result.localMatrix.m[0][0] = aiLocalMatrix[0][0];
	result.localMatrix.m[0][1] = aiLocalMatrix[1][0];
	result.localMatrix.m[0][2] = aiLocalMatrix[2][0];
	result.localMatrix.m[0][3] = aiLocalMatrix[3][0];
	result.localMatrix.m[1][0] = aiLocalMatrix[0][1];
	result.localMatrix.m[1][1] = aiLocalMatrix[1][1];
	result.localMatrix.m[1][2] = aiLocalMatrix[2][1];
	result.localMatrix.m[1][3] = aiLocalMatrix[3][1];
	result.localMatrix.m[2][0] = aiLocalMatrix[0][2];
	result.localMatrix.m[2][1] = aiLocalMatrix[1][2];
	result.localMatrix.m[2][2] = aiLocalMatrix[2][2];
	result.localMatrix.m[2][3] = aiLocalMatrix[3][2];
	result.localMatrix.m[3][0] = aiLocalMatrix[0][3];
	result.localMatrix.m[3][1] = aiLocalMatrix[1][3];
	result.localMatrix.m[3][2] = aiLocalMatrix[2][3];
	result.localMatrix.m[3][3] = aiLocalMatrix[3][3];

	result.name = node->mName.C_Str(); // nodeã®åå‰ã‚’å–å¾—
	result.children.resize(node->mNumChildren); // å­ãƒŽãƒ¼ãƒ‰ã®æ•°ã‚’å–å¾—
	for (uint32_t childIndex = 0; childIndex < node->mNumChildren; ++childIndex)
	{
		// å†å¸°çš„ã«èª­ã‚“ã§éšŽå±¤æ§‹é€ ã‚’ä½œã£ã¦ã„ã
		result.children[childIndex] = ReadNode(node->mChildren[childIndex]);
	}

	return result;
}

void Model::UpdateVertexBuffer()
{
	// é ‚ç‚¹ãƒ‡ãƒ¼ã‚¿ãŒç©ºã®å ´åˆã¯å‡¦ç†ã‚’ã‚¹ã‚­ãƒƒãƒ—
	if (modelData_.vertices.empty()) {
		return;
	}

	// æ–°ã—ã„é ‚ç‚¹ãƒãƒƒãƒ•ã‚¡ã‚’ä½œæˆ
	vertexResource_ = modelCommon_->GetDxCommon()->CreateBufferResource(sizeof(VertexData) * modelData_.vertices.size());

	// é ‚ç‚¹ãƒ‡ãƒ¼ã‚¿ã‚’ GPU ãƒãƒƒãƒ•ã‚¡ã«ã‚³ãƒ”ãƒ¼
	void* mappedData = nullptr;
	vertexResource_->Map(0, nullptr, &mappedData);
	std::memcpy(mappedData, modelData_.vertices.data(), sizeof(VertexData) * modelData_.vertices.size());
	vertexResource_->Unmap(0, nullptr);

	// é ‚ç‚¹ãƒãƒƒãƒ•ã‚¡ãƒ“ãƒ¥ãƒ¼ã‚’æ›´æ–°
	vertexBufferView_.BufferLocation = vertexResource_->GetGPUVirtualAddress();
	vertexBufferView_.SizeInBytes = static_cast<UINT>(sizeof(VertexData) * modelData_.vertices.size());
	vertexBufferView_.StrideInBytes = sizeof(VertexData);
}

void Model::UpdateIndexBuffer()
{
	// ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ãƒãƒƒãƒ•ã‚¡ãŒç©ºã®å ´åˆã¯å‡¦ç†ã‚’ã‚¹ã‚­ãƒƒãƒ—
	if (modelData_.indices.empty())
	{
		return;
	}

	// æ–°ã—ã„ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ãƒãƒƒãƒ•ã‚¡ã‚’ä½œæˆ
	indexResource_ = modelCommon_->GetDxCommon()->CreateBufferResource(sizeof(uint32_t) * modelData_.indices.size());
	
	// ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ãƒ‡ãƒ¼ã‚¿ã‚’ GPU ãƒãƒƒãƒ•ã‚¡ã«ã‚³ãƒ”ãƒ¼
	void* mappedData = nullptr;
	indexResource_->Map(0, nullptr, &mappedData);
	std::memcpy(mappedData, modelData_.indices.data(), sizeof(uint32_t) * modelData_.indices.size());
	indexResource_->Unmap(0, nullptr);
	// ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ãƒãƒƒãƒ•ã‚¡ãƒ“ãƒ¥ãƒ¼ã‚’æ›´æ–°
	indexBufferView_.BufferLocation = indexResource_->GetGPUVirtualAddress();
	indexBufferView_.SizeInBytes = static_cast<UINT>(sizeof(uint32_t) * modelData_.indices.size());
	indexBufferView_.Format = DXGI_FORMAT_R32_UINT;
}

void Model::ClearVertexData()
{
	// ãƒªã‚½ãƒ¼ã‚¹ã‚’è§£æ”¾
	modelData_.vertices.clear();
	modelData_.indices.clear();

	// é ‚ç‚¹ãƒªã‚½ãƒ¼ã‚¹ã¨ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ãƒªã‚½ãƒ¼ã‚¹ã‚’ãƒªã‚»ãƒƒãƒˆ
	vertexResource_.Reset();
	indexResource_.Reset();

	// é ‚ç‚¹ãƒãƒƒãƒ•ã‚¡ãƒ“ãƒ¥ãƒ¼ã¨ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ãƒãƒƒãƒ•ã‚¡ãƒ“ãƒ¥ãƒ¼ã‚’ãƒªã‚»ãƒƒãƒˆ
	vertexBufferView_ = {};
	indexBufferView_ = {};
}

void Model::CopyFrom(const Model& other)
{
	modelData_ = other.modelData_;
	vertexResource_ = other.vertexResource_;
	materialResource_ = other.materialResource_;
	vertexData_ = other.vertexData_;
	materialData_ = other.materialData_;
	vertexBufferView_ = other.vertexBufferView_;
	indexResource_ = other.indexResource_;
	indexBufferView_ = other.indexBufferView_;
	transform_ = other.transform_;
}

void Model::AddVertex(const Vector4& position, const Vector2& texcoord, const Vector3& normal)
{
	// é ‚ç‚¹ãƒ‡ãƒ¼ã‚¿ã‚’ä½œæˆã—ã¦è¿½åŠ 
	VertexData vertex = { position, texcoord, normal };
	modelData_.vertices.push_back(vertex);

	// VertexBufferViewã‚’æ›´æ–°
	UpdateVertexBuffer();
}

void Model::AddIndex(uint32_t index)
{
	modelData_.indices.push_back(index);
}

void Model::SetEnableLighting(bool enable)
{
	if (materialData_)
	{
		materialData_->enableLighting = enable ? 1 : 0;
	}
}

void Model::SetEnableDirectionalLight(bool enable)
{
	if (materialData_)
	{
		materialData_->phongReflection = enable ? 1 : 0;
	}
}

void Model::SetEnablePointLight(bool enable)
{
	if (materialData_)
	{
		materialData_->pointLight = enable ? 1 : 0;
	}
}

void Model::SetEnableSpotLight(bool enable)
{
	if (materialData_)
	{
		materialData_->spotLight = enable ? 1 : 0;
	}
}

void Model::SetEnvironment(bool enable)
{
	if (materialData_)
	{
		materialData_->environment = enable ? 1 : 0;
	}
}

void Model::SetEnvironmentStrength(float strength)
{
	if (materialData_)
	{
		materialData_->environmentStrength = strength;
	}
}



============================================================
File Path: project/gameEngine/3d/Model.h
============================================================
#pragma once

#include <assimp/Importer.hpp>
#include <assimp/scene.h>
#include <assimp/postprocess.h>

#include "MyMath.h"
#include "TextureManager.h"

class ModelCommon;

/// <summary>
/// 3Dãƒ¢ãƒ‡ãƒ«
/// Objãƒ•ã‚¡ã‚¤ãƒ«ã‚’èª­ã¿è¾¼ã‚€
/// </summary>
class Model
{
public:

	/// <summary>
	/// åˆæœŸåŒ–
	/// </summary>
	/// <param name="modelCommon">ãƒ¢ãƒ‡ãƒ«å…±é€šæ©Ÿèƒ½ç®¡ç†ã‚¯ãƒ©ã‚¹ã¸ã®ãƒã‚¤ãƒ³ã‚¿</param>	
	/// <param name="directoryPath">ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªãƒ‘ã‚¹</param>
	/// <param name="filename">ãƒ•ã‚¡ã‚¤ãƒ«å</param>
	void Initialize(ModelCommon* modelCommon, const std::string& directorypath, const std::string& filename);

	/// <summary>
	/// æ›´æ–°
	/// </summary>
	void UpData();

	/// <summary>
	/// æç”»
	/// </summary>
	void Draw();

	/// <summary>
	/// é ‚ç‚¹ãƒãƒƒãƒ•ã‚¡æ›´æ–°
	///	</summary>
	void UpdateVertexBuffer();

	/// <summary>
	/// ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ãƒãƒƒãƒ•ã‚¡æ›´æ–°
	/// </summary>
	void UpdateIndexBuffer();

	/// <summary>
	/// é ‚ç‚¹ãƒ‡ãƒ¼ã‚¿ã‚¯ãƒªã‚¢
	/// </summary>
	void ClearVertexData();

	/// <summary>
	/// ä»–ã®ãƒ¢ãƒ‡ãƒ«ãƒ‡ãƒ¼ã‚¿ã‚’ã‚³ãƒ”ãƒ¼
	/// </summary>
	/// <param name="other">ã‚³ãƒ”ãƒ¼å…ƒãƒ¢ãƒ‡ãƒ«ãƒ‡ãƒ¼ã‚¿</param>
	void CopyFrom(const Model& other);

private: // æ§‹é€ ä½“ã€é–¢æ•°

	struct Transform
	{
		Vector3 scale;
		Vector3 rotate;
		Vector3 translate;
	};

	struct VertexData
	{
		Vector4 position;
		Vector2 texcoord;
		Vector3 normal;
	};

	struct MaterialData
	{
		std::string textureFilePath;
		uint32_t textureIndex = 0;
	};

	struct Material
	{
		Vector4 color;
		int32_t enableLighting;
		float padding[3];
		Matrix4x4 uvTransform;
		float shininess;
		int32_t phongReflection;
		int32_t halfphongReflection;
		int32_t pointLight;
		int32_t spotLight;
		int32_t environment;
		float environmentStrength;
	};

	struct  Node
	{
		Matrix4x4 localMatrix;
		std::string name;
		std::vector<Node> children;
	};

	struct  ModelData
	{
		std::vector<VertexData> vertices;
		std::vector<uint32_t> indices;
		MaterialData material;
		Node rootNode;
	};

	//mtlãƒ•ã‚¡ã‚¤ãƒ«ã‚’èª­ã‚€é–¢æ•°
	static MaterialData LoadMaterialTemplateFile(const std::string& directoryPath, const std::string& filename);

	//Objãƒ•ã‚¡ã‚¤ãƒ«ã‚’èª­ã‚€é–¢æ•°
	static ModelData LoadObjFile(const std::string& directoryPath, const std::string& filename);

	// é ‚ç‚¹ãƒ‡ãƒ¼ã‚¿ç”Ÿæˆ
	void CreateVertexData();

	// ãƒžãƒ†ãƒªã‚¢ãƒ«ãƒ‡ãƒ¼ã‚¿ç”Ÿæˆ
	void CreateMaterialData();

	static Node ReadNode(aiNode* node);


public: // ã‚²ãƒƒã‚¿ãƒ¼

	D3D12_VERTEX_BUFFER_VIEW GetVertexBufferView()const { return vertexBufferView_; }
	ModelData GetModelData() { return modelData_; }

	uint32_t GetVertexCount() const { return static_cast<uint32_t>(modelData_.vertices.size()); }

	uint32_t GetIndexCount() const { return static_cast<uint32_t>(modelData_.indices.size()); }

	D3D12_INDEX_BUFFER_VIEW GetIndexBufferView() const { return indexBufferView_; }

public: // ã‚»ãƒƒã‚¿ãƒ¼

	// Vertexã‚’å…¥ã‚Œã‚‹
	void AddVertex(const Vector4& position, const Vector2& texcoord, const Vector3& normal);

	// indexã‚’å…¥ã‚Œã‚‹
	void AddIndex(uint32_t index);

	void SetEnableLighting(bool enable);
	void SetEnableDirectionalLight(bool enable);
	void SetEnablePointLight(bool enable);
	void SetEnableSpotLight(bool enable);
	void SetEnvironment(bool enable);
	void SetEnvironmentStrength(float strength);

	void SetModelCommon(ModelCommon* modelCommon) { modelCommon_ = modelCommon; }

private:

	ModelCommon* modelCommon_ = nullptr;

	// Objãƒ•ã‚¡ã‚¤ãƒ«ã®ãƒ‡ãƒ¼ã‚¿
	ModelData modelData_;

	// ãƒãƒƒãƒ•ã‚¡ãƒªã‚½ãƒ¼ã‚¹
	// é ‚ç‚¹ãƒªã‚½ãƒ¼ã‚¹
	Microsoft::WRL::ComPtr<ID3D12Resource> vertexResource_{};
	// ãƒžãƒ†ãƒªã‚¢ãƒ«ãƒªã‚½ãƒ¼ã‚¹
	Microsoft::WRL::ComPtr<ID3D12Resource> materialResource_{};

	// ãƒãƒƒãƒ•ã‚¡ãƒªã‚½ãƒ¼ã‚¹å†…ã®ãƒ‡ãƒ¼ã‚¿ã‚’æŒ‡ã™ãƒã‚¤ãƒ³ã‚¿
	VertexData* vertexData_ = nullptr;
	Material* materialData_ = nullptr;

	// ãƒãƒƒãƒ•ã‚¡ãƒªã‚½ãƒ¼ã‚¹ã®ä½¿ã„é“ã‚’è£œè¶³ã™ã‚‹ãƒãƒƒãƒ•ã‚¡ãƒ“ãƒ¥ãƒ¼
	D3D12_VERTEX_BUFFER_VIEW vertexBufferView_{};

	// Transform
	Transform transform_;

	// GPUä¸Šã®ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ãƒãƒƒãƒ•ã‚¡
	Microsoft::WRL::ComPtr<ID3D12Resource> indexResource_{};
	// GPUä¸Šã«ã‚»ãƒƒãƒˆã™ã‚‹ãŸã‚ã®ãƒ“ãƒ¥ãƒ¼
	D3D12_INDEX_BUFFER_VIEW indexBufferView_{};

};



============================================================
File Path: project/gameEngine/3d/ModelCommon.cpp
============================================================
#include "ModelCommon.h"

void ModelCommon::Initialize(DirectXCommon* dxCommon)
{
	dxCommon_ = dxCommon;
}


============================================================
File Path: project/gameEngine/3d/ModelCommon.h
============================================================
#pragma once

#include <d3d12.h>
//#include "externals/DirectXTex/d3dx12.h"
#include "../../externals/DirectXTex/d3dx12.h"
#include "DirectXCommon.h"
#include "Logger.h"

/// <summary>
/// ãƒ¢ãƒ‡ãƒ«å…±é€š
/// </summary>
class ModelCommon
{
public:

	/// <summary>
	/// åˆæœŸåŒ–
	/// </summary>
	/// <param name="dxCommon"> DirectXå…±é€šæ©Ÿèƒ½ç®¡ç†ã‚¯ãƒ©ã‚¹ã¸ã®ãƒã‚¤ãƒ³ã‚¿</param>
	void Initialize(DirectXCommon* dxCommon);

public: // ã‚²ãƒƒã‚¿ãƒ¼

	/// <summary>
	/// DirectXå…±é€šæ©Ÿèƒ½ç®¡ç†ã‚¯ãƒ©ã‚¹ã®å–å¾—
	/// </summary>
	DirectXCommon* GetDxCommon() const { return dxCommon_; }

private:

	DirectXCommon* dxCommon_;


};



============================================================
File Path: project/gameEngine/3d/ModelManager.cpp
============================================================
#include "ModelManager.h"

#include <filesystem>

#include "DirectXCommon.h"
#include "ModelCommon.h"

ModelManager* ModelManager::GetInstance()
{
	static ModelManager instance;
	return &instance;
}

void ModelManager::Finalize(){}

void ModelManager::Initialize(DirectXCommon* dxCommon)
{
	modelCommon_ = std::make_unique<ModelCommon>();
	modelCommon_->Initialize(dxCommon);
}

void ModelManager::LoadModel(const std::string& filePath)
{
	// ãƒ•ã‚¡ã‚¤ãƒ«ãƒ‘ã‚¹ã‹ã‚‰ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã¨ãƒ•ã‚¡ã‚¤ãƒ«åã‚’æŠ½å‡º
	std::filesystem::path path(filePath);
	std::string directory = "resources/models/" + path.parent_path().string();
	std::string fileName = path.filename().string(); // ãƒ•ã‚¡ã‚¤ãƒ«åã ã‘ã‚’æŠ½å‡º

	// èª­ã¿è¾¼ã¿æ¸ˆã¿ãƒ¢ãƒ‡ãƒ«ã‚’æ¤œç´¢
	if (models.contains(filePath)) {
		// èª­ã¿è¾¼ã¿æ¸ˆã¿ãªã‚‰æ—©æœŸ return
		return;
	}

	// ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªãŒå­˜åœ¨ã—ãªã„å ´åˆã¯ "resources/models/" ã‚’ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã«
	if (directory.empty()) {
		directory = "resources/models/";
	}

	// ãƒ¢ãƒ‡ãƒ«ã®ç”Ÿæˆã¨ãƒ•ã‚¡ã‚¤ãƒ«èª­ã¿è¾¼ã¿ãƒ»åˆæœŸåŒ– ---
	std::unique_ptr<Model> model = std::make_unique<Model>();
	model->Initialize(modelCommon_.get(), directory, fileName);

	// ãƒ¢ãƒ‡ãƒ«ã‚’mapã‚³ãƒ³ãƒ†ãƒŠã«æ ¼ç´ã™ã‚‹
	models.insert(std::make_pair(fileName, std::move(model))); // æ‰€æœ‰æ¨©ã‚’è­²æ¸¡
}

Model* ModelManager::FindModel(const std::string& filePath)
{
	// èª­ã¿è¾¼ã¿æ¸ˆã¿ãƒ¢ãƒ‡ãƒ«ã‚’æ¤œç´¢
	if (models.contains(filePath)) {
		// èª­ã¿è¾¼ã¿ãƒ¢ãƒ‡ãƒ«ã‚’æˆ»ã‚Šå€¤ã¨ã—ã¦return
		return models.at(filePath).get();
	}
	// ãƒ•ã‚¡ã‚¤ãƒ«åä¸€è‡´ç„¡ã—
	return nullptr;
}


============================================================
File Path: project/gameEngine/3d/ModelManager.h
============================================================
#pragma once

#include <string>
#include <map>
#include <memory>

#include "Model.h"

class ModelCommon;
class DirectXCommon;

/// <summary>
/// ãƒ¢ãƒ‡ãƒ«ç®¡ç†ã‚¯ãƒ©ã‚¹
/// ãƒ¢ãƒ‡ãƒ«ã®èª­ã¿è¾¼ã¿ã€æ¤œç´¢ã‚’è¡Œã†
/// </summary>
class ModelManager
{
#pragma region ã‚·ãƒ³ã‚°ãƒ«ãƒˆãƒ³ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹

private:

	ModelManager() = default;
	~ModelManager() = default;
	ModelManager(ModelManager&) = delete;
	ModelManager& operator = (ModelManager&) = delete;

public:

	// ã‚·ãƒ³ã‚°ãƒ«ãƒˆãƒ³ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã®å–å¾—
	static ModelManager* GetInstance();

	// çµ‚äº†
	void Finalize();

#pragma region ã‚·ãƒ³ã‚°ãƒ«ãƒˆãƒ³ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹

public:

	/// <summary>
	/// åˆæœŸåŒ–
	/// </summary>
	/// <param name="dxCommon">DirectXå…±é€šæ©Ÿèƒ½ç®¡ç†ã‚¯ãƒ©ã‚¹ã¸ã®ãƒã‚¤ãƒ³ã‚¿</param>
	void Initialize(DirectXCommon* dxCommon);

	/// <summary>
	/// ãƒ¢ãƒ‡ãƒ«ãƒ•ã‚¡ã‚¤ãƒ«ã®èª­ã¿è¾¼ã¿
	/// </summary>
	/// <param name="filePath">ãƒ•ã‚¡ã‚¤ãƒ«ãƒ‘ã‚¹</param>
	void LoadModel(const std::string& filePath);

	/// <summary>
	/// ãƒ¢ãƒ‡ãƒ«ã®æ¤œç´¢
	/// </summary>
	/// <param name="filePath">ãƒ•ã‚¡ã‚¤ãƒ«ãƒ‘ã‚¹</param>
	/// <returns>ãƒ¢ãƒ‡ãƒ«ãƒ‡ãƒ¼ã‚¿</returns>
	Model* FindModel(const std::string& filePath);

private:

	// ãƒ¢ãƒ‡ãƒ«ãƒ‡ãƒ¼ã‚¿
	std::map<std::string, std::unique_ptr<Model>> models;

	// ãƒ¢ãƒ‡ãƒ«å…±é€šéƒ¨
	std::unique_ptr<ModelCommon> modelCommon_ = nullptr;
};



============================================================
File Path: project/gameEngine/3d/Object3d.cpp
============================================================
#include "Object3d.h"

#include <fstream>
#include <sstream>
#include <numbers>

#include "Object3dCommon.h"
#include "Model.h"
#include "ModelManager.h"

void Object3d::Initialize(const std::string& filePath)
{
	object3dCommon_ = Object3dCommon::GetInstance();
	// ãƒ¢ãƒ‡ãƒ«ã‚’è¨­å®š
	SetModel(filePath);

	// åº§æ¨™å¤‰æ›è¡Œåˆ—ãƒªã‚½ãƒ¼ã‚¹ã‚’ä½œã‚‹
	CreateTransformationMatrixData();

	// å¹³è¡Œå…‰æºãƒªã‚½ãƒ¼ã‚¹ã‚’ä½œã‚‹
	CreateDirectionalLight();

	// Transformå¤‰æ•°ã‚’ä½œã‚‹
	transform_ = { {1.0f,1.0f,1.0f},{0.0f,0.0f,0.0f},{0.0f,4.0f,-10.0f} };

	camera_ = object3dCommon_->GetDefaultCamera();

	// ã‚«ãƒ¡ãƒ©ãƒªã‚½ãƒ¼ã‚¹ã‚’ä½œã‚‹
	CreateCamera();

	// ãƒã‚¤ãƒ³ãƒˆãƒ©ã‚¤ãƒˆãƒªã‚½ãƒ¼ã‚¹ã‚’ä½œã‚‹
	CreatePointLight();

	// ã‚¹ãƒãƒƒãƒˆãƒ©ã‚¤ãƒˆãƒªã‚½ãƒ¼ã‚¹ã‚’ä½œã‚‹
	CreateSpotLight();

	// ç’°å¢ƒãƒžãƒƒãƒ—ãƒªã‚½ãƒ¼ã‚¹ã‚’ä½œã‚‹
	CreateEnvironment();
}

void Object3d::Update()
{
	Matrix4x4 worldMatrix = MakeAffineMatrix(transform_.scale, transform_.rotate, transform_.translate);
	Matrix4x4 worldViewProjectionMatrix;
	
	model_->SetEnableLighting(enableLighting);
	model_->SetEnableDirectionalLight(directionalLightData_->enable);
	model_->SetEnablePointLight(pointLightData_->enable);
	model_->SetEnableSpotLight(spotLightData_->enable);
	model_->SetEnvironment(environmentData_->enable);
	model_->SetEnvironmentStrength(environmentData_->strength);



	if (camera_)
	{
		const Matrix4x4& viewProjectionMatrix = camera_->GetViewProjectionMatrix();
		worldViewProjectionMatrix = (worldMatrix * viewProjectionMatrix);
	}
	else
	{
		worldViewProjectionMatrix = worldMatrix;
	}

	//transformationMatrixData_->WVP = worldViewProjectionMatrix;
	//transformationMatrixData_->World = worldMatrix;

	transformationMatrixData_->WVP = model_->GetModelData().rootNode.localMatrix * worldViewProjectionMatrix;
	transformationMatrixData_->World = model_->GetModelData().rootNode.localMatrix * worldMatrix;
}

void Object3d::Draw()
{
	// TransformationMatrixCBufferã®å ´æ‰€ã‚’è¨­å®š
	object3dCommon_->GetDxCommon()->GetCommandList()->SetGraphicsRootConstantBufferView(1, transformationMatrixResource_->GetGPUVirtualAddress());
	// å¹³è¡Œå…‰æºCBufferã®å ´æ‰€ã‚’è¨­å®š
	object3dCommon_->GetDxCommon()->GetCommandList()->SetGraphicsRootConstantBufferView(3, directionalLightResource_->GetGPUVirtualAddress());
	// ã‚«ãƒ¡ãƒ©CBufferã®å ´æ‰€ã‚’è¨­å®š
	object3dCommon_->GetDxCommon()->GetCommandList()->SetGraphicsRootConstantBufferView(4, cameraResource_->GetGPUVirtualAddress());
	// ãƒã‚¤ãƒ³ãƒˆãƒ©ã‚¤ãƒˆCBufferã®å ´æ‰€ã‚’è¨­å®š
	object3dCommon_->GetDxCommon()->GetCommandList()->SetGraphicsRootConstantBufferView(5, pointLightResource_->GetGPUVirtualAddress());
	// ã‚¹ãƒãƒƒãƒˆãƒ©ã‚¤ãƒˆCBufferã®å ´æ‰€ã‚’è¨­å®š
	object3dCommon_->GetDxCommon()->GetCommandList()->SetGraphicsRootConstantBufferView(6, spotLightResource_->GetGPUVirtualAddress());

	if (environmentMapHandle_.ptr != 0) 
	{
		//object3dCommon_->GetDxCommon()->GetCommandList()->SetGraphicsRootDescriptorTable(2, environmentMapHandle_);
		//SetGraphicsRootDescriptorTable
		object3dCommon_->GetDxCommon()->GetCommandList()->SetGraphicsRootDescriptorTable(8, environmentMapHandle_);
	}

	if (model_)
	{
		model_->Draw();
	}
}

void Object3d::SetModel(const std::string& filePath)
{
	model_ = ModelManager::GetInstance()->FindModel(filePath);
	modelFilePath_ = filePath;
}

void Object3d::SetEnvironmentMapHandle(D3D12_GPU_DESCRIPTOR_HANDLE handle, bool useEnvironmentMap)
{
	environmentMapHandle_ = handle;
	environmentData_->enable = useEnvironmentMap;
}

void Object3d::CreateTransformationMatrixData()
{
	// åº§æ¨™å¤‰æ›è¡Œåˆ—ãƒªã‚½ãƒ¼ã‚¹ã‚’ä½œã‚‹
	transformationMatrixResource_ = object3dCommon_->GetDxCommon()->CreateBufferResource(sizeof(TransformationMatrix));
	//æ›¸ãè¾¼ã‚€ãŸã‚ã®ã‚¢ãƒ‰ãƒ¬ã‚¹
	transformationMatrixResource_->Map(0, nullptr, reinterpret_cast<void**>(&transformationMatrixData_));
	//å˜ä½è¡Œåˆ—ã‚’æ›¸ãè¾¼ã‚“ã§ãŠã
	transformationMatrixData_->World = MakeIdentity4x4();
	transformationMatrixData_->WVP = MakeIdentity4x4();
	transformationMatrixData_->WorldInvTranspose = InverseTranspose(transformationMatrixData_->World);
}

void Object3d::CreateDirectionalLight()
{
	// å¹³è¡Œå…‰æºãƒªã‚½ãƒ¼ã‚¹ã‚’ä½œã‚‹
	directionalLightResource_ = object3dCommon_->GetDxCommon()->CreateBufferResource(sizeof(DirectionalLight));
	//æ›¸ãè¾¼ã‚€ãŸã‚ã®ã‚¢ãƒ‰ãƒ¬ã‚¹
	directionalLightResource_->Map(0, nullptr, reinterpret_cast<void**>(&directionalLightData_));
	//ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå€¤ã¯ä»¥ä¸‹ã®ã‚ˆã†ã«ã—ã¦ãŠã
	directionalLightData_->color = { 1.0f,1.0f,1.0f,1.0f };
	directionalLightData_->direction = Normalize({ 0.0f,-1.0f,0.0f });
	directionalLightData_->intensity = 1.0f;
	directionalLightData_->enable = false;
}

void Object3d::CreateCamera()
{
	// ã‚«ãƒ¡ãƒ©ãƒªã‚½ãƒ¼ã‚¹ã‚’ä½œã‚‹
	cameraResource_ = object3dCommon_->GetDxCommon()->CreateBufferResource(sizeof(CameraForGPU));
	//æ›¸ãè¾¼ã‚€ãŸã‚ã®ã‚¢ãƒ‰ãƒ¬ã‚¹
	cameraResource_->Map(0, nullptr, reinterpret_cast<void**>(&cameraData_));
	//ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå€¤ã¯ä»¥ä¸‹ã®ã‚ˆã†ã«ã—ã¦ãŠã
	cameraData_->worldPosition = camera_->GetPosition();
}

void Object3d::CreatePointLight()
{
	// ãƒã‚¤ãƒ³ãƒˆãƒ©ã‚¤ãƒˆãƒªã‚½ãƒ¼ã‚¹ã‚’ä½œã‚‹
	pointLightResource_ = object3dCommon_->GetDxCommon()->CreateBufferResource(sizeof(PointLight));
	// æ›¸ãè¾¼ã‚€ãŸã‚ã®ã‚¢ãƒ‰ãƒ¬ã‚¹
	pointLightResource_->Map(0, nullptr, reinterpret_cast<void**>(&pointLightData_));
	// ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå€¤ã¯ä»¥ä¸‹ã®ã‚ˆã†ã«ã—ã¦ãŠã
	pointLightData_->color = { 1.0f,1.0f,1.0f,1.0f };
	pointLightData_->position = { 0.0f,0.0f,0.0f };
	pointLightData_->intensity = 1.0f;
	pointLightData_->radius = 10.0f;
	pointLightData_->decay = 1.0f;
	pointLightData_->enable = false;
}

void Object3d::CreateSpotLight()
{
	// ã‚¹ãƒãƒƒãƒˆãƒ©ã‚¤ãƒˆãƒªã‚½ãƒ¼ã‚¹ã‚’ä½œã‚‹
	spotLightResource_ = object3dCommon_->GetDxCommon()->CreateBufferResource(sizeof(SpotLight));
	// æ›¸ãè¾¼ã‚€ãŸã‚ã®ã‚¢ãƒ‰ãƒ¬ã‚¹
	spotLightResource_->Map(0, nullptr, reinterpret_cast<void**>(&spotLightData_));
	// ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå€¤ã¯ä»¥ä¸‹ã®ã‚ˆã†ã«ã—ã¦ãŠã
	spotLightData_->color = { 1.0f,1.0f,1.0f,1.0f };
	spotLightData_->position = { 2.0f,1.25f,0.0f };
	spotLightData_->intensity = 4.0f;
	spotLightData_->direction = Normalize({ 0.0f,-1.0f,0.0f });
	spotLightData_->distance = 7.0f;
	spotLightData_->decay = 2.0f;
	spotLightData_->consAngle = std::cos(std::numbers::pi_v<float> / 3.0f);
	spotLightData_->cosFalloffStart = 1.0f;
	spotLightData_->enable = false;
}

void Object3d::CreateEnvironment()
{
	// ç’°å¢ƒãƒžãƒƒãƒ—ãƒªã‚½ãƒ¼ã‚¹ã‚’ä½œã‚‹
	environmentResource_ = object3dCommon_->GetDxCommon()->CreateBufferResource(sizeof(Environment));
	// æ›¸ãè¾¼ã‚€ãŸã‚ã®ã‚¢ãƒ‰ãƒ¬ã‚¹
	environmentResource_->Map(0, nullptr, reinterpret_cast<void**>(&environmentData_));
	// ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå€¤ã¯ä»¥ä¸‹ã®ã‚ˆã†ã«ã—ã¦ãŠã
	environmentData_->enable = false;
	environmentData_->strength = 0.5f;
}

std::string Object3d::GetModel() const
{
	return modelFilePath_;
}


============================================================
File Path: project/gameEngine/3d/Object3d.h
============================================================
#pragma once

#include "MyMath.h"
#include "TextureManager.h"
#include "CameraManager.h"

class Object3dCommon;
class Model;

/// <summary>
/// 3Dã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ
/// </summary>
class Object3d
{
public:

	/// <summary>
	/// åˆæœŸåŒ–
	/// </summary>
	/// <param name="filePath">ãƒ¢ãƒ‡ãƒ«ãƒ•ã‚¡ã‚¤ãƒ«ã®ãƒ‘ã‚¹</param>
	void Initialize(const std::string& filePath);

	/// <summary>
	/// æ›´æ–°å‡¦ç†
	/// </summary>
	void Update();

	/// <summary>
	/// æç”»å‡¦ç†
	/// </summary>
	void Draw();

public: // ã‚»ãƒƒã‚¿ãƒ¼

	/// <summary>
	/// ã‚«ãƒ¡ãƒ©è¨­å®š
	/// </summary>
	/// <param name="camera">ã‚«ãƒ¡ãƒ©</param>
	void SetCamera(std::shared_ptr<Camera> camera) { camera_ = camera; }

	/// <summary>
	/// ãƒ¢ãƒ‡ãƒ«è¨­å®š
	/// </summary>
	/// <param name="model">ãƒ¢ãƒ‡ãƒ«</param>
	void SetModel(Model* model) { model_ = model; }

	/// <summary>
	/// ãƒ¢ãƒ‡ãƒ«è¨­å®š(ãƒ•ã‚¡ã‚¤ãƒ«ãƒ‘ã‚¹ã‹ã‚‰)
	/// </summary>
	/// <param name="filePath">ãƒ¢ãƒ‡ãƒ«ãƒ•ã‚¡ã‚¤ãƒ«ã®ãƒ‘ã‚¹</param>
	void SetModel(const std::string& filePath);

	/// <summary>
	/// ã‚¹ã‚±ãƒ¼ãƒ«è¨­å®š
	/// </summary>
	/// <param name="scale">ã‚¹ã‚±ãƒ¼ãƒ«</param>
	void SetScale(const Vector3& scale) { transform_.scale = scale; }

	/// <summary>
	/// å›žè»¢è¨­å®š
	/// </summary>
	/// <param name="rotate">å›žè»¢</param>
	void SetRotate(const Vector3& rotate) { transform_.rotate = rotate; }

	/// <summary>
	/// ä½ç½®è¨­å®š
	/// </summary>
	/// <param name="translate">ä½ç½®</param>
	void SetPosition(const Vector3& translate) { transform_.translate = translate; }

	/// <summary>
	/// ç’°å¢ƒãƒžãƒƒãƒ—è¨­å®š
	/// </summary>
	/// <param name="handle">ç’°å¢ƒãƒžãƒƒãƒ—ã®ãƒ‡ã‚£ã‚¹ã‚¯ãƒªãƒ—ã‚¿ãƒãƒ³ãƒ‰ãƒ«</param>
	/// <param name="useEnvironmentMap">ç’°å¢ƒãƒžãƒƒãƒ—ã‚’ä½¿ç”¨ã™ã‚‹ã‹ã©ã†ã‹</param>
	void SetEnvironmentMapHandle(D3D12_GPU_DESCRIPTOR_HANDLE handle, bool useEnvironmentMap);

public: // ã‚²ãƒƒã‚¿ãƒ¼

	// ã‚¹ã‚±ãƒ¼ãƒ«å–å¾—
	const Vector3& GetScale() const { return transform_.scale; }

	// å›žè»¢å–å¾—
	const Vector3& GetRotate() const { return transform_.rotate; }

	// ä½ç½®å–å¾—
	const Vector3& GetPosition() const { return transform_.translate; }

	// ãƒ¢ãƒ‡ãƒ«å–å¾—
	std::string GetModel() const;

private:

	struct TransformationMatrix
	{
		Matrix4x4 WVP;
		Matrix4x4 World;
		Matrix4x4 WorldInvTranspose;
	};

	struct DirectionalLight
	{
		Vector4 color;
		Vector3 direction;
		float intensity;
		bool enable;
	};

	struct Transform
	{
		Vector3 scale;
		Vector3 rotate;
		Vector3 translate;
	};

	struct CameraForGPU
	{
		Vector3 worldPosition;
	};

	struct PointLight
	{
		Vector4 color;
		Vector3 position;
		float intensity;
		float radius;
		float decay;
		bool enable;
		char padding[3];
	};

	struct SpotLight
	{
		Vector4 color;
		Vector3 position;
		Vector3 direction;
		float intensity;
		float distance;
		float decay;
		float consAngle;
		float cosFalloffStart;
		bool enable;
	};

	struct Environment
	{
		bool enable;
		float strength;
	};

public: // ãƒ©ã‚¤ãƒˆç­‰

	/// <summary>
	/// åº§æ¨™å¤‰æ›è¡Œåˆ—ãƒ‡ãƒ¼ã‚¿ç”Ÿæˆ
	/// </summary>
	void CreateTransformationMatrixData();

	/// <summary>
	/// å¹³è¡Œå…‰æºãƒ‡ãƒ¼ã‚¿ç”Ÿæˆ
	/// </summary>
	void CreateDirectionalLight();
	/// <summary>
	/// å¹³è¡Œå…‰æºè¨­å®š
	/// </summary>
	/// <param name="directionalLight">å¹³è¡Œå…‰æºãƒ‡ãƒ¼ã‚¿</param>
	void SetDirectionalLight(const DirectionalLight& directionalLight) { *directionalLightData_ = directionalLight; }
	/// <summary>
	/// å¹³è¡Œå…‰æºå–å¾—
	/// </summary>
	/// <returns>å¹³è¡Œå…‰æºãƒ‡ãƒ¼ã‚¿</returns>
	DirectionalLight GetDirectionalLight() { return *directionalLightData_; }
	/// <summary>
	/// å¹³è¡Œå…‰æºã®æ–¹å‘è¨­å®š
	/// </summary>
	/// <param name="direction">æ–¹å‘ãƒ™ã‚¯ãƒˆãƒ«</param>
	void SetDirectionalLightDirection(const Vector3& direction) { directionalLightData_->direction = direction; }
	/// <summary>
	/// å¹³è¡Œå…‰æºã®è‰²è¨­å®š
	/// </summary>
	/// <param name="color">è‰²ãƒ™ã‚¯ãƒˆãƒ«</param>
	void SetDirectionalLightColor(const Vector4& color) { directionalLightData_->color = color; }
	/// <summary>
	/// å¹³è¡Œå…‰æºã®å¼·ã•è¨­å®š
	/// </summary>
	/// <param name="intensity">å¼·ã•</param>
	void SetDirectionalLightIntensity(float intensity) { directionalLightData_->intensity = intensity; }
	
	/// <summary>
	/// å¹³è¡Œå…‰æºã®ã‚ªãƒ³ã‚ªãƒ•è¨­å®š
	/// </summary>
	/// <param name="enable"> ã‚ªãƒ³ã‚ªãƒ•ãƒ•ãƒ©ã‚°</param>
	void SetDirectionalLightEnable(bool enable) { directionalLightData_->enable = enable; }

	/// <summary>
	/// ã‚«ãƒ¡ãƒ©ãƒ‡ãƒ¼ã‚¿ç”Ÿæˆ
	/// </summary>
	void CreateCamera();

	/// <summary>
	/// ãƒã‚¤ãƒ³ãƒˆãƒ©ã‚¤ãƒˆãƒ‡ãƒ¼ã‚¿ç”Ÿæˆ
	/// </summary>
	void CreatePointLight();
	/// <summary>
	/// ãƒã‚¤ãƒ³ãƒˆãƒ©ã‚¤ãƒˆè¨­å®š
	/// </summary>
	/// <param name="pointLight">ãƒã‚¤ãƒ³ãƒˆãƒ©ã‚¤ãƒˆãƒ‡ãƒ¼ã‚¿</param>
	void SetPointLight(const PointLight& pointLight) { *pointLightData_ = pointLight; }
	/// <summary>
	/// ãƒã‚¤ãƒ³ãƒˆãƒ©ã‚¤ãƒˆå–å¾—
	/// </summary>
	/// <returns>ãƒã‚¤ãƒ³ãƒˆãƒ©ã‚¤ãƒˆãƒ‡ãƒ¼ã‚¿</returns>
	PointLight GetPointLight() { return *pointLightData_; }
	/// <summary>
	/// ãƒã‚¤ãƒ³ãƒˆãƒ©ã‚¤ãƒˆã®ä½ç½®è¨­å®š
	/// </summary>
	/// <param name="position">ä½ç½®ãƒ™ã‚¯ãƒˆãƒ«</param>
	void SetPointLightPosition(const Vector3& position) { pointLightData_->position = position; }
	/// <summary>
	/// ãƒã‚¤ãƒ³ãƒˆãƒ©ã‚¤ãƒˆã®è‰²è¨­å®š
	/// </summary>
	/// <param name="color">è‰²ãƒ™ã‚¯ãƒˆãƒ«</param>
	void SetPointLightColor(const Vector4& color) { pointLightData_->color = color; }
	/// <summary>
	/// ãƒã‚¤ãƒ³ãƒˆãƒ©ã‚¤ãƒˆã®å¼·ã•è¨­å®š
	/// </summary>
	/// <param name="intensity">å¼·ã•</param>
	void SetPointLightIntensity(float intensity) { pointLightData_->intensity = intensity; }
	/// <summary>
	/// ãƒã‚¤ãƒ³ãƒˆãƒ©ã‚¤ãƒˆã®è·é›¢è¨­å®š
	/// </summary>
	/// <param name="radius">è·é›¢</param>
	void SetPointLightRadius(float radius) { pointLightData_->radius = radius; }
	/// <summary>
	/// ãƒã‚¤ãƒ³ãƒˆãƒ©ã‚¤ãƒˆã®è·é›¢å–å¾—
	/// </summary>
	/// <returns>è·é›¢</returns>
	float GetPointLightRadius() { return pointLightData_->radius; }
	/// <summary>
	/// ãƒã‚¤ãƒ³ãƒˆãƒ©ã‚¤ãƒˆã®æ¸›è¡°çŽ‡è¨­å®š
	/// </summary>
	/// <param name="decay">æ¸›è¡°çŽ‡</param>
	void SetPointLightDecay(float decay) { pointLightData_->decay = decay; }
	/// <summary>
	/// ãƒã‚¤ãƒ³ãƒˆãƒ©ã‚¤ãƒˆã®æ¸›è¡°çŽ‡å–å¾—
	/// </summary>
	/// <returns>æ¸›è¡°çŽ‡</returns>
	float GetPointLightDecay() { return pointLightData_->decay; }
	/// <summary>
	/// ãƒã‚¤ãƒ³ãƒˆãƒ©ã‚¤ãƒˆã®ã‚ªãƒ³ã‚ªãƒ•è¨­å®š
	/// </summary>
	/// <param name="enable">ã‚ªãƒ³ã‚ªãƒ•ãƒ•ãƒ©ã‚°</param>
	void SetPointLightEnable(bool enable) { pointLightData_->enable = enable; }

	
	/// <summary>
	/// ã‚¹ãƒãƒƒãƒˆãƒ©ã‚¤ãƒˆãƒ‡ãƒ¼ã‚¿ç”Ÿæˆ
	/// </summary>
	void CreateSpotLight();
	/// <summary>
	/// ã‚¹ãƒãƒƒãƒˆãƒ©ã‚¤ãƒˆè¨­å®š
	/// </summary>
	/// <param name="spotLight">ã‚¹ãƒãƒƒãƒˆãƒ©ã‚¤ãƒˆãƒ‡ãƒ¼ã‚¿</param>
	void SetSpotLight(const SpotLight& spotLight) { *spotLightData_ = spotLight; }
	/// <summary>
	/// ã‚¹ãƒãƒƒãƒˆãƒ©ã‚¤ãƒˆå–å¾—
	/// </summary>
	/// <returns>ã‚¹ãƒãƒƒãƒˆãƒ©ã‚¤ãƒˆãƒ‡ãƒ¼ã‚¿</returns>
	SpotLight GetSpotLight() { return *spotLightData_; }
	/// <summary>
	/// ã‚¹ãƒãƒƒãƒˆãƒ©ã‚¤ãƒˆã®ä½ç½®
	/// </summary>
	/// <param name="position">ä½ç½®ãƒ™ã‚¯ãƒˆãƒ«</param>
	void SetSpotLightPosition(const Vector3& position) { spotLightData_->position = position; }
	/// <summary>
	/// ã‚¹ãƒãƒƒãƒˆãƒ©ã‚¤ãƒˆã®æ–¹å‘è¨­å®š
	/// </summary>
	/// <param name="direction">æ–¹å‘ãƒ™ã‚¯ãƒˆãƒ«</param>
	void SetSpotLightDirection(const Vector3& direction) { spotLightData_->direction = direction; }
	/// <summary>
	/// ã‚¹ãƒãƒƒãƒˆãƒ©ã‚¤ãƒˆã®è‰²è¨­å®š
	/// </summary>
	/// <param name="color">è‰²ãƒ™ã‚¯ãƒˆãƒ«</param>
	void SetSpotLightColor(const Vector4& color) { spotLightData_->color = color; }
	/// <summary>
	/// ã‚¹ãƒãƒƒãƒˆãƒ©ã‚¤ãƒˆã®å¼·ã•è¨­å®š
	/// </summary>
	/// <param name="intensity">å¼·ã•</param>
	void SetSpotLightIntensity(float intensity) { spotLightData_->intensity = intensity; }
	/// <summary>
	/// ã‚¹ãƒãƒƒãƒˆãƒ©ã‚¤ãƒˆã®è·é›¢è¨­å®š
	/// </summary>
	/// <param name="distance">è·é›¢</param>
	void SetSpotLightDistance(float distance) { spotLightData_->distance = distance; }
	/// <summary>
	/// ã‚¹ãƒãƒƒãƒˆãƒ©ã‚¤ãƒˆã®æ¸›è¡°çŽ‡è¨­å®š
	/// </summary>
	/// <param name="decay">æ¸›è¡°çŽ‡</param>
	void SetSpotLightDecay(float decay) { spotLightData_->decay = decay; }
	/// <summary>
	/// ã‚¹ãƒãƒƒãƒˆãƒ©ã‚¤ãƒˆã®ã‚³ãƒ¼ãƒ³è§’åº¦è¨­å®š
	/// </summary>
	/// <param name="consAngle">ã‚³ãƒ¼ãƒ³è§’åº¦</param>
	void SetSpotLightConsAngle(float consAngle) { spotLightData_->consAngle = consAngle; }
	/// <summary>
	/// ã‚¹ãƒãƒƒãƒˆãƒ©ã‚¤ãƒˆã®ã‚³ãƒ¼ãƒ³å¤–å´æ¸›è¡°é–‹å§‹è§’åº¦ã®ä½™å¼¦è¨­å®š
	/// </summary>
	/// <param name="cosFalloffStart">ã‚³ãƒ¼ãƒ³å¤–å´æ¸›è¡°é–‹å§‹è§’åº¦ã®ä½™å¼¦</param>
	void SetSpotLightCosFalloffStart(float cosFalloffStart) { spotLightData_->cosFalloffStart = cosFalloffStart; }
	/// <summary>
	/// ã‚¹ãƒãƒƒãƒˆãƒ©ã‚¤ãƒˆã®ã‚ªãƒ³ã‚ªãƒ•è¨­å®š
	/// </summary>
	/// <param name="enable">ã‚ªãƒ³ã‚ªãƒ•ãƒ•ãƒ©ã‚°</param>
	void SetSpotLightEnable(bool enable) { spotLightData_->enable = enable; }

	
	/// <summary>
	/// ãƒ©ã‚¤ãƒ†ã‚£ãƒ³ã‚°ã®ã‚ªãƒ³ã‚ªãƒ•è¨­å®š
	/// </summary>
	/// <param name="enable">ã‚ªãƒ³ã‚ªãƒ•ãƒ•ãƒ©ã‚°</param>
	void SetLighting(bool enable) { enableLighting = enable; }

	/// <summary>
	/// ç’°å¢ƒãƒžãƒƒãƒ—ãƒ‡ãƒ¼ã‚¿ç”Ÿæˆ
	/// </summary>
	void CreateEnvironment();
	/// <summary>
	/// ç’°å¢ƒãƒžãƒƒãƒ—ã®ã‚ªãƒ³ã‚ªãƒ•è¨­å®š
	/// </summary>
	/// <param name="enable">ã‚ªãƒ³ã‚ªãƒ•ãƒ•ãƒ©ã‚°</param>
	void IsEnvironment(bool enable) { environmentData_->enable = enable; }
	/// <summary>
	/// ç’°å¢ƒãƒžãƒƒãƒ—ã®å¼·ã•è¨­å®š
	/// </summary>
	/// <param name="strength">å¼·ã•</param>
	void SetEnvironmentStrength(float strength) { environmentData_->strength = strength; }

private:

	Object3dCommon* object3dCommon_ = nullptr;
	
	std::shared_ptr<Camera> camera_ = nullptr;

	Model* model_ = nullptr;
	
	//TransformationMatrixç”¨ã®ãƒªã‚½ãƒ¼ã‚¹
	Microsoft::WRL::ComPtr<ID3D12Resource> transformationMatrixResource_{};
	// å¹³è¡Œå…‰æºãƒªã‚½ãƒ¼ã‚¹
	Microsoft::WRL::ComPtr<ID3D12Resource> directionalLightResource_{};
	// ã‚«ãƒ¡ãƒ©ãƒªã‚½ãƒ¼ã‚¹
	Microsoft::WRL::ComPtr<ID3D12Resource> cameraResource_{};
	// ãƒã‚¤ãƒ³ãƒˆãƒ©ã‚¤ãƒˆãƒªã‚½ãƒ¼ã‚¹
	Microsoft::WRL::ComPtr<ID3D12Resource> pointLightResource_{};
	// ã‚¹ãƒãƒƒãƒˆãƒ©ã‚¤ãƒˆãƒªã‚½ãƒ¼ã‚¹
	Microsoft::WRL::ComPtr<ID3D12Resource> spotLightResource_{};
	// ç’°å¢ƒãƒžãƒƒãƒ—ãƒªã‚½ãƒ¼ã‚¹
	Microsoft::WRL::ComPtr<ID3D12Resource> environmentResource_{};


	//// ãƒãƒƒãƒ•ã‚¡ãƒªã‚½ãƒ¼ã‚¹å†…ã®ãƒ‡ãƒ¼ã‚¿ã‚’æŒ‡ã™ãƒã‚¤ãƒ³ã‚¿
	TransformationMatrix* transformationMatrixData_ = nullptr;
	DirectionalLight* directionalLightData_ = nullptr;
	CameraForGPU* cameraData_ = nullptr;
	PointLight* pointLightData_ = nullptr;
	SpotLight* spotLightData_ = nullptr;
	Environment* environmentData_ = nullptr;

	D3D12_GPU_DESCRIPTOR_HANDLE environmentMapHandle_ = { 0 };

	Transform transform_{};

	//ãƒ©ã‚¤ãƒˆã®ã‚ªãƒ³ã‚ªãƒ•
	bool enableLighting = false;

	std::string modelFilePath_;
};



============================================================
File Path: project/gameEngine/3d/Object3dCommon.cpp
============================================================
#include "Object3dCommon.h"

Object3dCommon* Object3dCommon::GetInstance()
{
	static Object3dCommon instance;
	return &instance;
}

void Object3dCommon::Finalize(){}



void Object3dCommon::Initialize(DirectXCommon* dxCommon)
{
	dxCommon_ = dxCommon;
	device_ = dxCommon_->GetDevice();
	commandList_ = dxCommon_->GetCommandList();
	

	CreateGraphicsPipeline();
}

void Object3dCommon::CreateRootSignature()
{
	HRESULT result = S_FALSE;

	//ãƒ‡ã‚£ã‚¹ã‚¯ãƒªãƒ—ã‚¿ãƒ¬ãƒ³ã‚¸ã®ç”Ÿæˆ
	descriptorRange_[0].BaseShaderRegister = 0;
	descriptorRange_[0].NumDescriptors = 1;
	descriptorRange_[0].RangeType = D3D12_DESCRIPTOR_RANGE_TYPE_SRV;
	descriptorRange_[0].OffsetInDescriptorsFromTableStart = D3D12_DESCRIPTOR_RANGE_OFFSET_APPEND;

	// ç’°å¢ƒãƒžãƒƒãƒ—ç”¨ã®ãƒ‡ã‚£ã‚¹ã‚¯ãƒªãƒ—ã‚¿ãƒ¬ãƒ³ã‚¸
	descriptorRange_[1].BaseShaderRegister = 1; // æ–°ã—ã„CBVã®ãƒ¬ã‚¸ã‚¹ã‚¿ç•ªå·
	descriptorRange_[1].NumDescriptors = 1; // æ–°ã—ã„CBVã¯1ã¤
	descriptorRange_[1].RangeType = D3D12_DESCRIPTOR_RANGE_TYPE_SRV; // æ–°ã—ã„CBVã®ã‚¿ã‚¤ãƒ—
	descriptorRange_[1].OffsetInDescriptorsFromTableStart = D3D12_DESCRIPTOR_RANGE_OFFSET_APPEND;
	
	descriptionRootSignature_.Flags = D3D12_ROOT_SIGNATURE_FLAG_ALLOW_INPUT_ASSEMBLER_INPUT_LAYOUT;

	//RootParameterä½œæˆã€‚è¤‡æ•°è¨­å®šã§ãã‚‹ã®ã§é…åˆ—ã€‚ä»Šå›žã¯çµæžœï¼‘ã¤ã ã‘ãªã®ã§é•·ã•ï¼‘ã®é…åˆ—
	rootParameters_[0].ParameterType = D3D12_ROOT_PARAMETER_TYPE_CBV;		//CBVã‚’ä½¿ã†
	rootParameters_[0].ShaderVisibility = D3D12_SHADER_VISIBILITY_PIXEL;		//PixelShaderã§ä½¿ã†
	rootParameters_[0].Descriptor.ShaderRegister = 0;						//ãƒ¬ã‚¸ã‚¹ã‚¿ç•ªå·ï¼ã¨ãƒã‚¤ãƒ³ãƒ‰

	rootParameters_[1].ParameterType = D3D12_ROOT_PARAMETER_TYPE_CBV;
	rootParameters_[1].ShaderVisibility = D3D12_SHADER_VISIBILITY_VERTEX;
	rootParameters_[1].Descriptor.ShaderRegister = 0;

	rootParameters_[2].ParameterType = D3D12_ROOT_PARAMETER_TYPE_DESCRIPTOR_TABLE;			//DescriptorTableã‚’ä½¿ã†
	rootParameters_[2].ShaderVisibility = D3D12_SHADER_VISIBILITY_PIXEL;						//PixelShaderã§ä½¿ã†
	rootParameters_[2].DescriptorTable.pDescriptorRanges = &descriptorRange_[0]; 				//Tableã®ä¸­èº«ã®é…åˆ—ã‚’æŒ‡å®š
	rootParameters_[2].DescriptorTable.NumDescriptorRanges = 1;		//Tableã§åˆ©ç”¨ã™ã‚‹æ•°

	rootParameters_[3].ParameterType = D3D12_ROOT_PARAMETER_TYPE_CBV;
	rootParameters_[3].ShaderVisibility = D3D12_SHADER_VISIBILITY_PIXEL;
	rootParameters_[3].Descriptor.ShaderRegister = 1;

	// æ–°ã—ã„CBVã‚’è¿½åŠ 
	rootParameters_[4].ParameterType = D3D12_ROOT_PARAMETER_TYPE_CBV;
	rootParameters_[4].ShaderVisibility = D3D12_SHADER_VISIBILITY_PIXEL;
	rootParameters_[4].Descriptor.ShaderRegister = 2;

	// æ–°ã—ã„CBVã‚’è¿½åŠ 
	rootParameters_[5].ParameterType = D3D12_ROOT_PARAMETER_TYPE_CBV;
	rootParameters_[5].ShaderVisibility = D3D12_SHADER_VISIBILITY_PIXEL;
	rootParameters_[5].Descriptor.ShaderRegister = 3;

	// æ–°ã—ã„CBVã‚’è¿½åŠ 
	rootParameters_[6].ParameterType = D3D12_ROOT_PARAMETER_TYPE_CBV;
	rootParameters_[6].ShaderVisibility = D3D12_SHADER_VISIBILITY_PIXEL;
	rootParameters_[6].Descriptor.ShaderRegister = 4;

	// æ–°ã—ã„CBVã‚’è¿½åŠ 
	rootParameters_[7].ParameterType = D3D12_ROOT_PARAMETER_TYPE_CBV;
	rootParameters_[7].ShaderVisibility = D3D12_SHADER_VISIBILITY_PIXEL;
	rootParameters_[7].Descriptor.ShaderRegister = 5;

	// ç’°å¢ƒãƒžãƒƒãƒ—ç”¨ã®ãƒ«ãƒ¼ãƒˆãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã‚’è¿½åŠ 
	rootParameters_[8].ParameterType = D3D12_ROOT_PARAMETER_TYPE_DESCRIPTOR_TABLE;			//DescriptorTableã‚’ä½¿ã†
	rootParameters_[8].ShaderVisibility = D3D12_SHADER_VISIBILITY_PIXEL;						//PixelShaderã§ä½¿ã†
	rootParameters_[8].DescriptorTable.pDescriptorRanges = &descriptorRange_[1]; 				//Tableã®ä¸­èº«ã®é…åˆ—ã‚’æŒ‡å®š
	rootParameters_[8].DescriptorTable.NumDescriptorRanges = 1;		//Tableã§åˆ©ç”¨ã™ã‚‹æ•°

	descriptionRootSignature_.pParameters = rootParameters_;					//ãƒ«ãƒ¼ãƒˆãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿é…åˆ—ã¸ã®ãƒã‚¤ãƒ³ã‚¿
	descriptionRootSignature_.NumParameters = _countof(rootParameters_);		//é…åˆ—ã®é•·ã•

	//Smaplerã®è¨­å®š
	staticSamplers_[0].Filter = D3D12_FILTER_MIN_MAG_MIP_LINEAR;				//ãƒã‚¤ãƒªãƒ‹ã‚¢ãƒ•ã‚£ãƒ«ã‚¿
	staticSamplers_[0].AddressU = D3D12_TEXTURE_ADDRESS_MODE_WRAP;			//0ï½ž1ã®ç¯„å›²å¤–ã‚’ãƒªãƒ”ãƒ¼ãƒˆ
	staticSamplers_[0].AddressV = D3D12_TEXTURE_ADDRESS_MODE_WRAP;
	staticSamplers_[0].AddressW = D3D12_TEXTURE_ADDRESS_MODE_WRAP;
	staticSamplers_[0].ComparisonFunc = D3D12_COMPARISON_FUNC_NEVER;			//æ¯”è¼ƒã—ãªã„
	staticSamplers_[0].MaxLOD = D3D12_FLOAT32_MAX;							//ã‚ã‚Šã£ãŸã‘ã®Mipmapã‚’ä½¿ã†
	staticSamplers_[0].ShaderRegister = 0;									//ãƒ¬ã‚¸ã‚¹ã‚¿ç•ªå·0ã‚’ä½¿ã†
	staticSamplers_[0].ShaderVisibility = D3D12_SHADER_VISIBILITY_PIXEL;		//PixelShaderã‚’ä½¿ã†
	descriptionRootSignature_.pStaticSamplers = staticSamplers_;
	descriptionRootSignature_.NumStaticSamplers = _countof(staticSamplers_);

	

	//ã‚·ãƒªã‚¢ãƒ©ã‚¤ã‚ºã—ã¦ãƒã‚¤ãƒŠãƒªã™ã‚‹
	ID3DBlob* signatureBlob = nullptr;
	ID3DBlob* errorBlob = nullptr;
	result = D3D12SerializeRootSignature(&descriptionRootSignature_, D3D_ROOT_SIGNATURE_VERSION_1, &signatureBlob, &errorBlob);
	if (FAILED(result))
	{
		Logger::Log(reinterpret_cast<char*>(errorBlob->GetBufferPointer()));
		assert(false);
	}
	//ãƒã‚¤ãƒŠãƒªã‚’ã‚‚ã¨ã«ç”Ÿæˆ
	result = device_->CreateRootSignature(0, signatureBlob->GetBufferPointer(), signatureBlob->GetBufferSize(), IID_PPV_ARGS(&rootSignature_));
	assert(SUCCEEDED(result));


	// InputLayoutã®è¨­å®š
	inputElementDescs_[0].SemanticName = "POSITION";
	inputElementDescs_[0].SemanticIndex = 0;
	inputElementDescs_[0].Format = DXGI_FORMAT_R32G32B32A32_FLOAT;
	inputElementDescs_[0].AlignedByteOffset = D3D12_APPEND_ALIGNED_ELEMENT;

	inputElementDescs_[1].SemanticName = "TEXCOORD";
	inputElementDescs_[1].SemanticIndex = 0;
	inputElementDescs_[1].Format = DXGI_FORMAT_R32G32_FLOAT;
	inputElementDescs_[1].AlignedByteOffset = D3D12_APPEND_ALIGNED_ELEMENT;

	inputElementDescs_[2].SemanticName = "NORMAL";
	inputElementDescs_[2].SemanticIndex = 0;
	inputElementDescs_[2].Format = DXGI_FORMAT_R32G32B32_FLOAT;
	inputElementDescs_[2].AlignedByteOffset = D3D12_APPEND_ALIGNED_ELEMENT;

	inputLayoutDesc_.pInputElementDescs = inputElementDescs_;
	inputLayoutDesc_.NumElements = _countof(inputElementDescs_);

	// BlendStateã®è¨­å®š
	// å…¨ã¦ã®è‰²è¦ç´ ã‚’æ›¸ãè¾¼ã‚€
	blendDesc_.RenderTarget[0].RenderTargetWriteMask = D3D12_COLOR_WRITE_ENABLE_ALL;
	
	blendDesc_.RenderTarget[0].BlendEnable = TRUE;
	blendDesc_.RenderTarget[0].SrcBlend = D3D12_BLEND_SRC_ALPHA;
	blendDesc_.RenderTarget[0].DestBlend = D3D12_BLEND_INV_SRC_ALPHA;
	blendDesc_.RenderTarget[0].BlendOp = D3D12_BLEND_OP_ADD;
	blendDesc_.RenderTarget[0].SrcBlendAlpha = D3D12_BLEND_ONE;
	blendDesc_.RenderTarget[0].DestBlendAlpha = D3D12_BLEND_ZERO;
	blendDesc_.RenderTarget[0].BlendOpAlpha = D3D12_BLEND_OP_ADD;


	// RasterizerStateã®è¨­å®š
	// è£é¢(æ™‚è¨ˆå›žã‚Š)ã®è¡¨ç¤ºã®æœ‰ç„¡ (NONE / BACK)
	rasterizerDesc_.CullMode = D3D12_CULL_MODE_NONE;
	// å¡—ã‚Šã¤ã¶ã™ã‹ã©ã†ã‹
	rasterizerDesc_.FillMode = D3D12_FILL_MODE_SOLID;

	// Shaderã‚’ã‚³ãƒ³ãƒ‘ã‚¤ãƒ« 
	vertexShaderBlob_ = dxCommon_->CompileShader(L"resources/shaders/Object3d.VS.hlsl", L"vs_6_0");
	assert(vertexShaderBlob_ != nullptr);
	pixelShaderBlob_ = dxCommon_->CompileShader(L"resources/shaders/Object3d.PS.hlsl", L"ps_6_0");
	assert(pixelShaderBlob_ != nullptr);

	// DepthStencilStateã®è¨­å®š
	// Depthã®æ©Ÿèƒ½ã‚’æœ‰åŠ¹åŒ–
	depthStencilDesc_.DepthEnable = true;
	depthStencilDesc_.DepthWriteMask = D3D12_DEPTH_WRITE_MASK_ALL;
	depthStencilDesc_.DepthFunc = D3D12_COMPARISON_FUNC_LESS_EQUAL;
}

void Object3dCommon::CreateGraphicsPipeline()
{
	HRESULT result = S_FALSE;

	CreateRootSignature();


	D3D12_GRAPHICS_PIPELINE_STATE_DESC graphicsPipelineStateDesc{};
	graphicsPipelineStateDesc.pRootSignature = rootSignature_.Get();
	graphicsPipelineStateDesc.InputLayout = inputLayoutDesc_;
	graphicsPipelineStateDesc.VS = { vertexShaderBlob_->GetBufferPointer(),vertexShaderBlob_->GetBufferSize() };
	graphicsPipelineStateDesc.PS = { pixelShaderBlob_->GetBufferPointer(),pixelShaderBlob_->GetBufferSize() };
	graphicsPipelineStateDesc.BlendState = blendDesc_;
	graphicsPipelineStateDesc.RasterizerState = rasterizerDesc_;
	//DepthStencilã®è¨­å®š
	graphicsPipelineStateDesc.DepthStencilState = depthStencilDesc_;
	graphicsPipelineStateDesc.DSVFormat = DXGI_FORMAT_D24_UNORM_S8_UINT;




	//æ›¸ãè¾¼ã‚€RTVã®æƒ…å ±
	graphicsPipelineStateDesc.NumRenderTargets = 1;
	graphicsPipelineStateDesc.RTVFormats[0] = DXGI_FORMAT_R8G8B8A8_UNORM_SRGB;
	//åˆ©ç”¨ã™ã‚‹ãƒˆãƒãƒ­ã‚¸ï¼ˆå½¢çŠ¶ï¼‰ã®ã‚¿ã‚¤ãƒ—ã€‚ä¸‰è§’å½¢
	graphicsPipelineStateDesc.PrimitiveTopologyType = D3D12_PRIMITIVE_TOPOLOGY_TYPE_TRIANGLE;
	//ã©ã®ã‚ˆã†ã«ç”»é¢ã«è‰²ã‚’æ‰“ã¡è¾¼ã‚€ã‹ã®è¨­å®šï¼ˆæ°—ã«ã—ãªãã¦ã„ã„ï¼‰
	graphicsPipelineStateDesc.SampleDesc.Count = 1;
	graphicsPipelineStateDesc.SampleMask = D3D12_DEFAULT_SAMPLE_MASK;

	//å®Ÿéš›ã«ç”Ÿæˆ
	result = device_->CreateGraphicsPipelineState(&graphicsPipelineStateDesc, IID_PPV_ARGS(&graphicsPipelineState_));
	assert(SUCCEEDED(result));

	// ã‚«ãƒªãƒ³ã‚°ã—ãªã„ï¼ˆè£é¢ã‚‚è¡¨ç¤ºã•ã›ã‚‹ï¼‰
	rasterizerDesc_.CullMode = D3D12_CULL_MODE_NONE;
}

void Object3dCommon::CommonDrawSetting()
{
	//RootSignatureã‚’è¨­å®šã€‚PSOã«è¨­å®šã—ã¦ã„ã‚‹ã‘ã©åˆ¥é€”è¨­å®šãŒå¿…è¦
	commandList_->SetGraphicsRootSignature(rootSignature_.Get());
	commandList_->SetPipelineState(graphicsPipelineState_.Get());

	//å½¢çŠ¶ã‚’è¨­å®šã€‚PSOã«è¨­å®šã—ã¦ã„ã‚‹ã‚‚ã®ã¨ã¯ã¾ãŸåˆ¥ã€‚åŒã˜ã‚‚ã®ã‚’è¨­å®šã™ã‚‹ã¨è€ƒãˆã¦ãŠã‘ã°ã‚ˆã„
	commandList_->IASetPrimitiveTopology(D3D_PRIMITIVE_TOPOLOGY_TRIANGLELIST);
}

============================================================
File Path: project/gameEngine/3d/Object3dCommon.h
============================================================
#pragma once

#include <d3d12.h>
#include "../../externals/DirectXTex/d3dx12.h"

#include "DirectXCommon.h"
#include "Logger.h"
#include "CameraManager.h"

/// <summary>
/// 3Dã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆå…±é€šæ©Ÿèƒ½
/// </summary>
class Object3dCommon
{
#pragma region ã‚·ãƒ³ã‚°ãƒ«ãƒˆãƒ³ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹

private:

	Object3dCommon() = default;
	~Object3dCommon() = default;
	Object3dCommon(Object3dCommon&) = delete;
	Object3dCommon& operator = (Object3dCommon&) = delete;

public:
	// ã‚·ãƒ³ã‚°ãƒ«ãƒˆãƒ³ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã®å–å¾—
	static Object3dCommon* GetInstance();
	// çµ‚äº†
	void Finalize();

#pragma endregion ã‚·ãƒ³ã‚°ãƒ«ãƒˆãƒ³ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹

public:

	/// <summary>
	/// åˆæœŸåŒ–
	/// </summary>
	/// <param name="dxCommon">DirectXå…±é€šæ©Ÿèƒ½</param>
	void Initialize(DirectXCommon* dxCommon);

	/// <summary>
	/// æç”»å…±é€šè¨­å®š
	/// </summary>
	void CommonDrawSetting();

public: // ã‚»ãƒƒã‚¿ãƒ¼

	/// <summary>
	/// ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã‚«ãƒ¡ãƒ©ã®è¨­å®š
	/// </summary>
	/// <param name="camera">ã‚«ãƒ¡ãƒ©</param>
	void SetDefaultCamera(std::shared_ptr<Camera> camera) { defaultCamera_ = camera; }

public: // ã‚²ãƒƒã‚¿ãƒ¼

	/// <summary>
	/// DirectXå…±é€šæ©Ÿèƒ½ã®å–å¾—
	/// </summary>
	/// <returns>DirectXå…±é€šæ©Ÿèƒ½</returns>
	DirectXCommon* GetDxCommon() const { return dxCommon_; }

	/// <summary>
	/// ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã‚«ãƒ¡ãƒ©ã®å–å¾—
	/// </summary>
	/// <returns>ã‚«ãƒ¡ãƒ©</returns>
	std::shared_ptr<Camera> GetDefaultCamera() const { return defaultCamera_; }

private:

	/// <summary>
	/// ãƒ«ãƒ¼ãƒˆã‚·ã‚°ãƒãƒãƒ£ã®ç”Ÿæˆ
	/// </summary>
	void CreateRootSignature();

	/// <summary>
	/// ã‚°ãƒ©ãƒ•ã‚£ãƒƒã‚¯ã‚¹ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³ã®ç”Ÿæˆ
	/// </summary>
	void CreateGraphicsPipeline();

private:

	DirectXCommon* dxCommon_;

	std::shared_ptr<Camera> defaultCamera_ = nullptr;
	
	// ãƒ‡ãƒã‚¤ã‚¹
	Microsoft::WRL::ComPtr<ID3D12Device> device_ = nullptr;
	// ã‚³ãƒžãƒ³ãƒ‰ãƒªã‚¹ãƒˆ
	Microsoft::WRL::ComPtr<ID3D12GraphicsCommandList> commandList_ = nullptr;

	//ãƒ‡ã‚£ã‚¹ã‚¯ãƒªãƒ—ã‚¿ãƒ¬ãƒ³ã‚¸ã®ç”Ÿæˆ
	D3D12_DESCRIPTOR_RANGE descriptorRange_[2]{};
	//DepthStencilStateã®è¨­å®š
	D3D12_DEPTH_STENCIL_DESC depthStencilDesc_{};
	//InputLayout
	D3D12_INPUT_LAYOUT_DESC inputLayoutDesc_{};
	//BlendStateã®è¨­å®š
	D3D12_BLEND_DESC blendDesc_{};
	//RasterizerStateã®è¨­å®š
	D3D12_RASTERIZER_DESC rasterizerDesc_{};

	//shaderã‚’ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ã™ã‚‹
	Microsoft::WRL::ComPtr<IDxcBlob> vertexShaderBlob_ = nullptr;
	Microsoft::WRL::ComPtr<IDxcBlob> pixelShaderBlob_ = nullptr;
	

	//RootSignatureä½œæˆ
	Microsoft::WRL::ComPtr<ID3D12RootSignature> rootSignature_ = nullptr;

	//PSOã‚’ç”Ÿæˆã™ã‚‹
	Microsoft::WRL::ComPtr<ID3D12PipelineState> graphicsPipelineState_ = nullptr;


	D3D12_ROOT_SIGNATURE_DESC descriptionRootSignature_{};
	D3D12_ROOT_PARAMETER rootParameters_[9] = {};
	D3D12_STATIC_SAMPLER_DESC staticSamplers_[1] = {};
	D3D12_INPUT_ELEMENT_DESC inputElementDescs_[3] = {};
};



============================================================
File Path: project/gameEngine/Collider/Collider.cpp
============================================================
#include "Collider.h"

#include<sstream>

#include"ColliderManager.h"

Collider::Collider()
{
}

Collider::~Collider()
{
}

void Collider::MakeAABBDesc(const ColliderDesc& desc)
{
    SetOwner(desc.owner);
    SetColliderID(desc.colliderID);
    SetShape(Shape::AABB);
    SetShapeData(static_cast<AABB*>(desc.shapeData));
    SetAttribute(desc.attribute);
    if (desc.onCollision) SetOnCollision(desc.onCollision);
    if (desc.onCollisionTrigger) SetOnCollisionTrigger(desc.onCollisionTrigger);
}

void Collider::MakeOBBDesc(const ColliderDesc& desc)
{
    SetOwner(desc.owner);
    SetColliderID(desc.colliderID);
    SetShape(Shape::OBB);
    SetShapeData(static_cast<OBB*>(desc.shapeData));
    SetAttribute(desc.attribute);
    if (desc.onCollision) SetOnCollision(desc.onCollision);
    if (desc.onCollisionTrigger) SetOnCollisionTrigger(desc.onCollisionTrigger);
}

void Collider::MakeSphereDesc(const ColliderDesc& desc)
{
    SetOwner(desc.owner);
    SetColliderID(desc.colliderID);
    SetShape(Shape::Sphere);
    SetShapeData(static_cast<Sphere*>(desc.shapeData));
    SetAttribute(desc.attribute);
    if (desc.onCollision) SetOnCollision(desc.onCollision);
    if (desc.onCollisionTrigger) SetOnCollisionTrigger(desc.onCollisionTrigger);
}

const bool Collider::IsRegisteredCollidingPtr(const Collider* _ptr) const
{
    for (auto itr = collidingPtrList_.begin(); itr != collidingPtrList_.end(); ++itr)
    {
        if (_ptr == *itr) return true;
    }
    return false;
}

void Collider::EraseCollidingPtr(const Collider* _ptr)
{
    collidingPtrList_.remove_if([_ptr](const Collider* _pCollider) 
        {
        return _pCollider == _ptr;
        });
    return;
}

void Collider::SetAttribute(uint32_t _attribute)
{
    collisionAttribute_ = _attribute;
}

void Collider::SetMask(uint32_t _mask)
{
    collisionMask_ = _mask;
}

void Collider::OnCollisionTrigger(const Collider* _other)
{
    if (onCollisionTriggerFunction_)
        onCollisionTriggerFunction_(_other);
    return;
}


============================================================
File Path: project/gameEngine/Collider/Collider.h
============================================================
#pragma once

#include<vector>
#include<string>
#include<functional>
#include<list>
#include<variant>

#include"Shape.h"
#include"../../application/BaseObject/GameObject.h"

class ColliderManager;

/// <summary>
/// ã‚³ãƒ©ã‚¤ãƒ€ãƒ¼
/// å½¢çŠ¶ã¯Sphereã€OBBã€AABBã®3ç¨®é¡ž
/// </summary>
class Collider
{
public:

    Collider();
    ~Collider();

    /// <summary>
    /// ã‚³ãƒ©ã‚¤ãƒ€ãƒ¼ä½œæˆã®æ§‹é€ ä½“
    /**
     * @brief ã‚³ãƒ©ã‚¤ãƒ€ãƒ¼ä½œæˆç”¨ã®æ§‹é€ ä½“
     * owner: æ‰€æœ‰ã™ã‚‹GameObject
     * colliderID: ã‚³ãƒ©ã‚¤ãƒ€ãƒ¼è­˜åˆ¥ID
     * shape: å½¢çŠ¶ã‚¿ã‚¤ãƒ—ï¼ˆAABB/OBB/Sphereï¼‰
     * shapeData: å½¢çŠ¶ãƒ‡ãƒ¼ã‚¿ã¸ã®ãƒã‚¤ãƒ³ã‚¿
     * attribute: è¡çªå±žæ€§
     * onCollision: è¡çªæ™‚ã‚³ãƒ¼ãƒ«ãƒãƒƒã‚¯
     * onCollisionTrigger: è¡çªé–‹å§‹æ™‚ã‚³ãƒ¼ãƒ«ãƒãƒƒã‚¯
     */
    /// </summary>
    struct ColliderDesc
    {
        GameObject* owner = nullptr;
        std::string colliderID;
        Shape shape = Shape::AABB;
        void* shapeData = nullptr;
        uint32_t attribute = 0;
        std::function<void(const Collider*)> onCollision = nullptr;
        std::function<void(const Collider*)> onCollisionTrigger = nullptr;
    };

    /// <summary>
    /// AABBã‚³ãƒ©ã‚¤ãƒ€ãƒ¼ä½œæˆ
    /// </summary>
    /// <param name="desc">ã‚³ãƒ©ã‚¤ãƒ€ãƒ¼ä½œæˆç”¨æ§‹é€ ä½“</param>
    void MakeAABBDesc(const ColliderDesc& desc);

    /// <summary>
	/// OBBã‚³ãƒ©ã‚¤ãƒ€ãƒ¼ä½œæˆ
    /// </summary>
    /// <param name="desc">ã‚³ãƒ©ã‚¤ãƒ€ãƒ¼ä½œæˆç”¨æ§‹é€ ä½“</param>
    void MakeOBBDesc(const ColliderDesc& desc);

    /// <summary>
	/// Sphereã‚³ãƒ©ã‚¤ãƒ€ãƒ¼ä½œæˆ
    /// </summary>
    /// <param name="desc">ã‚³ãƒ©ã‚¤ãƒ€ãƒ¼ä½œæˆç”¨æ§‹é€ ä½“</param>
    void MakeSphereDesc(const ColliderDesc& desc);

public: // ã‚²ãƒƒã‚¿ãƒ¼

	// ã‚ªãƒ¼ãƒŠãƒ¼å–å¾—
    inline const GameObject* GetOwner()const { return owner_; }
	
	// å½¢çŠ¶ãƒ‡ãƒ¼ã‚¿å–å¾—(AABB)
    inline const AABB* GetAABB()const { return std::get<AABB*>(shapeData_); }
    
	// å½¢çŠ¶ãƒ‡ãƒ¼ã‚¿å–å¾—(OBB)
    inline const OBB* GetOBB()const { return std::get<OBB*>(shapeData_); }
    
	// å½¢çŠ¶ãƒ‡ãƒ¼ã‚¿å–å¾—(Sphere)
    inline const Sphere* GetSphere()const { return std::get<Sphere*>(shapeData_); }

	// è¡çªå±žæ€§å–å¾—
    inline uint32_t GetCollisionAttribute()const { return collisionAttribute_; }
    
	// è¡çªãƒžã‚¹ã‚¯å–å¾—
    inline uint32_t GetCollisionMask()const { return collisionMask_; }
    
	// å½¢çŠ¶ã‚¿ã‚¤ãƒ—å–å¾—
    inline Shape GetShape()const { return shape_; }
    
	// è»½é‡åŒ–ç”¨åŠå¾„å–å¾—
    inline unsigned int GetRadius() const { return radiusCollider_; }
    
	// ã‚³ãƒ©ã‚¤ãƒ€ãƒ¼IDå–å¾—
    inline const std::string& GetColliderID() const { return colliderID_; }
	
    // è»½é‡åŒ–ç”¨æœ‰åŠ¹ãƒ•ãƒ©ã‚°å–å¾—
    inline bool GetIsEnableLighter() const { return enableLighter_; }
	
    // è»½é‡åŒ–ç”¨ä½ç½®å–å¾—
    inline Vector3 GetPosition() const { return position_; }
	
    // è»½é‡åŒ–ç”¨æœ‰åŠ¹ãƒ•ãƒ©ã‚°å–å¾—
    inline const bool GetEnable() const { return isEnableCollision_; }

	// ã‚ãŸã£ã¦ã„ã‚‹ã‚³ãƒ©ã‚¤ãƒ€ãƒ¼ã®ä¸­ã«æŒ‡å®šã•ã‚ŒãŸãƒã‚¤ãƒ³ã‚¿ãŒã‚ã‚‹ã‹
    const bool IsRegisteredCollidingPtr(const Collider* _ptr) const;
	// ã‚ãŸã£ã¦ã„ã‚‹ã‚³ãƒ©ã‚¤ãƒ€ãƒ¼ãƒªã‚¹ãƒˆã‹ã‚‰æŒ‡å®šã•ã‚ŒãŸãƒã‚¤ãƒ³ã‚¿ã‚’å‰Šé™¤
    void EraseCollidingPtr(const Collider* _ptr);


public: // ã‚»ãƒƒã‚¿ãƒ¼

    /// <summary>
	/// ã‚ªãƒ¼ãƒŠãƒ¼è¨­å®š
    /// </summary>
    /// <param name="_owner">GameObjectã®ãƒã‚¤ãƒ³ã‚¿</param>
    inline void SetOwner(GameObject* _owner) { owner_ = _owner; }
    
    /// <summary>
	/// ã‚³ãƒ©ã‚¤ãƒ€ãƒ¼IDè¨­å®š
    /// </summary>
    /// <param name="_id">ã‚³ãƒ©ã‚¤ãƒ€ãƒ¼IDæ–‡å­—åˆ—</param>
    inline void SetColliderID(const std::string& _id)
    {
        colliderID_ = _id;
    }

    template<typename T>
   
	/// <summary>
	/// å½¢çŠ¶ãƒ‡ãƒ¼ã‚¿è¨­å®š
	/// </summary>
	/// <param name="_shapeData">å½¢çŠ¶ãƒ‡ãƒ¼ã‚¿ã¸ã®ãƒã‚¤ãƒ³ã‚¿</param>
    void SetShapeData(T* _shapeData) { shapeData_ = _shapeData; }
   
    /// <summary>
	/// å½¢çŠ¶ã‚¿ã‚¤ãƒ—è¨­å®š
    /// </summary>
    /// <param name="_shape">å½¢çŠ¶ãƒ‡ãƒ¼ã‚¿ã¸ã®ãƒã‚¤ãƒ³ã‚¿</param>
    void SetShape(Shape _shape) { shape_ = _shape; }

    /// <summary>
	/// è¡çªå±žæ€§è¨­å®š
    /// </summary>
    /// <param name="_attribute">å±žæ€§å€¤</param>
    void SetAttribute(uint32_t _attribute);
   
    /// <summary>
	/// è¡çªãƒžã‚¹ã‚¯è¨­å®š
    /// </summary>
    /// <param name="_mask">ãƒžã‚¹ã‚¯å€¤ã¸ã®ãƒã‚¤ãƒ³ã‚¿</param>
    void SetMask(uint32_t _mask);
   
    /// <summary>
	/// è¡çªæ™‚ã‚³ãƒ¼ãƒ«ãƒãƒƒã‚¯è¨­å®š
    /// </summary>
    /// <param name="_func">ã‚³ãƒ¼ãƒ«ãƒãƒƒã‚¯é–¢æ•°</param>
    void SetOnCollision(const std::function<void(const Collider*)>& _func) { onCollisionFunction_ = _func; }
   
    /// <summary>
	/// è¡çªé–‹å§‹æ™‚ã‚³ãƒ¼ãƒ«ãƒãƒƒã‚¯è¨­å®š
    /// </summary>
    /// <param name="_func">ã‚³ãƒ¼ãƒ«ãƒãƒƒã‚¯é–¢æ•°</param>
    void SetOnCollisionTrigger(const std::function<void(const Collider*)>& _func) { onCollisionTriggerFunction_ = _func; }
    
    /// <summary>
	/// è»½é‡åŒ–ç”¨åŠå¾„è¨­å®š
    /// </summary>
	/// <param name="_rad">åŠå¾„</param>
    void SetRadius(unsigned int _rad) { radiusCollider_ = _rad; }
    
    /// <summary>
	/// è»½é‡åŒ–ç”¨ä½ç½®è¨­å®š
    /// </summary>
	/// <param name="_v"> ä½ç½®ãƒ™ã‚¯ãƒˆãƒ«</param>
    void SetPosition(const Vector3& _v) { position_ = _v; }
    
	/// <summary>
	/// è»½é‡åŒ–ç”¨æœ‰åŠ¹ãƒ•ãƒ©ã‚°è¨­å®š
	/// </summary>
	/// <param name="_flag">æœ‰åŠ¹ãƒ•ãƒ©ã‚°</param>
    void SetEnableLighter(bool _flag) { enableLighter_ = _flag; }
    
	/// <summary>
	/// ã‚³ãƒ©ã‚¤ãƒ€ãƒ¼æœ‰åŠ¹ãƒ•ãƒ©ã‚°è¨­å®š
	/// </summary>
	/// <param name="_flag">æœ‰åŠ¹ãƒ•ãƒ©ã‚°</param>
    void SetEnable(bool _flag) { isEnableCollision_ = _flag; }
    
	/// <summary>
	/// ã‚ãŸã£ã¦ã„ã‚‹ã‚³ãƒ©ã‚¤ãƒ€ãƒ¼ãƒªã‚¹ãƒˆã«æŒ‡å®šã•ã‚ŒãŸãƒã‚¤ãƒ³ã‚¿ã‚’ç™»éŒ²
	/// </summary>
	/// <param name="_ptr">ã‚³ãƒ©ã‚¤ãƒ€ãƒ¼ãƒã‚¤ãƒ³ã‚¿</param>
    void RegisterCollidingPtr(const Collider* _ptr) { collidingPtrList_.push_back(_ptr); }

    /// <summary>
	/// è¡çªæ™‚å‡¦ç†
    /// </summary>
	/// <param name="_other">è¡çªç›¸æ‰‹ã®ã‚³ãƒ©ã‚¤ãƒ€ãƒ¼</param>
    inline void OnCollision(const Collider* _other)
    {
        if (onCollisionFunction_)
            onCollisionFunction_(_other);
        return;
    }

    /// <summary>
	/// è¡çªé–‹å§‹æ™‚å‡¦ç†
    /// </summary>
	/// <param name="_other">è¡çªç›¸æ‰‹ã®ã‚³ãƒ©ã‚¤ãƒ€ãƒ¼</param>
    void OnCollisionTrigger(const Collider* _other);

private:

    std::function<void(const Collider*)> onCollisionFunction_;
    std::function<void(const Collider*)> onCollisionTriggerFunction_;
    std::variant<OBB*, AABB*, Sphere*> shapeData_ = {};

    GameObject* owner_ = nullptr;
    bool isEnableCollision_ = true; // åˆ¤å®šã‚’ã™ã‚‹ã‹ã©ã†ã‹
    Shape shape_ = Shape::Sphere; // å½¢çŠ¶
    std::string colliderID_ = {}; // ID


    std::list<const Collider*> collidingPtrList_ = {}; // ç¾åœ¨ã‚ãŸã£ã¦ã„ã‚‹ã‚³ãƒ©ã‚¤ãƒ€ãƒ¼ã®ãƒªã‚¹ãƒˆ

    // è»½é‡åŒ–ç”¨
    unsigned int radiusCollider_ = 0u;
    Vector3 position_ = {};
    bool enableLighter_ = false;

    // è¡çªå±žæ€§(è‡ªåˆ†)
    uint32_t collisionAttribute_ = 0xffffffff;
    // è¡çªãƒžã‚¹ã‚¯(ç›¸æ‰‹)
    uint32_t collisionMask_ = 0xffffffff;
};



============================================================
File Path: project/gameEngine/Collider/ColliderManager.cpp
============================================================
#include "ColliderManager.h"

#include <Vector3.h>
#include <Matrix4x4.h>
#include <cmath>
#include <algorithm>

#include"MyMath.h"

void ColliderManager::Initialize()
{
}

void ColliderManager::CheckAllCollision()
{
    collisionNames_.clear();
    countCheckCollision_ = 0ui32;
    countWithoutFilter_ = 0ui32;
    countWithoutLighter = 0ui32;

    auto itrA = colliders_.begin();
    for (; itrA != colliders_.end(); ++itrA)
    {
        auto itrB = itrA + 1;
        for (; itrB != colliders_.end(); ++itrB)
        {
            CheckCollisionPair(*itrA, *itrB);
        }
    }
}

void ColliderManager::RegisterCollider(Collider* _collider)
{
    colliders_.push_back(_collider);
}

void ColliderManager::ClearColliderList()
{
    colliders_.clear();
}

void ColliderManager::DeleteCollider(Collider* _collider)
{
    for (int i = 0; i < colliders_.size(); i++)
    {
        colliders_[i]->EraseCollidingPtr(_collider);
        if (colliders_[i] == _collider)
        {
            colliders_.erase(colliders_.begin() + i);
        }
    }
}

uint32_t ColliderManager::GetNewAttribute(std::string _id)
{
    if (attributeList_.size() == 0)
    {
        attributeList_.push_back({ _id, 1 });
        return 1;
    }
    for (auto& attributePair : attributeList_)
    {
        if (attributePair.first.compare(_id) == 0)
        {
            return attributePair.second;
        }
    }

    uint32_t result = static_cast<uint32_t>(attributeList_.back().second << 1);

    attributeList_.push_back({ _id, result });

    return attributeList_.back().second;
}

void ColliderManager::CheckCollisionPair(Collider* _colA, Collider* _colB)
{
    // è¡çªã—ã¦ã„ã‚‹ã‹ã©ã†ã‹
    bool isCollide = true;

    if (!_colA->GetEnable() || !_colB->GetEnable())
    {
        _colA->EraseCollidingPtr(_colB);
        _colB->EraseCollidingPtr(_colA);
        return;
    }
    countWithoutFilter_++;

    // è¡çªãƒ•ã‚£ãƒ«ã‚¿ãƒªãƒ³ã‚°
    bool fillterFlag =
        !(_colA->GetCollisionAttribute() & _colB->GetCollisionMask()) ||
        !(_colB->GetCollisionAttribute() & _colA->GetCollisionMask());
    if (fillterFlag) return;

    // å½¢çŠ¶æ¡ä»¶
    if (_colA->GetShape() == Shape::AABB && _colB->GetShape() == Shape::AABB)
    {
        isCollide = IsCollision(_colA->GetAABB(), _colB->GetAABB());
    } else if (_colA->GetShape() == Shape::Sphere && _colB->GetShape() == Shape::Sphere)
    {
        isCollide = IsCollision(_colA->GetSphere(), _colB->GetSphere());
    } else if (_colA->GetShape() == Shape::OBB && _colB->GetShape() == Shape::OBB)
    {
        ++countWithoutLighter;
        /// ãƒ©ã‚°è»½æ¸›ã®ãŸã‚ã€åŠå¾„ã§åˆ¤å®šã¨ã£ã¦æ—©æœŸãƒªã‚¿ãƒ¼ãƒ³ (ãŸã ã—è¨­å®šã•ã‚Œã¦ã„ãŸã‚‰)
        if (_colA->GetRadius() && _colB->GetRadius() && _colA->GetIsEnableLighter() && _colB->GetIsEnableLighter())
        {
            Sphere sphereA = { _colA->GetPosition(), static_cast<float>(_colA->GetRadius()) };
            Sphere sphereB = { _colB->GetPosition(), static_cast<float>(_colB->GetRadius()) };
            isCollide = IsCollision(&sphereA, &sphereB);
        }
        ++countCheckCollision_;


        isCollide = IsCollision(_colA->GetOBB(), _colB->GetOBB());
    }

    if (isCollide)
    {
        _colA->OnCollision(_colB);
        _colB->OnCollision(_colA);

        if (!_colA->IsRegisteredCollidingPtr(_colB) && !_colB->IsRegisteredCollidingPtr(_colA))
        {
            _colA->RegisterCollidingPtr(_colB);
            _colB->RegisterCollidingPtr(_colA);
            _colA->OnCollisionTrigger(_colB);
            _colB->OnCollisionTrigger(_colA);
        }

        collisionNames_.push_back({ _colA->GetColliderID(), _colB->GetColliderID() });
    } else
    {
        // ã‚ãŸã£ã¦ã„ãªã„å ´åˆã€CollidingPtrã‚’ãƒã‚§ãƒƒã‚¯ã—è©²å½“ã™ã‚‹å ´åˆãƒãƒƒãƒ—
        _colA->EraseCollidingPtr(_colB);
        _colB->EraseCollidingPtr(_colA);
    }
    return;
}

void ColliderManager::ProjectShapeOnAxis(const std::vector<Vector3>* _v, const Vector3& _axis, float& _min, float& _max)
{
    _min = (*_v)[0].Projection(_axis);
    _max = _min;

    for (int i = 1; i < _v->size(); i++)
    {
        float projection = (*_v)[i].Projection(_axis);
        if (projection < _min) _min = projection;
        if (projection > _max) _max = projection;
    }
    return;
}

bool ColliderManager::IsCollision(const AABB* _aabb1, const AABB* _aabb2)
{
    if (_aabb1->max.x >= _aabb2->min.x && _aabb1->min.x <= _aabb2->max.x &&
        _aabb1->max.y >= _aabb2->min.y && _aabb1->min.y <= _aabb2->max.y &&
        _aabb1->max.z >= _aabb2->min.z && _aabb1->min.z <= _aabb2->max.z)
    {
        return true;
    }

    return false;
}

bool ColliderManager::IsCollision(const AABB& _aabb, const Sphere& _sphere)
{
    Vector3 _closestPoint{
       std::clamp(_sphere.center.x, _aabb.min.x, _aabb.max.x),
       std::clamp(_sphere.center.y, _aabb.min.y, _aabb.max.y),
       std::clamp(_sphere.center.z, _aabb.min.z, _aabb.max.z)
    };
    float distance = (_closestPoint - _sphere.center).LengthWithoutRoot();
    if (distance <= _sphere.radius * _sphere.radius)
    {
        return true;
    }
    return false;
}

bool ColliderManager::IsCollision(const Sphere* _sphere1, const Sphere* _sphere2)
{
    Vector3 distanceAB = _sphere1->center - _sphere2->center;
    float radiusAB = _sphere1->radius + _sphere2->radius;
    if (distanceAB.LengthWithoutRoot() < static_cast<float>(radiusAB * radiusAB)) return true;
    return false;
}

bool ColliderManager::IsCollision(const OBB* _obb1, const OBB* _obb2)
{
    // åˆ†é›¢è»¸ã®ãƒªã‚¹ãƒˆ
    Vector3 axes[15];
    int axisIndex = 0;

    // å„OBBã®ãƒ­ãƒ¼ã‚«ãƒ«è»¸ï¼ˆ6è»¸ï¼‰
    for (int i = 0; i < 3; ++i) {
        axes[axisIndex++] = _obb1->orientations[i];
        axes[axisIndex++] = _obb2->orientations[i];
    }

    // å¤–ç©ã‹ã‚‰ç”Ÿæˆã•ã‚Œã‚‹è»¸ï¼ˆ9è»¸ï¼‰
    for (int i = 0; i < 3; ++i) {
        for (int j = 0; j < 3; ++j) {
            axes[axisIndex++] = _obb1->orientations[i].Cross(_obb2->orientations[j]);
        }
    }

    // å„è»¸ã«ã¤ã„ã¦æŠ•å½±ã‚’ç¢ºèª
    for (int i = 0; i < 15; ++i) {
        if (!OverlapOnAxis(_obb1, _obb2, axes[i])) {
            // åˆ†é›¢è»¸ãŒè¦‹ã¤ã‹ã£ãŸ
            return false;
        }
    }

    // åˆ†é›¢è»¸ãŒãªã„å ´åˆã€äº¤å·®ã—ã¦ã„ã‚‹
    return true;
}

bool ColliderManager::IsCollision(const OBB& _obb, const Sphere& _sphere)
{
    Matrix4x4 obbWorldMatrix{};
        for (int i = 0; i < 3; i++)
            obbWorldMatrix.m[0][i] = _obb.orientations[i].x;
        for (int i = 0; i < 3; i++)
            obbWorldMatrix.m[1][i] = _obb.orientations[i].y;
        for (int i = 0; i < 3; i++)
            obbWorldMatrix.m[2][i] = _obb.orientations[i].z;
        for (int i = 0; i < 3; i++)
            obbWorldMatrix.m[3][i] = *(&_obb.center.x + i);
        obbWorldMatrix.m[3][3] = 1.0f;
    
        Matrix4x4 obbWorldMatrixInverse = obbWorldMatrix.Inverse();
        Vector3 centerInOBBLocalSpace = Transform(_sphere.center, obbWorldMatrixInverse);
    
        AABB aabbOBBLocal{ .min = -_obb.size, .max = _obb.size };
        Sphere sphereOBBLocal{ centerInOBBLocalSpace, _sphere.radius };
    
        return IsCollision(aabbOBBLocal, sphereOBBLocal);
}

float ColliderManager::ProjectOntoAxis(const OBB* _obb, const Vector3& axis)
{
    // è»¸æ–¹å‘ã«OBBã®å„åŠã‚µã‚¤ã‚ºã‚’æŠ•å½±
    float extent = 0.0f;

    extent += std::abs(_obb->orientations[0].Dot(axis)) * _obb->size.x;
    extent += std::abs(_obb->orientations[1].Dot(axis)) * _obb->size.y;
    extent += std::abs(_obb->orientations[2].Dot(axis)) * _obb->size.z;

    return extent;
}

bool ColliderManager::OverlapOnAxis(const OBB* _obb1, const OBB* _obb2, const Vector3& axis)
{
    // è»¸ãŒã‚¼ãƒ­ãƒ™ã‚¯ãƒˆãƒ«ãªã‚‰ç„¡åŠ¹
    if (axis.x == 0 && axis.y == 0 && axis.z == 0) return true;

    // è»¸ã‚’æ­£è¦åŒ–
    Vector3 normAxis = axis.Normalize();

    // OBBã®ä¸­å¿ƒé–“è·é›¢ã‚’è»¸ä¸Šã«æŠ•å½±
    float distance = std::abs((_obb2->center - _obb1->center).Dot(normAxis));

    // å„OBBã®æŠ•å½±å¹…ã‚’è¨ˆç®—
    float aProjection = ProjectOntoAxis(_obb1, normAxis);
    float bProjection = ProjectOntoAxis(_obb2, normAxis);

    // æŠ•å½±åŒºé–“ãŒé‡ãªã‚‹ã‹åˆ¤å®š
    return distance <= (aProjection + bProjection);
}


============================================================
File Path: project/gameEngine/Collider/ColliderManager.h
============================================================
#pragma once

#include<vector>
#include<string>
#include<utility>
#include <list>

#include"Shape.h"
#include"Collider.h"

/// <summary>
/// ã‚³ãƒ©ã‚¤ãƒ€ãƒ¼ç®¡ç†ã‚¯ãƒ©ã‚¹
/// </summary>
class ColliderManager
{

public:
    
    ColliderManager(const ColliderManager&) = delete;
    ColliderManager(const ColliderManager&&) = delete;
    ColliderManager& operator=(const ColliderManager&) = delete;
    ColliderManager& operator=(const ColliderManager&&) = delete;

    static ColliderManager* GetInstance() { static ColliderManager instance; return &instance; }

	/// <summary>
	/// åˆæœŸåŒ–
	/// </summary>
    void Initialize();
    
    /// <summary>
	/// å…¨ã¦ã®ã‚³ãƒªã‚¸ãƒ§ãƒ³ãƒã‚§ãƒƒã‚¯
    /// </summary>
    void CheckAllCollision();
    
    /// <summary>
	/// ã‚³ãƒ©ã‚¤ãƒ€ãƒ¼ç™»éŒ²
    /// </summary>
	/// <param name="_collider"> ç™»éŒ²ã™ã‚‹ã‚³ãƒ©ã‚¤ãƒ€ãƒ¼ã®ãƒã‚¤ãƒ³ã‚¿</param>
    void RegisterCollider(Collider* _collider);
    
    /// <summary>
	/// ã‚³ãƒ©ã‚¤ãƒ€ãƒ¼ãƒªã‚¹ãƒˆã‚¯ãƒªã‚¢
    /// </summary>
    void ClearColliderList();
    
	/// <summary>
	/// ã‚³ãƒ©ã‚¤ãƒ€ãƒ¼å‰Šé™¤
	/// </summary>
    void DeleteCollider(Collider* _collider);
    
public: // ã‚²ãƒƒã‚¿ãƒ¼

	/// <summary>
	/// æ–°ã—ã„å±žæ€§å€¤ã‚’å–å¾—
	/// </summary>
	/// <param name="_nameA"> è¡çªåˆ¤å®šåA</param>
    uint32_t GetNewAttribute(std::string _id);

    template <typename... Args>
	/// <summary>
	/// æ–°ã—ã„ãƒžã‚¹ã‚¯å€¤ã‚’å–å¾—
	/// </summary>
	/// <param name="_id"> è¡çªåˆ¤å®šåA</param>
	/// <param name="_ignoreNames"> ç„¡è¦–ã™ã‚‹å±žæ€§åãƒªã‚¹ãƒˆ</param>
    uint32_t* GetNewMask(std::string _id, Args... _ignoreNames)
    {
        uint32_t result = 0;
        for (auto& attributePair : attributeList_)
        {
            if (_id.compare(attributePair.first) == 0)
            {
                result = ~attributePair.second;
                break;
            }
        }
        for (std::string name : std::initializer_list<std::string>{ _ignoreNames... })
        {
            bool iscompare = false;
            for (auto& attributePair : attributeList_)
            {
                if (name.compare(attributePair.first) == 0)
                {
                    result ^= attributePair.second;
                    iscompare = true;
                }
            }
        }

        if (!result) result = ~result;

        uint32_t* resultPtr = nullptr;
        bool isCompare = false;
        /// é…åˆ—ã®ä¸­èº«ã‚’å¤‰æ›´
        for (auto& maskPair : maskList_)
        {
            if (maskPair.first.compare(_id) == 0)
            {
                maskPair.second = result;
                resultPtr = &maskPair.second;
                isCompare = true;
            }
        }
        if (!isCompare) // ãƒžã‚¹ã‚¯ãƒªã‚¹ãƒˆã«ç™»éŒ²ã•ã‚Œã¦ã„ãªã‹ã£ãŸã‚‰
        {
            maskList_.push_back({ _id, result });
            resultPtr = &maskList_.back().second;
        }

        return resultPtr;
    }


private:

    ColliderManager() = default;

    /// <summary>
	/// ã‚³ãƒªã‚¸ãƒ§ãƒ³ãƒšã‚¢ãƒã‚§ãƒƒã‚¯
    /// </summary>
	/// <param name="_colA"> ã‚³ãƒ©ã‚¤ãƒ€ãƒ¼A</param>
	/// <param name="_colB"> ã‚³ãƒ©ã‚¤ãƒ€ãƒ¼B</param>
    void CheckCollisionPair(Collider* _colA, Collider* _colB);

    /// <summary>
	/// å½¢çŠ¶ã‚’è»¸ã«æŠ•å½±
    /// </summary>
	/// <param name="_v"> å½¢çŠ¶ã®é ‚ç‚¹ãƒªã‚¹ãƒˆ</param>
	/// <param name="_axis"> æŠ•å½±ã™ã‚‹è»¸</param>
	/// <param name="_min"> æŠ•å½±å¾Œã®æœ€å°å€¤</param>
	/// <param name="_max"> æŠ•å½±å¾Œã®æœ€å¤§å€¤</param>
    void ProjectShapeOnAxis(const std::vector<Vector3>* _v, const Vector3& _axis, float& _min, float& _max);

    /// <summary>
	/// AABBåŒå£«ã®å½“ãŸã‚Šåˆ¤å®š
    /// </summary>
	/// <param name="_aabb1"> AABB1</param>
	/// <param name="_aabb2"> AABB2</param>
	/// <returns> å½“ãŸã£ã¦ã„ã‚‹ã‹</returns>
    bool IsCollision(const AABB* _aabb1, const AABB* _aabb2);
	/// <summary>
	/// AABBã¨Sphereã®å½“ãŸã‚Šåˆ¤å®š
	/// </summary>
	/// <param name="_aabb"> AABB</param>
	/// <param name="_sphere"> Sphere</param>
	/// <returns> å½“ãŸã£ã¦ã„ã‚‹ã‹</returns>
    bool IsCollision(const AABB& _aabb, const Sphere& _sphere);

	/// <summary>
	/// SphereåŒå£«ã®å½“ãŸã‚Šåˆ¤å®š
	/// </summary>
	/// <param name="_sphere1"> Sphere1</param>
	/// <param name="_sphere2"> Sphere2</param>
	/// <returns> å½“ãŸã£ã¦ã„ã‚‹ã‹</returns>
    bool IsCollision(const Sphere* _sphere1, const Sphere* _sphere2);
	/// <summary>
	/// OBBåŒå£«ã®å½“ãŸã‚Šåˆ¤å®š
	/// </summary>
	/// <param name="_obb1"> OBB1</param>
	/// <param name="_obb2"> OBB2</param>
	/// <returns> å½“ãŸã£ã¦ã„ã‚‹ã‹</returns>
    bool IsCollision(const OBB* _obb1, const OBB* _obb2);

	/// <summary>
	/// OBBã¨Sphereã®å½“ãŸã‚Šåˆ¤å®š
	/// </summary>
	/// <param name="_obb"> OBB</param>
	/// <param name="_sphere"> Sphere</param>
	/// <returns> å½“ãŸã£ã¦ã„ã‚‹ã‹</returns>
    bool IsCollision(const OBB& _obb, const Sphere& _sphere);

	/// <summary>
	/// OBBã‚’è»¸ã«æŠ•å½±
	/// </summary>
	/// <param name="_obb"> OBB</param>
	/// <param name="axis"> æŠ•å½±ã™ã‚‹è»¸</param>
	/// <returns> æŠ•å½±å¾Œã®é•·ã•</returns>
    float ProjectOntoAxis(const OBB* _obb, const Vector3& axis);
    
	/// <summary>
	/// è»¸ä¸Šã§ã®é‡ãªã‚Šåˆ¤å®š
	/// </summary>
	/// <param name="_obb1"> OBB1</param>
	/// <param name="_obb2"> OBB2</param>
	/// <param name="axis"> åˆ¤å®šã™ã‚‹è»¸</param>
	/// <returns> é‡ãªã£ã¦ã„ã‚‹ã‹</returns>
    bool OverlapOnAxis(const OBB* _obb1, const OBB* _obb2, const Vector3& axis);

private:

    std::vector<Collider*> colliders_;
    std::vector<std::pair<std::string, std::string>> collisionNames_;
    std::vector<std::pair<std::string, uint32_t>> attributeList_;
    std::list<std::pair<std::string, uint32_t>> maskList_;

    uint32_t countCheckCollision_ = 0ui32;
    uint32_t countWithoutFilter_ = 0ui32;
    uint32_t countWithoutLighter = 0ui32;

};

============================================================
File Path: project/gameEngine/Collider/Shape.h
============================================================
#pragma once

#include "Vector3.h"

/// <summary>
/// å½¢çŠ¶ã®ç¨®é¡ž
/// </summary>
enum class Shape
{
    Sphere,
    OBB,
    AABB,
};

struct AABB
{
    Vector3 min; // æœ€å°ç‚¹
    Vector3 max; // æœ€å¤§ç‚¹
};

struct OBB
{
    Vector3 center; // ä¸­å¿ƒç‚¹
    Vector3 orientations[3]; // åº§æ¨™è»¸ã€‚æ­£è¦åŒ–ãƒ»ç›´äº¤å¿…é ˆ
    Vector3 size; // åº§æ¨™è»¸æ–¹å‘ã®é•·ã•ã®åŠåˆ†ã€‚ä¸­å¿ƒã‹ã‚‰é¢ã¾ã§ã®è·é›¢
};

struct Sphere
{
    Vector3 center; // ä¸­å¿ƒç‚¹
    float radius; // åŠå¾„
};

============================================================
File Path: project/gameEngine/audio/Audio.cpp
============================================================
#include "Audio.h"
#include <cassert>
#include <cstring>

Audio* Audio::GetInstance()
{
	static Audio instance;
	return &instance;
}

void Audio::Finalize()
{
	if (masterVoice_) 
	{
		masterVoice_->DestroyVoice();
		masterVoice_ = nullptr;
	}
}

void Audio::Initialize()
{
	// xAudioç”Ÿæˆ
	hr = XAudio2Create(&xAudio2_, 0, XAUDIO2_DEFAULT_PROCESSOR);
	// ãƒžã‚¹ã‚¿ãƒ¼ãƒœã‚¤ã‚¹ç”Ÿæˆ
	hr = xAudio2_->CreateMasteringVoice(&masterVoice_);
}

SoundData Audio::LoadWav(const char* filename)
{
	std::ifstream file;
	// åŸºæœ¬ãƒ‘ã‚¹ã‚’æŒ‡å®šï¼ˆ"resources/audio/"ï¼‰
	std::string basePath = "resources/audio/";
	std::string fullPath = basePath + filename;

	// .wavãƒ•ã‚¡ã‚¤ãƒ«ã‚’ãƒã‚¤ãƒŠãƒªãƒ¢ãƒ¼ãƒ‰ã§å±•é–‹
	file.open(fullPath.c_str(), std::ios_base::binary);
	// ãƒ•ã‚¡ã‚¤ãƒ«å±•é–‹å¤±æ•—æ™‚
	assert(file.is_open());

	// RIFFãƒ˜ãƒƒãƒ€ãƒ¼ã®èª­ã¿è¾¼ã¿
	RiffHeader riff;
	file.read((char*)&riff, sizeof(riff));
	// ãƒ•ã‚¡ã‚¤ãƒ«ãŒRIFFã‹ãƒã‚§ãƒƒã‚¯
	if (strncmp(riff.chunk.id, "RIFF", 4) != 0) 
	{
		assert(0);
	}
	// ã‚¿ã‚¤ãƒ—ãŒWAVEã‹ãƒã‚§ãƒƒã‚¯
	if (strncmp(riff.type, "WAVE", 4) != 0) 
	{
		assert(0);
	}

	// ãƒãƒ£ãƒ³ã‚¯ã®ãƒ«ãƒ¼ãƒ—ã‚’é–‹å§‹
	ChunkHeader chunkHeader;
	FormatChunk format = {};
	while (file.read((char*)&chunkHeader, sizeof(chunkHeader))) {
		// ãƒãƒ£ãƒ³ã‚¯IDãŒ "fmt" ã‹ç¢ºèª
		if (strncmp(chunkHeader.id, "fmt ", 4) == 0) {
			// Formatãƒãƒ£ãƒ³ã‚¯ã®ã‚µã‚¤ã‚ºã‚’ç¢ºèªã€ãƒ‡ãƒ¼ã‚¿ã‚’èª­ã¿è¾¼ã‚€
			assert(chunkHeader.size <= sizeof(format.fmt));

			format.chunk = chunkHeader; // ãƒãƒ£ãƒ³ã‚¯ãƒ˜ãƒƒãƒ€ãƒ¼ã‚’ã‚³ãƒ”ãƒ¼
			file.read((char*)&format.fmt, chunkHeader.size); // fmtã®ãƒ‡ãƒ¼ã‚¿ã‚’èª­ã¿è¾¼ã¿

			break;
		}
		else {
			// æ¬¡ã®ãƒãƒ£ãƒ³ã‚¯ã«ç§»å‹•
			file.seekg(chunkHeader.size, std::ios_base::cur);
		}
	}

	// "fmt"ãƒãƒ£ãƒ³ã‚¯ãŒè¦‹ã¤ã‹ã‚‰ãªã‹ã£ãŸå ´åˆã®ã‚¨ãƒ©ãƒ¼ã¨ã—ã¦ã ã™
	if (strncmp(format.chunk.id, "fmt ", 4) != 0) {
		assert(0);
	}


	// Dataãƒãƒ£ãƒ³ã‚¯ã®èª­ã¿è¾¼ã¿ã¨ã‚¹ã‚­ãƒƒãƒ—å‡¦ç†
	ChunkHeader data;
	while (file.read((char*)&data, sizeof(data))) {
		if (strncmp(data.id, "data", 4) == 0) {
			break; // "data" ãƒãƒ£ãƒ³ã‚¯ã‚’è¦‹ã¤ã‘ãŸã‚‰ãƒ«ãƒ¼ãƒ—ã‚’æŠœã‘ã‚‹
		}
		else 
		{
			// ç¾åœ¨ã®ãƒãƒ£ãƒ³ã‚¯ãŒ "data" ã§ãªã„å ´åˆã€ãã®ã‚µã‚¤ã‚ºåˆ†ã‚·ãƒ¼ã‚¯
			file.seekg(data.size, std::ios_base::cur);
		}
	}


	if (strncmp(data.id, "data", 4) != 0) {
		assert(0);
	}

	// Dataãƒãƒ£ãƒ³ã‚¯ã®ãƒ‡ãƒ¼ã‚¿éƒ¨ï¼ˆæ³¢å½¢ãƒ‡ãƒ¼ã‚¿ã®èª­ã¿è¾¼ã¿ï¼‰
	std::vector<char> tmpBuffer(data.size);
	file.read(tmpBuffer.data(), data.size);

	// Wavãƒ•ã‚¡ã‚¤ãƒ«ã‚’é–‰ã˜ã‚‹
	file.close();


	// returnã™ã‚‹ç‚ºã®ãƒ‡ãƒ¼ã‚¿
	SoundData soundData = {};

	soundData.wfex = format.fmt;
	soundData.pBuffer.resize(data.size);
	std::memcpy(soundData.pBuffer.data(), tmpBuffer.data(), data.size);
	soundData.bufferSize = data.size;

	soundData.sourceVoice = nullptr;

	return soundData;
}

void Audio::SoundUnload(Microsoft::WRL::ComPtr<IXAudio2> xAudio2, SoundData* soundData)
{
	if (soundData->sourceVoice) {
		soundData->sourceVoice->Stop();
		soundData->sourceVoice->FlushSourceBuffers();
		soundData->sourceVoice->DestroyVoice();
		soundData->sourceVoice = nullptr;
	}

	// éŸ³å£°ãƒ‡ãƒ¼ã‚¿è§£æ”¾
	xAudio2.Reset();

	soundData->pBuffer.clear();
	soundData->bufferSize = 0;
	soundData->wfex = {};
}

void Audio::PlayWave(SoundData& soundData, bool loop, float volume)
{
	// æ³¢å½¢ãƒ•ã‚©ãƒ¼ãƒžãƒƒãƒˆã‚’ã‚‚ã¨ã«SourceVoiceã®ç”Ÿæˆ
	hr = xAudio2_->CreateSourceVoice(&soundData.sourceVoice, &soundData.wfex);
	assert(SUCCEEDED(hr));

	// å†ç”Ÿã™ã‚‹æ³¢å½¢ãƒ‡ãƒ¼ã‚¿ã®è¨­å®š
	XAUDIO2_BUFFER buf{};
	buf.pAudioData = soundData.pBuffer.data();
	buf.AudioBytes = soundData.bufferSize;
	buf.Flags = XAUDIO2_END_OF_STREAM;

	// ãƒœãƒªãƒ¥ãƒ¼ãƒ ã‚’è¨­å®š
	soundData.sourceVoice->SetVolume(volume);

	// "loop" ãŒtrueã®å ´åˆãƒ«ãƒ¼ãƒ—ã•ã›ã‚‹
	if (loop) {
		buf.LoopCount = XAUDIO2_LOOP_INFINITE; // ç„¡é™ãƒ«ãƒ¼ãƒ—
	}

	// æ³¢å½¢ãƒ‡ãƒ¼ã‚¿ã®å†ç”Ÿ
	hr = soundData.sourceVoice->SubmitSourceBuffer(&buf);
	hr = soundData.sourceVoice->Start();
}

void Audio::SoundStop(SoundData& soundData)
{
	if (soundData.sourceVoice) {
		soundData.sourceVoice->Stop();
		soundData.sourceVoice->FlushSourceBuffers();
		soundData.sourceVoice->DestroyVoice();
		soundData.sourceVoice = nullptr;
	}
}

void Audio::SetVolume(SoundData& soundData, float volume)
{
	// 0.0f ~ 1.0f ã®ç¯„å›²ã§éŸ³é‡ã‚’è¨­å®š
	hr = soundData.sourceVoice->SetVolume(volume);

	// å¤±æ•—æ™‚ã«ã‚¨ãƒ©ãƒ¼ã‚’å‡ºåŠ›
	assert(SUCCEEDED(hr) && "Failed to set volume");
}


============================================================
File Path: project/gameEngine/audio/Audio.h
============================================================
#pragma once

#include <xaudio2.h>
#pragma comment(lib, "xaudio2.lib")
#include <fstream>
#include <vector>
#include <wrl/client.h>

// ãƒãƒ£ãƒ³ã‚¯ãƒ˜ãƒƒãƒ€
struct ChunkHeader {
	char id[4];		 // ãƒãƒ£ãƒ³ã‚¯æ¯Žã®ID
	int32_t size;	 // ãƒãƒ£ãƒ³ã‚¯ã‚µã‚¤ã‚º
};
// RIFFãƒ˜ãƒƒãƒ€ãƒãƒ£ãƒ³ã‚¯
struct RiffHeader {
	ChunkHeader chunk;	// "RIFF"
	char type[4];		// "WAVE"
};
// FMTãƒãƒ£ãƒ³ã‚¯
struct FormatChunk {
	ChunkHeader chunk;	// "fmt"
	WAVEFORMATEX fmt;	// æ³¢å½¢ãƒ•ã‚©ãƒ¼ãƒžãƒƒãƒˆ
};
// éŸ³å£°ãƒ‡ãƒ¼ã‚¿
struct SoundData {
	WAVEFORMATEX wfex;		// æ³¢å½¢ãƒ•ã‚©ãƒ¼ãƒžãƒƒãƒˆ
	std::vector<BYTE> pBuffer;			// ãƒãƒƒãƒ•ã‚¡ã®å…ˆé ­ã‚¢ãƒ‰ãƒ¬ã‚¹
	IXAudio2SourceVoice* sourceVoice = nullptr;  // ã‚½ãƒ¼ã‚¹ãƒœã‚¤ã‚¹
	unsigned int bufferSize;// ãƒãƒƒãƒ•ã‚¡ã‚µã‚¤ã‚º
};

/// <summary>
/// ã‚ªãƒ¼ãƒ‡ã‚£ã‚ª
/// éŸ³å£°å†ç”Ÿã€ç®¡ç†ã‚’è¡Œã†
/// </summary>
class Audio
{
#pragma region ã‚·ãƒ³ã‚°ãƒ«ãƒˆãƒ³ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹
private:

	Audio() = default;
	~Audio() = default;
	Audio(Audio&) = delete;
	Audio& operator = (Audio&) = delete;

public:
	// ã‚·ãƒ³ã‚°ãƒ«ãƒˆãƒ³ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã®å–å¾—
	static Audio* GetInstance();
	// çµ‚äº†
	void Finalize();
#pragma endregion ã‚·ãƒ³ã‚°ãƒ«ãƒˆãƒ³ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹

public:
	
	// åˆæœŸåŒ–
	void Initialize();
	
	/// <summary>
	/// éŸ³å£°ãƒ‡ãƒ¼ã‚¿èª­ã¿è¾¼ã¿
	/// </summary>
	/// <param name="filename">èª­ã¿è¾¼ã‚€WAVãƒ•ã‚¡ã‚¤ãƒ«ã®ãƒ‘ã‚¹</param>
	/// <returns>èª­ã¿è¾¼ã‚“ã éŸ³å£°ãƒ‡ãƒ¼ã‚¿</returns>
	SoundData LoadWav(const char* filename);

	/// <summary>
	/// éŸ³å£°ãƒ‡ãƒ¼ã‚¿ã®è§£æ”¾
	/// </summary>
	/// <param name="xAudio2"> XAudio2ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹</param>
	/// <param name="soundData">è§£æ”¾ã—ãŸã„éŸ³å£°ãƒ‡ãƒ¼ã‚¿</param>
	void SoundUnload(Microsoft::WRL::ComPtr<IXAudio2> xAudio2, SoundData* soundData);

	/// <summary>
	/// ã‚µã‚¦ãƒ³ãƒ‰å†ç”Ÿ
	/// </summary>
	/// <param name="soundData"> å†ç”Ÿã—ãŸã„ã‚µã‚¦ãƒ³ãƒ‰ãƒ‡ãƒ¼ã‚¿</param>
	/// <param name="loop">ãƒ«ãƒ¼ãƒ—ã™ã‚‹ã‹</param>
	/// <param name="volume">ãƒœãƒªãƒ¥ãƒ¼ãƒ </param>
	void PlayWave(SoundData& soundData, bool loop, float volume);

	/// <summary>
	/// ã‚µã‚¦ãƒ³ãƒ‰åœæ­¢ 
	/// </summary>
	/// <param name="soundData">åœæ­¢ã—ãŸã„ã‚µã‚¦ãƒ³ãƒ‰ãƒ‡ãƒ¼ã‚¿</param>
	void SoundStop(SoundData& soundData);

	/// <summary>
	/// ãƒœãƒªãƒ¥ãƒ¼ãƒ ã‚’è¨­å®š 
	/// </summary>
	/// <param name="soundData">è¨­å®šã—ãŸã„ã‚µã‚¦ãƒ³ãƒ‰ãƒ‡ãƒ¼ã‚¿</param>
	/// <param name="volume">ãƒœãƒªãƒ¥ãƒ¼ãƒ </param>
	void SetVolume(SoundData& soundData, float volume);

public: // ã‚²ãƒƒã‚¿ãƒ¼

	// xAudioã®å–å¾—
	Microsoft::WRL::ComPtr<IXAudio2> GetXAudio2() const { return xAudio2_; }

private:

	Microsoft::WRL::ComPtr<IXAudio2> xAudio2_ = nullptr;
	IXAudio2MasteringVoice* masterVoice_ = nullptr;

	HRESULT hr;
};



============================================================
File Path: project/gameEngine/base/D3DResourceLeakChecker.cpp
============================================================
#include "D3DResourceLeakChecker.h"

#include <d3d12.h>
#include <dxgi1_6.h>
#include <wrl.h>

#include <dxgidebug.h>
#pragma comment(lib,"dxguid.lib")

D3DResourceLeakChecker::~D3DResourceLeakChecker()
{
	//ãƒªã‚½ãƒ¼ã‚¹ãƒªãƒ¼ã‚¯ãƒã‚§ãƒƒã‚¯
	Microsoft::WRL::ComPtr<IDXGIDebug1> debug;
	if (SUCCEEDED(DXGIGetDebugInterface1(0, IID_PPV_ARGS(&debug))))
	{
		debug->ReportLiveObjects(DXGI_DEBUG_ALL, DXGI_DEBUG_RLO_ALL);
		debug->ReportLiveObjects(DXGI_DEBUG_APP, DXGI_DEBUG_RLO_ALL);
		debug->ReportLiveObjects(DXGI_DEBUG_D3D12, DXGI_DEBUG_RLO_ALL);
	}
}

============================================================
File Path: project/gameEngine/base/D3DResourceLeakChecker.h
============================================================
#pragma once

/// <summary>
/// Direct3Dãƒªã‚½ãƒ¼ã‚¹ãƒªãƒ¼ã‚¯ãƒã‚§ãƒƒã‚«ãƒ¼
/// Direct3Dã®ãƒªã‚½ãƒ¼ã‚¹ãŒæ­£ã—ãè§£æ”¾ã•ã‚Œã¦ã„ã‚‹ã‹ã‚’ãƒã‚§ãƒƒã‚¯ã™ã‚‹ã‚¯ãƒ©ã‚¹
/// </summary>
class D3DResourceLeakChecker
{
public:

	/// <summary>
	/// ãƒ‡ã‚¹ãƒˆãƒ©ã‚¯ã‚¿
	/// </summary>
	~D3DResourceLeakChecker();

};



============================================================
File Path: project/gameEngine/base/DirectXCommon.cpp
============================================================

#include "DirectXCommon.h"

#include <cassert>
#include <thread>
#include <d3d12.h>

#pragma comment(lib,"d3d12.lib")
#pragma comment(lib,"dxgi.lib")

#pragma comment(lib,"winmm.lib")

using namespace Microsoft::WRL;

const uint32_t DirectXCommon::kMaxSRVCount = 512;

void DirectXCommon::Initialize(WinApp* winApp)
{
	// NULLæ¤œå‡º
	assert(winApp);
	// å€Ÿã‚Šã¦ããŸWinAppã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚’è¨˜éŒ²
	this->winApp_ = winApp;

	// FPSå›ºå®šåˆæœŸåŒ–
	InitializeFixFPS();
	// ã‚·ã‚¹ãƒ†ãƒ ã‚¿ã‚¤ãƒžãƒ¼ã®åˆ†è§£èƒ½ã‚’ä¸Šã’ã‚‹
	timeBeginPeriod(1);


	// ãƒ‡ãƒã‚¤ã‚¹ã®åˆæœŸåŒ–
	InitializeDevice();

	// ã‚³ãƒžãƒ³ãƒ‰é–¢é€£åˆæœŸåŒ–
	InitializeCommand();

	// ã‚¹ãƒ¯ãƒƒãƒ—ãƒã‚§ãƒ¼ãƒ³ã®ç”Ÿæˆ
	CreateSwapChain();



	// ãƒ‡ã‚£ã‚¹ã‚¯ãƒªãƒ—ã‚¿ãƒ’ãƒ¼ãƒ—ã®ç”Ÿæˆ
	CreateDescriptorHeap();

	// æ·±åº¦ãƒãƒƒãƒ•ã‚¡ã®ç”Ÿæˆ
	CreateDepthBuffer();




	// ãƒ¬ãƒ³ãƒ€ãƒ¼ã‚¿ãƒ¼ã‚²ãƒƒãƒˆãƒ“ãƒ¥ãƒ¼ã®åˆæœŸåŒ–
	InitializeFinalRenderTargets();

	// æ·±åº¦ã‚¹ãƒ†ãƒ³ã‚·ãƒ«ãƒ“ãƒ¥ãƒ¼ã®åˆæœŸåŒ–
	InitializeDepthStencilView();

	// ãƒ•ã‚§ãƒ³ã‚¹ç”Ÿæˆ
	CreateFence();

	// ãƒ“ãƒ¥ãƒ¼ãƒãƒ¼ãƒˆçŸ©å½¢ã®åˆæœŸåŒ–
	InitializeViewPort();

	// ã‚·ã‚¶ãƒªãƒ³ã‚°çŸ©å½¢ã®è¨­å®š
	InitializeScissor();

	// DXCã‚³ãƒ³ãƒ‘ã‚¤ãƒ©ã®ç”Ÿæˆ
	CreateDXCompiler();

	// ImGuiã®åˆæœŸåŒ–
	//InitializeImGui(); 9ç« ã§ã‚„ã‚‹

	//Fenceã®Signalã‚’å¾…ã¤ãŸã‚ã®ã‚¤ãƒ™ãƒ³ãƒˆã‚’ä½œæˆã™ã‚‹
	fenceEvent_ = CreateEvent(NULL, FALSE, FALSE, NULL);
	assert(fenceEvent_ != nullptr);


}

void DirectXCommon::ReportLiveObjects()
{
	Microsoft::WRL::ComPtr<IDXGIDebug1> debug;
	if (SUCCEEDED(DXGIGetDebugInterface1(0, IID_PPV_ARGS(&debug))))
	{
		debug->ReportLiveObjects(DXGI_DEBUG_ALL, DXGI_DEBUG_RLO_ALL);
	}
}

void DirectXCommon::Finalize()
{
	// æ—¢å­˜ã®ãƒªã‚½ãƒ¼ã‚¹è§£æ”¾å‡¦ç†

   // Report live objects
	ReportLiveObjects();
}

void DirectXCommon::InitializeDevice()
{
	HRESULT result = S_FALSE;

	//ãƒ‡ãƒãƒƒã‚°ãƒ¬ã‚¤ãƒ¤ãƒ¼
#ifdef _DEBUG
	Microsoft::WRL::ComPtr<ID3D12Debug1> debugController = nullptr;
	if (SUCCEEDED(D3D12GetDebugInterface(IID_PPV_ARGS(&debugController)))) {
		//ãƒ‡ãƒãƒƒã‚°ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚’æœ‰åŠ¹åŒ–ã™ã‚‹
		debugController->EnableDebugLayer();
		//ã•ã‚‰ã«GPUå´ã§ã‚‚ãƒã‚§ãƒƒã‚¯ã‚’è¡Œã†ã‚ˆã†ã«ã™ã‚‹
		debugController->SetEnableGPUBasedValidation(TRUE);
	}
#endif


	//DXGIãƒ•ã‚¡ã‚¯ãƒˆãƒªãƒ¼ã®ç”Ÿæˆ

	//HRESULTã¯Windowsåˆ‘ã®ã‚¨ãƒ©ãƒ¼ã‚³ãƒ¼ãƒ‰ã§ã‚ã‚Šã€
	//é–¢æ•°ãŒæˆåŠŸã—ãŸã‹ã©ã†ã‹ã‚’SUCCEEDEDãƒžã‚¯ãƒ­ã§åˆ¤å®šã§ãã‚‹
	result = CreateDXGIFactory(IID_PPV_ARGS(&dxgiFactory_));
	//åˆæœŸåŒ–ã®æ ¹æœ¬çš„ãªéƒ¨åˆ†ã§ã‚¨ãƒ©ãƒ¼ãŒå‡ºãŸå ´åˆã¯ãƒ—ãƒ­ã‚°ãƒ©ãƒ ãŒé–“é•ã£ã¦ã„ã‚‹ã‹ã€
	//ã©ã†ã«ã‚‚ã§ããªã„å ´åˆãŒå¤šã„ã®ã§assertã«ã—ã¦ãŠã
	assert(SUCCEEDED(result));

	//ä½¿ç”¨ã™ã‚‹ã‚¢ãƒ€ãƒ—ã‚¿ç”¨ã®å¤‰æ•°ã€‚æœ€åˆã«nullptrã‚’å…¥ã‚Œã¦ãŠã
	Microsoft::WRL::ComPtr<IDXGIAdapter4> useAdapter = nullptr;
	//ã„ã„é †ã«ã‚¢ãƒ€ãƒ—ã‚¿ã‚’é ¼ã‚€
	for (UINT i = 0; dxgiFactory_->EnumAdapterByGpuPreference(i, DXGI_GPU_PREFERENCE_HIGH_PERFORMANCE, IID_PPV_ARGS(&useAdapter)) != DXGI_ERROR_NOT_FOUND; i++)
	{
		//ã‚¢ãƒ€ãƒ—ã‚¿ãƒ¼ã®æƒ…å ±ã‚’å–å¾—ã™ã‚‹
		DXGI_ADAPTER_DESC3 adapterDesc{};
		result = useAdapter->GetDesc3(&adapterDesc);
		assert(SUCCEEDED(result));	//å–å¾—ã§ããªã„ã®ã¯ä¸€å¤§äº‹
		//ã‚½ãƒ•ãƒˆã‚¦ã‚§ã‚¢ã‚¢ãƒ€ãƒ—ã‚¿ã§ãªã‘ã‚Œã°æŽ¡ç”¨ï¼
		if (!(adapterDesc.Flags & DXGI_ADAPTER_FLAG3_SOFTWARE))
		{
			//æŽ¡ç”¨ã—ãŸã‚¢ãƒ€ãƒ—ã‚¿ã®æƒ…å ±ã‚’ãƒ­ã‚°ã«å‡ºåŠ›ã€‚wstringã®æ–¹ãªã®ã§æ³¨æ„
			Logger::Log(StringUtility::ConvertString(std::format(L"Use Adapter:{}\n", adapterDesc.Description)));
			break;
		}
		useAdapter = nullptr;
	}
	//é©åˆ‡ãªã‚¢ãƒ€ãƒ—ã‚¿ãŒè¦‹ã¤ã‹ã‚‰ãªã‹ã£ãŸã®ã§èµ·å‹•ã§ããªã„
	assert(useAdapter != nullptr);



	//æ©Ÿèƒ½ãƒ¬ãƒ™ãƒ«ã¨ãƒ­ã‚°ã®å‡ºåŠ›ç”¨ã®æ–‡å­—åˆ—
	D3D_FEATURE_LEVEL featureLevels[] = {
		D3D_FEATURE_LEVEL_12_2,D3D_FEATURE_LEVEL_12_1,D3D_FEATURE_LEVEL_12_0
	};
	const char* featureLevelStrings[] = { "12.2","12.1","12.0" };
	//é«˜ã„é †ã«ç”Ÿæˆã§ãã‚‹ã‹è©¦ã—ã¦ã„ã
	for (size_t i = 0; i < _countof(featureLevels); ++i)
	{
		//æŽ¡ç”¨ã—ãŸã‚¢ãƒ€ãƒ—ã‚¿ãƒ¼ã§ãƒ‡ãƒã‚¤ã‚¹ã‚’ç”Ÿæˆ
		result = D3D12CreateDevice(useAdapter.Get(), featureLevels[i], IID_PPV_ARGS(&device_));
		//æŒ‡å®šã—ãŸæ©Ÿèƒ½ãƒ¬ãƒ™ãƒ«ã§ãƒ‡ãƒã‚¤ã‚¹ãŒç”Ÿæˆã§ããŸã‹ã‚’ç¢ºèª
		if (SUCCEEDED(result))
		{
			//ç”Ÿæˆã§ããŸã®ã§ãƒ­ã‚°å‡ºåŠ›ã‚’è¡Œã£ã¦ãƒ«ãƒ¼ãƒ—ã‚’æŠœã‘ã‚‹
			Logger::Log(std::format("FeatureLevel : {}\n", featureLevelStrings[i]));
			break;
		}
	}
	//ãƒ‡ãƒã‚¤ã‚¹ã®ç”ŸæˆãŒã†ã¾ãã„ã‹ãªã‹ã£ãŸã®ã§èµ·å‹•ã§ããªã„
	assert(device_ != nullptr);
	Logger::Log("Complete create D3D12Device!!!");//åˆæœŸåŒ–å®Œäº†ã®ãƒ­ã‚°ã‚’å‡ºã™



#ifdef _DEBUG
	Microsoft::WRL::ComPtr<ID3D12InfoQueue> infoQueue = nullptr;
	if (SUCCEEDED(device_->QueryInterface(IID_PPV_ARGS(&infoQueue))))
	{
		//ã‚„ã°ã„ã‚¨ãƒ©ãƒ¼æ™‚ã«æ­¢ã¾ã‚‹
		infoQueue->SetBreakOnSeverity(D3D12_MESSAGE_SEVERITY_CORRUPTION, true);
		//ã‚¨ãƒ©ãƒ¼æ™‚ã«æ­¢ã¾ã‚‹
		infoQueue->SetBreakOnSeverity(D3D12_MESSAGE_SEVERITY_ERROR, true);
		//è­¦å‘Šæ™‚ã«æ­¢ã¾ã‚‹
		//infoQueue->SetBreakOnSeverity(D3D12_MESSAGE_SEVERITY_WARNING, true);

		//æŠ‘åˆ¶ã™ã‚‹ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã®ID
		D3D12_MESSAGE_ID denyIds[] = {
			//windows11ã¾ã§ã®DXGIãƒ‡ãƒãƒƒã‚°ãƒ¬ã‚¤ãƒ¤ãƒ¼ã¨DX12ãƒ‡ãƒãƒƒã‚°ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®ç›¸äº’ä½œç”¨ãƒã‚°ã«ã‚ˆã‚‹ã‚¨ãƒ©ãƒ¼ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸
			D3D12_MESSAGE_ID_RESOURCE_BARRIER_MISMATCHING_COMMAND_LIST_TYPE
		};
		//æŠ‘åˆ¶ã™ã‚‹ãƒ¬ãƒ™ãƒ«
		D3D12_MESSAGE_SEVERITY severities[] = { D3D12_MESSAGE_SEVERITY_INFO };
		D3D12_INFO_QUEUE_FILTER filter{};
		filter.DenyList.NumIDs = _countof(denyIds);
		filter.DenyList.pIDList = denyIds;
		filter.DenyList.NumSeverities = _countof(severities);
		filter.DenyList.pSeverityList = severities;
		//æŒ‡å®šã—ãŸãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã®è¡¨ç¤ºã‚’æŠ‘åˆ¶ã™ã‚‹
		infoQueue->PushStorageFilter(&filter);

		//è§£æ”¾
		//infoQueue->Release();
	}
#endif
}

void DirectXCommon::InitializeCommand()
{
	HRESULT result = S_FALSE;

	// ã‚³ãƒžãƒ³ãƒ‰ã‚¢ãƒ­ã‚±ãƒ¼ã‚¿ã‚’ç”Ÿæˆ
	result = device_->CreateCommandAllocator(D3D12_COMMAND_LIST_TYPE_DIRECT, IID_PPV_ARGS(&commandAllocator_));
	// ã‚³ãƒžãƒ³ãƒ‰ã‚¢ãƒ­ã‚±ãƒ¼ã‚¿ã®ç”ŸæˆãŒã†ã¾ãã„ã‹ãªã‹ã£ãŸã®ã§èµ·å‹•ã§ããªã„
	assert(SUCCEEDED(result));

	// ã‚³ãƒžãƒ³ãƒ‰ãƒªã‚¹ãƒˆã‚’ç”Ÿæˆ
	result = device_->CreateCommandList(0, D3D12_COMMAND_LIST_TYPE_DIRECT, commandAllocator_.Get(), nullptr, IID_PPV_ARGS(&commandList_));
	// ã‚³ãƒžãƒ³ãƒ‰ãƒªã‚¹ãƒˆã®ç”ŸæˆãŒã†ã¾ãã„ã‹ãªã‹ã£ãŸã®ã§èµ·å‹•ã§ããªã„
	assert(SUCCEEDED(result));

	// æ¨™æº–è¨­å®šã§ã‚³ãƒžãƒ³ãƒ‰ã‚­ãƒ¥ãƒ¼ã‚’ç”Ÿæˆ
	D3D12_COMMAND_QUEUE_DESC commandQueueDesc{};
	result = device_->CreateCommandQueue(&commandQueueDesc, IID_PPV_ARGS(&commandQueue_));
	// ã‚³ãƒžãƒ³ãƒ‰ã‚­ãƒ¥ãƒ¼ã®ç”ŸæˆãŒã†ã¾ãã„ã‹ãªã‹ã£ãŸã®ã§èµ·å‹•ã§ããªã„
	assert(SUCCEEDED(result));
}

void DirectXCommon::CreateSwapChain()
{
	HRESULT result = S_FALSE;

	//ã‚¹ãƒ¯ãƒƒãƒ—ãƒã‚§ã‚¤ãƒ³ã‚’ç”Ÿæˆã™ã‚‹
	swapChainDesc_.Width = WinApp::kClientWidth;						// ç”»é¢ã®å¹…ã€‚ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ã®ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆé ˜åŸŸã‚’åŒã˜ã‚‚ã®ã«ã—ã¦ãŠã
	swapChainDesc_.Height = WinApp::kClientHeight;						// ç”»é¢ã®é«˜ã•ã€‚ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ã®ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆé ˜åŸŸã‚’åŒã˜ã‚‚ã®ã«ã—ã¦ãŠã
	swapChainDesc_.Format = /*DXGI_FORMAT_R8G8B8A8_UNORM_SRGB*/DXGI_FORMAT_R8G8B8A8_UNORM;				    // è‰²ã®å½¢å¼
	swapChainDesc_.SampleDesc.Count = 1;								// ãƒžãƒ«ãƒã‚µãƒ³ãƒ—ãƒ«ã—ãªã„
	swapChainDesc_.BufferUsage = DXGI_USAGE_RENDER_TARGET_OUTPUT;	    // æç”»ã®ã‚¿ãƒ¼ã‚²ãƒƒãƒˆã¨ã—ã¦åˆ©ç”¨ã™ã‚‹
	swapChainDesc_.BufferCount = 2;									    // ãƒ€ãƒ–ãƒ«ãƒãƒƒãƒ•ã‚¡
	swapChainDesc_.SwapEffect = DXGI_SWAP_EFFECT_FLIP_DISCARD;		    // ãƒ¢ãƒ‹ã‚¿ã«ã†ã¤ã—ãŸã‚‰ã€ä¸­èº«ã‚’å»ƒæ£„

	//ã‚³ãƒžãƒ³ãƒ‰ã‚­ãƒ¥ãƒ¼ã€ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ãƒãƒ³ãƒ‰ãƒ«ã€è¨­å®šã‚’æ¸¡ã—ã¦ç”Ÿæˆã™ã‚‹
	result = dxgiFactory_->CreateSwapChainForHwnd(commandQueue_.Get(), winApp_->GetHwnd(), &swapChainDesc_, nullptr, nullptr, reinterpret_cast<IDXGISwapChain1**>(swapChain_.GetAddressOf()));
	assert(SUCCEEDED(result));

}

void DirectXCommon::CreateDepthBuffer()
{
	HRESULT result = S_FALSE;

	//åˆ©ç”¨ã™ã‚‹Heapã®è¨­å®š
	D3D12_HEAP_PROPERTIES heapProperties{};
	heapProperties.Type = D3D12_HEAP_TYPE_DEFAULT;						//VRAMä¸Šã«ä½œã‚‹

	D3D12_RESOURCE_DESC resourceDesc{};
	resourceDesc.Width = WinApp::kClientWidth;											//Textureã®å¹…
	resourceDesc.Height = WinApp::kClientHeight;										//Textureã®é«˜ã•
	resourceDesc.MipLevels = 1;											//mipmapã®æ•°
	resourceDesc.DepthOrArraySize = 1;									//å¥¥è¡Œã or é…åˆ—Textureã®é…åˆ—æ•°
	resourceDesc.Format = DXGI_FORMAT_D24_UNORM_S8_UINT;				//DepthStencilã¨ã—ã¦åˆ©ç”¨å¯èƒ½ãªãƒ•ã‚©ãƒ¼ãƒžãƒƒãƒˆ
	resourceDesc.SampleDesc.Count = 1;									//ã‚µãƒ³ãƒ—ãƒªãƒ³ã‚°ã‚«ã‚¦ãƒ³ãƒˆã€‚ï¼‘å€‹æŒ‡å®š
	resourceDesc.Dimension = D3D12_RESOURCE_DIMENSION_TEXTURE2D;		//ï¼’æ¬¡å…ƒ
	resourceDesc.Flags = D3D12_RESOURCE_FLAG_ALLOW_DEPTH_STENCIL;		//DepthStencilã¨ã—ã¦ä½¿ã†é€šçŸ¥

	//æ·±åº¦å€¤ã®ã‚¯ãƒªã‚¢è¨­å®š
	D3D12_CLEAR_VALUE depthClearValue{};
	depthClearValue.DepthStencil.Depth = 1.0f;							//1.0f(æœ€å¤§å€¤)ã§ã‚¯ãƒªã‚¢
	depthClearValue.Format = DXGI_FORMAT_D24_UNORM_S8_UINT;				//ãƒ•ã‚©ãƒ¼ãƒžãƒƒãƒˆã€‚Resourceã¨åˆã‚ã›ã‚‹

	//resourceã®ç”Ÿæˆ
	result = device_->CreateCommittedResource(
		&heapProperties,												//Heapã®è¨­å®š
		D3D12_HEAP_FLAG_NONE,											//Heapã®ç‰¹æ®Šãªè¨­å®šã€‚ç‰¹ã«ãªã—
		&resourceDesc,													//Resourceã®è¨­å®š
		D3D12_RESOURCE_STATE_DEPTH_WRITE,								    //æ·±åº¦å€¤ã‚’æ›¸ãè¾¼ã‚€çŠ¶æ…‹ã«ã—ã¦ãŠã
		&depthClearValue,		//Clearæœ€é©å€¤
		IID_PPV_ARGS(&resource_)											//ä½œæˆã™ã‚‹Resourceãƒã‚¤ãƒ³ã‚¿ã¸ã®ãƒã‚¤ãƒ³ã‚¿
	);
	assert(SUCCEEDED(result));


	InitializeDepthStencilView();
}

void DirectXCommon::CreateDescriptorHeap()
{
	//RTVç”¨ã®ãƒ’ãƒ¼ãƒ—ã§ãƒ‡ã‚£ã‚¹ã‚¯ãƒªãƒ—ã‚¿ã®æ•°ã¯ï¼’ã€‚RTVã¯Shaderå†…ã§è§¦ã‚‹ã‚‚ã®ã§ã¯ãªã„ã®ã§ã€ShaderVisibleã¯false
	rtvDescriptorHeap_ = CreateDescriptorHeap(D3D12_DESCRIPTOR_HEAP_TYPE_RTV, 2, false);

	//SRVç”¨ã®ãƒ’ãƒ¼ãƒ—ã§ãƒ‡ã‚£ã‚¹ã‚¯ãƒªãƒ—ã‚¿ã®æ•°ã¯ï¼‘ï¼’ï¼˜ã€‚SRVã¯Shaderå†…ã§è§¦ã‚‹ã‚‚ã®ãªã®ã§ã€ShaderVisibleã¯true
	srvDescriptorHeap_ = CreateDescriptorHeap(D3D12_DESCRIPTOR_HEAP_TYPE_CBV_SRV_UAV, kMaxSRVCount, true);

	//DSVç”¨ã®ãƒ’ãƒ¼ãƒ—ã§ãƒ‡ã‚£ã‚¹ã‚¯ãƒªãƒ—ã‚¿ã®æ•°ã¯ï¼‘ã€‚DSVã¯Sharderå†…ã§è§¦ã‚‹ã‚‚ã®ã§ã¯ãªã„ã®ã§ã€ShaderVisibleã¯false
	dsvDescriptorHeap_ = CreateDescriptorHeap(D3D12_DESCRIPTOR_HEAP_TYPE_DSV, 1, false);


	//ãƒ‡ã‚£ã‚¹ã‚¯ãƒªãƒ—ã‚¿ãƒ’ãƒ¼ãƒ—ã®ã‚µã‚¤ã‚º
	descriptorSizeSRV_ = device_->GetDescriptorHandleIncrementSize(D3D12_DESCRIPTOR_HEAP_TYPE_CBV_SRV_UAV);
	descriptorSizeRTV_ = device_->GetDescriptorHandleIncrementSize(D3D12_DESCRIPTOR_HEAP_TYPE_RTV);
	descriptorSizeDSV_ = device_->GetDescriptorHandleIncrementSize(D3D12_DESCRIPTOR_HEAP_TYPE_DSV);

}

Microsoft::WRL::ComPtr<ID3D12DescriptorHeap> DirectXCommon::CreateDescriptorHeap(D3D12_DESCRIPTOR_HEAP_TYPE heapType, UINT numDescriptor, bool shaderVisible)
{
	HRESULT result = S_FALSE;

	Microsoft::WRL::ComPtr<ID3D12DescriptorHeap> descriptorHeap = nullptr;
	D3D12_DESCRIPTOR_HEAP_DESC descriptorHeapDesc{};
	descriptorHeapDesc.Type = heapType;
	descriptorHeapDesc.NumDescriptors = numDescriptor;
	descriptorHeapDesc.Flags = shaderVisible ? D3D12_DESCRIPTOR_HEAP_FLAG_SHADER_VISIBLE : D3D12_DESCRIPTOR_HEAP_FLAG_NONE;
	result = device_->CreateDescriptorHeap(&descriptorHeapDesc, IID_PPV_ARGS(&descriptorHeap));
	assert(SUCCEEDED(result));

	return descriptorHeap;
}

void DirectXCommon::InitializeFinalRenderTargets()
{
	HRESULT result = S_FALSE;


	//SwapChainã‹ã‚‰Resourceã‚’å¼•ã£å¼µã£ã¦ãã‚‹
	result = swapChain_->GetBuffer(0, IID_PPV_ARGS(&swapChainResources_[0]));
	//ã†ã¾ãå–å¾—ã§ããªã‘ã‚Œã°èµ·å‹•ã§ããªã„
	assert(SUCCEEDED(result));
	result = swapChain_->GetBuffer(1, IID_PPV_ARGS(&swapChainResources_[1]));
	assert(SUCCEEDED(result));


	//RTVã®è¨­å®š
	rtvDesc_.Format = DXGI_FORMAT_R8G8B8A8_UNORM_SRGB;
	rtvDesc_.ViewDimension = D3D12_RTV_DIMENSION_TEXTURE2D;
	//ãƒ‡ã‚£ã‚¹ã‚¯ãƒªãƒ—ã‚¿ã®å…ˆé ­ã‚’å–å¾—ã™ã‚‹
	D3D12_CPU_DESCRIPTOR_HANDLE rtvStartHandle = rtvDescriptorHeap_->GetCPUDescriptorHandleForHeapStart();

	// è£è¡¨ã®2ã¤åˆ†
	rtvHandles_[0] = rtvStartHandle;
	device_->CreateRenderTargetView(swapChainResources_[0].Get(), &rtvDesc_, rtvHandles_[0]);
	rtvHandles_[0] = GetCPUDescriptorHandle(rtvDescriptorHeap_, descriptorSizeRTV_, 0);

	//ï¼’ã¤ç›®_ã®ãƒ‡ã‚£ã‚¹ã‚¯ãƒªãƒ—ã‚¿ãƒãƒ³ãƒ‰ãƒ«ã‚’å¾—ã‚‹
	rtvHandles_[1].ptr = rtvHandles_[0].ptr + device_->GetDescriptorHandleIncrementSize(D3D12_DESCRIPTOR_HEAP_TYPE_RTV);

	//rtvHandles_[1] = rtvStartHandle;
	device_->CreateRenderTargetView(swapChainResources_[1].Get(), &rtvDesc_, rtvHandles_[1]);
	rtvHandles_[1] = GetCPUDescriptorHandle(rtvDescriptorHeap_, descriptorSizeRTV_, 1);


	//æç”»å…ˆã®RTVã¨DSVã‚’è¨­å®šã™ã‚‹
	dsvHandle_ = dsvDescriptorHeap_->GetCPUDescriptorHandleForHeapStart();

}

D3D12_CPU_DESCRIPTOR_HANDLE DirectXCommon::GetCPUDescriptorHandle(Microsoft::WRL::ComPtr<ID3D12DescriptorHeap> descriptorHeap, uint32_t descriptorSize, uint32_t index)
{
	D3D12_CPU_DESCRIPTOR_HANDLE handleCPU = descriptorHeap->GetCPUDescriptorHandleForHeapStart();
	handleCPU.ptr += (descriptorSize * index);
	return handleCPU;
}

D3D12_GPU_DESCRIPTOR_HANDLE DirectXCommon::GetGPUDescriptorHandle(Microsoft::WRL::ComPtr<ID3D12DescriptorHeap> descriptorHeap, uint32_t descriptorSize, uint32_t index)
{
	D3D12_GPU_DESCRIPTOR_HANDLE handleGPU = descriptorHeap->GetGPUDescriptorHandleForHeapStart();
	handleGPU.ptr += (descriptorSize * index);
	return handleGPU;
}

D3D12_CPU_DESCRIPTOR_HANDLE DirectXCommon::GetSRVCPUDescriptorHandle(uint32_t index)
{
	return GetCPUDescriptorHandle(srvDescriptorHeap_, descriptorSizeSRV_, index);
}

D3D12_GPU_DESCRIPTOR_HANDLE DirectXCommon::GetSRVGPUDescriptorHandle(uint32_t index)
{
	return GetGPUDescriptorHandle(srvDescriptorHeap_, descriptorSizeSRV_, index);
}

void DirectXCommon::InitializeDepthStencilView()
{
	//DepthStencilTextureã‚’ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ã®ã‚µã‚¤ã‚ºã§ä½œæˆ
	//Microsoft::WRL::ComPtr<ID3D12Resource> depthStencilResource = CreateDepthStencilTextureResource(device, WinApp::kClientWidth, WinApp::kClientHeight);
	//DSVã®è¨­å®š
	D3D12_DEPTH_STENCIL_VIEW_DESC dsvDesc{};
	dsvDesc.Format = DXGI_FORMAT_D24_UNORM_S8_UINT;
	dsvDesc.ViewDimension = D3D12_DSV_DIMENSION_TEXTURE2D;
	//DSVHeapã®å…ˆé ­ã«DSVã‚’ä½œã‚‹
	device_->CreateDepthStencilView(
		resource_.Get(),
		&dsvDesc,
		dsvDescriptorHeap_->GetCPUDescriptorHandleForHeapStart()
	);
}

void DirectXCommon::CreateFence()
{
	HRESULT result = S_FALSE;

	// ãƒ•ã‚§ãƒ³ã‚¹ã®ç”Ÿæˆ
	//åˆæœŸå€¤0ã§Fenceã‚’ä½œã‚‹
	result = device_->CreateFence(fenceValue_, D3D12_FENCE_FLAG_NONE, IID_PPV_ARGS(&fence_));
	assert(SUCCEEDED(result));
}

void DirectXCommon::InitializeViewPort()
{
	//ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆé ˜åŸŸã®ã‚µã‚¤ã‚ºã¨ä¸€ç·’ã«ã—ã¦ç”»é¢å…¨ä½“ã«è¡¨ç¤º
	viewport_.Width = WinApp::kClientWidth;
	viewport_.Height = WinApp::kClientHeight;
	viewport_.TopLeftX = 0;
	viewport_.TopLeftY = 0;
	viewport_.MinDepth = 0.0f;
	viewport_.MaxDepth = 1.0f;
}

void DirectXCommon::InitializeScissor()
{
	//åŸºæœ¬çš„ã«ãƒ“ãƒ¥ãƒ¼ãƒãƒ¼ãƒˆã¨åŒã˜çŸ©å½¢ãŒæ§‹æˆã•ã‚Œã‚‹ã‚ˆã†ã«ã™ã‚‹
	scissorRect_.left = 0;
	scissorRect_.right = WinApp::kClientWidth;
	scissorRect_.top = 0;
	scissorRect_.bottom = WinApp::kClientHeight;
}

void DirectXCommon::CreateDXCompiler()
{
	HRESULT result = S_FALSE;

	result = DxcCreateInstance(CLSID_DxcUtils, IID_PPV_ARGS(&dxcUtils_));
	assert(SUCCEEDED(result));
	result = DxcCreateInstance(CLSID_DxcCompiler, IID_PPV_ARGS(&dxcCompiler_));
	assert(SUCCEEDED(result));

	//ç¾æ™‚ç‚¹ã§includeã¯ã—ãªã„ãŒã€includeã«å¯¾å¿œã™ã‚‹ãŸã‚ã®è¨­å®šã‚’è¡Œã£ã¦ãŠã
	result = dxcUtils_->CreateDefaultIncludeHandler(&includeHandler_);
	assert(SUCCEEDED(result));
}

void DirectXCommon::InitializeImGui()
{
#ifdef USE_IMGUI

	//ImGuiã®åˆæœŸåŒ–
	/*IMGUI_CHECKVERSION();
	ImGui::CreateContext();
	ImGui::StyleColorsDark();
	ImGui_ImplWin32_Init(winApp_->GetHwnd());
	ImGui_ImplDX12_Init(
		device_.Get(),
		swapChainDesc_.BufferCount,
		rtvDesc_.Format,
		srvDescriptorHeap_.Get(),
		srvDescriptorHeap_->GetCPUDescriptorHandleForHeapStart(),
		srvDescriptorHeap_->GetGPUDescriptorHandleForHeapStart()
	);*/

#endif // USE_IMGUI
}

void DirectXCommon::PreDraw()
{
	//ã“ã‚Œã‹ã‚‰æ›¸ãè¾¼ã‚€ãƒãƒƒã‚¯ãƒãƒƒãƒ•ã‚¡ã®ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã‚’å–å¾—
	UINT backBufferIndex = swapChain_->GetCurrentBackBufferIndex();


	//TransitionBarrierã®è¨­å®š
	//ä»Šå›žã®ãƒãƒªã‚¢ã¯Transition
	barrier_.Type = D3D12_RESOURCE_BARRIER_TYPE_TRANSITION;
	//Noneã«ã—ã¦ãŠã
	barrier_.Flags = D3D12_RESOURCE_BARRIER_FLAG_NONE;
	//ãƒãƒªã‚¢ã‚’å¼µã‚‹å¯¾ç§°ã®ãƒªã‚½ãƒ¼ã‚¹ã€‚ç¾åœ¨ã®ãƒãƒƒã‚¯ãƒãƒƒãƒ•ã‚¡ã«å¯¾ã—ã¦è¡Œã†
	barrier_.Transition.pResource = swapChainResources_[backBufferIndex].Get();
	//é·ç§»å‰ï¼ˆç¾åœ¨ï¼‰ã®resourceState
	barrier_.Transition.StateBefore = D3D12_RESOURCE_STATE_PRESENT;
	//é·ç§»å¾Œã®ResourceState
	barrier_.Transition.StateAfter = D3D12_RESOURCE_STATE_RENDER_TARGET;
	//transitionBarrierã‚’å¼µã‚‹
	commandList_->ResourceBarrier(1, &barrier_);




	//æç”»å…ˆã®RTVã‚’è¨­å®šã™ã‚‹
	commandList_->OMSetRenderTargets(1, &rtvHandles_[backBufferIndex], false, nullptr);
	commandList_->OMSetRenderTargets(1, &rtvHandles_[backBufferIndex], false, &dsvHandle_);


	//æŒ‡å®šã—ãŸè‰²ã§ç”»é¢å…¨ä½“ã‚’ã‚¯ãƒªã‚¢ã™ã‚‹
	float clearColor[] = { 1.0f,0.98f,0.85f,1.0f };//{ 0.1f,0.25f,0.5f,1.0f };	//é’ã£ã½ã„è‰²ã€‚RGBAã®é †
	commandList_->ClearRenderTargetView(rtvHandles_[backBufferIndex], clearColor, 0, nullptr);

	//æŒ‡å®šã—ãŸæ·±åº¦ã§ç”»é¢å…¨ä½“ã‚’ã‚¯ãƒªã‚¢ã™ã‚‹
	commandList_->ClearDepthStencilView(
		dsvHandle_,
		D3D12_CLEAR_FLAG_DEPTH,
		1.0f,
		0,
		0,
		nullptr
	);

	//æç”»ç”¨ã®DescriptorHeapã®è¨­å®š
	//ã‚‚ã‚ã‚‚ã‚ã®æç”»å‡¦ç†ãŒçµ‚ã‚ã£ãŸã‚¿ã‚¤ãƒŸãƒ³ã‚°ã§ImGuiã®æç”»ã‚³ãƒžãƒ³ãƒ‰ã‚’ç©ã‚€
	//Guiã¯ç”»é¢ã®æœ€å‰é¢ã«æ˜ ã™ã®ã§ã€ä¸€ç•ªæœ€å¾Œã®æç”»ã¨ã—ã¦è¡Œã†
	//Microsoft::WRL::ComPtr<ID3D12DescriptorHeap> descriptorHeaps[] = { srvDescriptorHeap_ };
	//commandList_->SetDescriptorHeaps(1, descriptorHeaps->GetAddressOf());

	commandList_->RSSetViewports(1, &viewport_);
	commandList_->RSSetScissorRects(1, &scissorRect_);
}

void DirectXCommon::PostDraw()
{
	HRESULT result = S_FALSE;

	//ã“ã‚Œã‹ã‚‰æ›¸ãè¾¼ã‚€ãƒãƒƒã‚¯ãƒãƒƒãƒ•ã‚¡ã®ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã‚’å–å¾—
	UINT backBufferIndex = swapChain_->GetCurrentBackBufferIndex();

	//ç”»é¢ã®å„å‡¦ç†ã¯ã™ã¹ã¦çµ‚ã‚ã‚Šã€ç”»é¢ã«ç§»ã™ã®ã§ã€çŠ¶æ…‹ã‚’é·ç§»
	//ä»Šå›žã¯RenderTargetã‹ã‚‰Presentã«ã™ã‚‹
	barrier_.Type = D3D12_RESOURCE_BARRIER_TYPE_TRANSITION;
	barrier_.Flags = D3D12_RESOURCE_BARRIER_FLAG_NONE;
	barrier_.Transition.pResource = swapChainResources_[backBufferIndex].Get();
	barrier_.Transition.StateBefore = D3D12_RESOURCE_STATE_RENDER_TARGET;
	barrier_.Transition.StateAfter = D3D12_RESOURCE_STATE_PRESENT;
	barrier_.Transition.Subresource = D3D12_RESOURCE_BARRIER_ALL_SUBRESOURCES;


	//Transitonã®Barrierã‚’å¼µã‚‹
	commandList_->ResourceBarrier(1, &barrier_);



	//ã‚³ãƒžãƒ³ãƒ‰ãƒªã‚¹ãƒˆã®å†…å®¹ã‚’ç¢ºå®šã•ã›ã‚‹ã€‚ã™ã¹ã¦ã®ã‚³ãƒžãƒ³ãƒ‰ã‚’é ¼ã‚“ã§ã‹ã‚‰Closeã™ã‚‹ã“ã¨
	result = commandList_->Close();
	assert(SUCCEEDED(result));


	// FPSå›ºå®š
	UpdateFixFPS();


	//ã‚³ãƒžãƒ³ãƒ‰ã‚’ã‚­ãƒƒã‚¯ã™ã‚‹
	//GPUäºŒã‚³ãƒžãƒ³ãƒ‰ãƒªã‚¹ãƒˆã®å®Ÿè¡Œã‚’è¡Œã‚ã›ã‚‹
	Microsoft::WRL::ComPtr<ID3D12CommandList> commandLists[] = { commandList_ };
	commandQueue_->ExecuteCommandLists(1, commandLists->GetAddressOf());
	//GPUã¨OSã«ç”»é¢ã®äº¤æ›ã‚’è¡Œã†ã‚ˆã†ã«é€šçŸ¥ã™ã‚‹
	swapChain_->Present(1, 0);



	//Fenceã®å€¤ã‚’æ›´æ–°
	fenceValue_++;
	//GPUãŒã“ã“ã¾ã§ãŸã©ã‚Šç€ã„ãŸã¨ãã«ã€Fenceã®å€¤ã‚’æŒ‡å®šã—ãŸå€¤ã‚’ä»£å…¥ã™ã‚‹ã‚ˆã†ã«Signalã‚’é€ã‚‹
	commandQueue_->Signal(fence_.Get(), fenceValue_);
	//Fenceã®å€¤ãŒæŒ‡å®šã—ãŸSignalå€¤ã«ãŸã©ã‚Šç€ã„ã¦ã„ã‚‹ã‹ç¢ºèªã™ã‚‹
	//GetCompleteValueã®åˆæœŸå€¤ã¯Fenceåˆ¶ä½œæ™‚ã«æ¸¡ã—ãŸåˆæœŸå€¤
	if (fence_->GetCompletedValue() < fenceValue_)
	{
		//æŒ‡å®šã—ãŸSignalã«ãŸã©ã‚Šç€ã„ã¦ã„ãªã„ã®ã§ã€ãŸã©ã‚Šç€ãã¾ã§å¾…ã¤ã‚ˆã†ã«ã‚¤ãƒ™ãƒ³ãƒˆã‚’è¨­å®šã™ã‚‹
		fence_->SetEventOnCompletion(fenceValue_, fenceEvent_);
		//ã‚¤ãƒ™ãƒ³ãƒˆã‚’å¾…ã¤
		WaitForSingleObject(fenceEvent_, INFINITE);
	}

	//æ¬¡ãƒ•ãƒ¬ãƒ¼ãƒ ç”¨ã®ã‚³ãƒžãƒ³ãƒ‰ãƒªã‚¹ãƒˆã‚’æº–å‚™
	result = commandAllocator_->Reset();
	assert(SUCCEEDED(result));
	result = commandList_->Reset(commandAllocator_.Get(), nullptr);
	assert(SUCCEEDED(result));
}

Microsoft::WRL::ComPtr<IDxcBlob> DirectXCommon::CompileShader(const std::wstring& filePath, const wchar_t* profile)
{
	HRESULT result = S_FALSE;

	//hlslãƒ•ã‚¡ã‚¤ãƒ«ã‚’èª­ã‚€

	//ã“ã‚Œã‹ã‚‰ã‚·ã‚§ãƒ¼ãƒ€ãƒ¼ã‚’ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ã™ã‚‹æ—¨ã‚’ãƒ­ã‚°ã«å‡ºã™
	Logger::Log(StringUtility::ConvertString(std::format(L"Begin CompileSharder, path:{}, profile:{}\n", filePath, profile)));
	//hlslãƒ•ã‚¡ã‚¤ãƒ«ã‚’èª­ã‚€
	IDxcBlobEncoding* shaderSource = nullptr;
	result = dxcUtils_->LoadFile(filePath.c_str(), nullptr, &shaderSource);
	//èª­ã‚ãªã‹ã£ãŸã‚‰æ­¢ã‚ã‚‹
	assert(SUCCEEDED(result));
	//èª­ã¿è¾¼ã‚“ã ãƒ•ã‚¡ã‚¤ãƒ«ã®å†…å®¹ã‚’è¨­å®šã™ã‚‹
	DxcBuffer shaderSourceBuffer;
	shaderSourceBuffer.Ptr = shaderSource->GetBufferPointer();
	shaderSourceBuffer.Size = shaderSource->GetBufferSize();
	shaderSourceBuffer.Encoding = DXC_CP_UTF8;		//UTF8ã®æ–‡å­—ã‚³ãƒ¼ãƒ‰ã§ã‚ã‚‹ã“ã¨ã‚’é€šçŸ¥

	//ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ã™ã‚‹

	LPCWSTR arguments[] = {
		filePath.c_str(),				//ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«å¯¾ç§°ã®hlslãƒ•ã‚¡ã‚¤ãƒ«å
		L"-E", L"main",					//ã‚¨ãƒ³ãƒˆãƒªãƒ¼ãƒã‚¤ãƒ³ãƒˆã®æŒ‡å®šã€‚åŸºæœ¬çš„ã«mainä»¥å¤–ã«ã¯ã—ãªã„
		L"-T", profile,					//Sharderprofileã®è¨­å®š
		L"-Zi", L"-Qembed_debug",		//ãƒ‡ãƒãƒƒã‚°ç”¨ã®æƒ…å ±ã‚’åŸ‹ã‚è¾¼ã‚€
		L"-Od",							//æœ€é©åŒ–ã‚’å¤–ã—ã¦ãŠã
		L"-Zpr",						//ãƒ¡ãƒ¢ãƒªãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆã¯è¡Œå„ªå…ˆ
	};

	//å®Ÿéš›ã«ã‚·ã‚§ãƒ¼ãƒ€ãƒ¼ã‚’ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ã™ã‚‹
	IDxcResult* shaderResult = nullptr;
	result = dxcCompiler_->Compile(
		&shaderSourceBuffer,
		arguments,
		_countof(arguments),
		includeHandler_,
		IID_PPV_ARGS(&shaderResult)
	);
	//ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ã‚¨ãƒ©ãƒ¼ã§ã¯ãªãdxcã§èµ·å‹•ã§ããªã„ãªã©è‡´å‘½çš„ãªçŠ¶æ³
	assert(SUCCEEDED(result));



	//è­¦å‘Šãƒ»ã‚¨ãƒ©ãƒ¼ãŒå‡ºã¦ã„ãªã„ã‹ç¢ºèªã™ã‚‹


	//è­¦å‘Šãƒ»ã‚¨ãƒ©ãƒ¼ãŒå‡ºã¦ãŸã‚‰ãƒ­ã‚°ã«å‡ºã—ã¦æ­¢ã‚ã‚‹
	IDxcBlobUtf8* shaderError = nullptr;
	shaderResult->GetOutput(DXC_OUT_ERRORS, IID_PPV_ARGS(&shaderError), nullptr);
	if (shaderError != nullptr && shaderError->GetStringLength() != 0)
	{
		Logger::Log(shaderError->GetStringPointer());
		//è­¦å‘Šãƒ»ã‚¨ãƒ©ãƒ¼ãƒ€ãƒ¡çµ¶å¯¾
		assert(SUCCEEDED(false));
	}



	//ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«çµæžœã‚’å—ã‘å–ã£ã¦è¿”ã™

	//ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«çµæžœã‹ã‚‰å®Ÿè¡Œç”¨ã®ãƒã‚¤ãƒŠãƒªéƒ¨åˆ†ã‚’å–å¾—
	IDxcBlob* shaderBlob = nullptr;
	result = shaderResult->GetOutput(DXC_OUT_OBJECT, IID_PPV_ARGS(&shaderBlob), nullptr);
	assert(SUCCEEDED(result));
	//æˆåŠŸã—ãŸãƒ­ã‚°ã‚’å‡ºã™
	Logger::Log(StringUtility::ConvertString(std::format(L"Compile Succeeded, path:{}, profile:{}\n", filePath, profile)));
	//ã‚‚ã†ä½¿ã‚ãªã„ãƒªã‚½ãƒ¼ã‚¹ã‚’è§£æ”¾
	shaderSource->Release();
	shaderResult->Release();
	//å®Ÿè¡Œç”¨ã®ãƒã‚¤ãƒŠãƒªã‚’è¿”å´
	return shaderBlob;
}

Microsoft::WRL::ComPtr<ID3D12Resource> DirectXCommon::CreateBufferResource(size_t sizeInBytes)
{
	HRESULT result = S_FALSE;

	Microsoft::WRL::ComPtr<ID3D12Resource> bufferResource = nullptr;
	//é ‚ç‚¹ãƒªã‚½ãƒ¼ã‚¹ç”¨ã®ãƒ’ãƒ¼ãƒ—è¨­å®š
	D3D12_HEAP_PROPERTIES uploadHeapProperties{};
	uploadHeapProperties.Type = D3D12_HEAP_TYPE_UPLOAD;

	//é ‚ç‚¹ãƒªã‚½ãƒ¼ã‚¹ã®è¨­å®š
	D3D12_RESOURCE_DESC bufferResourceDesc{};
	//ãƒãƒƒãƒ•ã‚¡ãƒªã‚½ãƒ¼ã‚¹ã€‚ãƒ†ã‚¯ã‚¹ãƒãƒ£ã®å ´åˆã¯ã¾ãŸåˆ¥ã®è¨­å®šã‚’ã™ã‚‹
	bufferResourceDesc.Dimension = D3D12_RESOURCE_DIMENSION_BUFFER;
	bufferResourceDesc.Width = (sizeInBytes + 255) & ~255;
	//ãƒãƒƒãƒ•ã‚¡ã®å ´åˆã¯ã“ã‚Œã‚‰ã¯ï¼‘ã«ã™ã‚‹æ±ºã¾ã‚Š
	bufferResourceDesc.Height = 1;
	bufferResourceDesc.DepthOrArraySize = 1;
	bufferResourceDesc.MipLevels = 1;
	bufferResourceDesc.SampleDesc.Count = 1;
	//ãƒãƒƒãƒ•ã‚¡ã®å ´åˆã¯ã“ã‚Œã«ã™ã‚‹æ±ºã¾ã‚Š
	bufferResourceDesc.Layout = D3D12_TEXTURE_LAYOUT_ROW_MAJOR;

	result = device_->CreateCommittedResource(&uploadHeapProperties, D3D12_HEAP_FLAG_NONE, &bufferResourceDesc, D3D12_RESOURCE_STATE_GENERIC_READ, nullptr, IID_PPV_ARGS(&bufferResource));
	assert(SUCCEEDED(result));
	result;
	return bufferResource;
}

Microsoft::WRL::ComPtr<ID3D12Resource> DirectXCommon::CreateTextureResource(const DirectX::TexMetadata& metadata)
{
	HRESULT result = S_FALSE;

	D3D12_RESOURCE_DESC resourceDesc{};
	resourceDesc.Width = UINT(metadata.width);									//Textureã®å¹…
	resourceDesc.Height = UINT(metadata.height);								//Textureã®é«˜ã•
	resourceDesc.MipLevels = UINT16(metadata.mipLevels);						//mipmapã®æ•°
	resourceDesc.DepthOrArraySize = UINT16(metadata.arraySize);					//å¥¥è¡Œã or é…åˆ—Textureã®é…åˆ—æ•°
	resourceDesc.Format = metadata.format;										//Textureã®Format
	resourceDesc.SampleDesc.Count = 1;											//ã‚µãƒ³ãƒ—ãƒªãƒ³ã‚°ã‚«ã‚¦ãƒ³ãƒˆã€‚ï¼‘å›ºå®š
	resourceDesc.Dimension = D3D12_RESOURCE_DIMENSION(metadata.dimension);		//Textureã®æ¬¡å…ƒæ•°ã€‚æ™®æ®µä½¿ã£ã¦ã„ã‚‹ã®ã¯ï¼’æ¬¡å…ƒ

	//åˆ©ç”¨ã™ã‚‹Heapã®è¨­å®šã€‚éžå¸¸ã«ç‰¹æ®Šãªé‹ç”¨ã€‚02_04exã§ä¸€èˆ¬çš„ãªã‚±ãƒ¼ã‚¹ç‰ˆãŒã‚ã‚‹
	D3D12_HEAP_PROPERTIES heapProperties{};
	heapProperties.Type = D3D12_HEAP_TYPE_DEFAULT;								//ç´°ã‹ã„è¨­å®šã‚’è¡Œã†

	//resourceã®ç”Ÿæˆ
	Microsoft::WRL::ComPtr<ID3D12Resource> resource = nullptr;
	result = device_->CreateCommittedResource(
		&heapProperties,
		D3D12_HEAP_FLAG_NONE,
		&resourceDesc,
		D3D12_RESOURCE_STATE_COPY_DEST,
		nullptr,
		IID_PPV_ARGS(&resource)
	);
	assert(SUCCEEDED(result));


	return resource;
}

Microsoft::WRL::ComPtr<ID3D12Resource> DirectXCommon::UploadTextureData(Microsoft::WRL::ComPtr<ID3D12Resource> texture, const DirectX::ScratchImage& mipImages)
{
	std::vector<D3D12_SUBRESOURCE_DATA> subresources;
	DirectX::PrepareUpload(device_.Get(), mipImages.GetImages(), mipImages.GetImageCount(), mipImages.GetMetadata(), subresources);
	uint64_t intermediateSize = GetRequiredIntermediateSize(texture.Get(), 0, UINT(subresources.size()));
	Microsoft::WRL::ComPtr<ID3D12Resource> intermediateResource = CreateBufferResource(intermediateSize);
	UpdateSubresources(commandList_.Get(), texture.Get(), intermediateResource.Get(), 0, 0, UINT(subresources.size()), subresources.data());
	//Textureã¸ã®è»¢é€å¾Œã¯åˆ©ç”¨ã§ãã‚‹ã‚ˆã†ã€D3D12_RESOURCE_STATE_COPY_DESTã‹ã‚‰D3D12_RESOURCE_STATE_GENERI_READã¸ResourceStateã‚’å¤‰æ›´ã™ã‚‹
	D3D12_RESOURCE_BARRIER barrier{};
	barrier.Type = D3D12_RESOURCE_BARRIER_TYPE_TRANSITION;
	barrier.Flags = D3D12_RESOURCE_BARRIER_FLAG_NONE;
	barrier.Transition.pResource = texture.Get();
	barrier.Transition.Subresource = D3D12_RESOURCE_BARRIER_ALL_SUBRESOURCES;
	barrier.Transition.StateBefore = D3D12_RESOURCE_STATE_COPY_DEST;
	barrier.Transition.StateAfter = D3D12_RESOURCE_STATE_GENERIC_READ;
	commandList_->ResourceBarrier(1, &barrier);
	return intermediateResource;
}

DirectX::ScratchImage DirectXCommon::LoadTexture(const std::string& filePath)
{
	//ãƒ†ã‚¯ã‚¹ãƒãƒ£ãƒ•ã‚¡ã‚¤ãƒ«ã‚’èª­ã‚“ã§ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã§æ‰±ãˆã‚‹ã‚ˆã†ã«ã™ã‚‹
	DirectX::ScratchImage image{};
	std::wstring filePathW = StringUtility::ConvertString(filePath);
	HRESULT hr;
	if (filePathW.ends_with(L".dds"))
	{
		hr = DirectX::LoadFromDDSFile(filePathW.c_str(), DirectX::DDS_FLAGS_NONE, nullptr, image);
	}
	else
	{
		hr = DirectX::LoadFromWICFile(filePathW.c_str(), DirectX::WIC_FLAGS_FORCE_SRGB, nullptr, image);
		assert(SUCCEEDED(hr));
	}
	
	//ãƒŸãƒƒãƒ—ãƒžãƒƒãƒ—ã®ä½œæˆ
	DirectX::ScratchImage mipImages{};
	if (DirectX::IsCompressed(image.GetMetadata().format))
	{
		//åœ§ç¸®ãƒ†ã‚¯ã‚¹ãƒãƒ£ã®å ´åˆã¯ã€ãƒŸãƒƒãƒ—ãƒžãƒƒãƒ—ã‚’ç”Ÿæˆã—ãªã„
		mipImages = std::move(image);
	} 
	else
	{
		hr = DirectX::GenerateMipMaps(image.GetImages(), image.GetImageCount(), image.GetMetadata(), DirectX::TEX_FILTER_SRGB, 4, mipImages);
		assert(SUCCEEDED(hr));
	}
	
	//ãƒŸãƒƒãƒ—ãƒžãƒƒãƒ—ä»˜ãã®ãƒ‡ãƒ¼ã‚¿ã‚’è¿”ã™
	return mipImages;
}

Microsoft::WRL::ComPtr<ID3D12Resource> DirectXCommon::CreateDepthStencilTextureResource(int32_t width, int32_t height)
{
	HRESULT hr = S_FALSE;

	// ç”Ÿæˆã™ã‚‹Resourceã®è¨­å®š
	D3D12_RESOURCE_DESC resourceDesc{};
	resourceDesc.Width = width;                                   // Textureã®å¹…ã€€
	resourceDesc.Height = height;                                 // Textureã®é«˜ã•
	resourceDesc.MipLevels = 1;                                   // mipMapã®æ•°
	resourceDesc.DepthOrArraySize = 1;                            // å¥¥è¡Œã or é…åˆ—Textureã®é…åˆ—æ•°
	resourceDesc.Format = DXGI_FORMAT_D24_UNORM_S8_UINT;          // DepthStencilã¨ã—ã¦åˆ©ç”¨å¯èƒ½ãªãƒ•ã‚©ãƒ¼ãƒžãƒƒãƒˆ
	resourceDesc.SampleDesc.Count = 1;                            // ã‚µãƒ³ãƒ—ãƒªãƒ³ã‚°ã‚«ã‚¦ãƒ³ãƒˆã€‚1å›ºå®š
	resourceDesc.Dimension = D3D12_RESOURCE_DIMENSION_TEXTURE2D;  // 2æ¬¡å…ƒ
	resourceDesc.Flags = D3D12_RESOURCE_FLAG_ALLOW_DEPTH_STENCIL; // DepthStencilã¨ã—ã¦ä½¿ã†é€šçŸ¥

	// åˆ©ç”¨ã™ã‚‹Heapã®è¨­å®š
	D3D12_HEAP_PROPERTIES heapProperties{};
	heapProperties.Type = D3D12_HEAP_TYPE_DEFAULT; // VRAMä¸Šã«ä½œã‚‹

	// æ·±åº¦å€¤ã®ã‚¯ãƒªã‚¢è¨­å®š
	D3D12_CLEAR_VALUE depthClearValue{};
	depthClearValue.DepthStencil.Depth = 1.0f;              // 1.0f(æœ€å¤§å€¤)ã§ã‚¯ãƒªã‚¢
	depthClearValue.Format = DXGI_FORMAT_D24_UNORM_S8_UINT; // ãƒ•ã‚©ãƒ¼ãƒžãƒƒãƒˆã€‚Resourceã¨åˆã‚ã›ã‚‹

	// Resourceã®ç”Ÿæˆ
	Microsoft::WRL::ComPtr<ID3D12Resource> resource = nullptr;
	hr = device_->CreateCommittedResource(
		&heapProperties,                  // Heapã®è¨­å®š
		D3D12_HEAP_FLAG_NONE,             // Heapã®ç‰¹æ®Šãªè¨­å®š
		&resourceDesc,                    // Resourceè¨­å®š
		D3D12_RESOURCE_STATE_DEPTH_WRITE, // åˆå›žã®ResourceStateã€‚Textureã¯èª­ã‚€ã ã‘
		&depthClearValue,                 // Clearæœ€é©å€¤
		IID_PPV_ARGS(&resource)           // ä½œæˆã™ã‚‹Resourceãƒã‚¤ãƒ³ã‚¿ã¸ã®ãƒã‚¤ãƒ³ã‚¿
	);
	assert(SUCCEEDED(hr));

	return resource;
}

void DirectXCommon::CommandPass()
{
	HRESULT result = S_FALSE;

	//ã‚³ãƒžãƒ³ãƒ‰ãƒªã‚¹ãƒˆã®å†…å®¹ã‚’ç¢ºå®šã•ã›ã‚‹ã€‚ã™ã¹ã¦ã®ã‚³ãƒžãƒ³ãƒ‰ã‚’é ¼ã‚“ã§ã‹ã‚‰Closeã™ã‚‹ã“ã¨
	result = commandList_->Close();
	assert(SUCCEEDED(result));

	//ã‚³ãƒžãƒ³ãƒ‰ã‚’ã‚­ãƒƒã‚¯ã™ã‚‹
	//GPUäºŒã‚³ãƒžãƒ³ãƒ‰ãƒªã‚¹ãƒˆã®å®Ÿè¡Œã‚’è¡Œã‚ã›ã‚‹
	Microsoft::WRL::ComPtr<ID3D12CommandList> commandLists[] = { commandList_ };
	commandQueue_->ExecuteCommandLists(1, commandLists->GetAddressOf());
	//GPUã¨OSã«ç”»é¢ã®äº¤æ›ã‚’è¡Œã†ã‚ˆã†ã«é€šçŸ¥ã™ã‚‹
	swapChain_->Present(1, 0);



	//Fenceã®å€¤ã‚’æ›´æ–°
	fenceValue_++;
	//GPUãŒã“ã“ã¾ã§ãŸã©ã‚Šç€ã„ãŸã¨ãã«ã€Fenceã®å€¤ã‚’æŒ‡å®šã—ãŸå€¤ã‚’ä»£å…¥ã™ã‚‹ã‚ˆã†ã«Signalã‚’é€ã‚‹
	commandQueue_->Signal(fence_.Get(), fenceValue_);
	//Fenceã®å€¤ãŒæŒ‡å®šã—ãŸSignalå€¤ã«ãŸã©ã‚Šç€ã„ã¦ã„ã‚‹ã‹ç¢ºèªã™ã‚‹
	//GetCompleteValueã®åˆæœŸå€¤ã¯Fenceåˆ¶ä½œæ™‚ã«æ¸¡ã—ãŸåˆæœŸå€¤
	if (fence_->GetCompletedValue() < fenceValue_)
	{
		//æŒ‡å®šã—ãŸSignalã«ãŸã©ã‚Šç€ã„ã¦ã„ãªã„ã®ã§ã€ãŸã©ã‚Šç€ãã¾ã§å¾…ã¤ã‚ˆã†ã«ã‚¤ãƒ™ãƒ³ãƒˆã‚’è¨­å®šã™ã‚‹
		fence_->SetEventOnCompletion(fenceValue_, fenceEvent_);
		//ã‚¤ãƒ™ãƒ³ãƒˆã‚’å¾…ã¤
		WaitForSingleObject(fenceEvent_, INFINITE);
	}

	//æ¬¡ãƒ•ãƒ¬ãƒ¼ãƒ ç”¨ã®ã‚³ãƒžãƒ³ãƒ‰ãƒªã‚¹ãƒˆã‚’æº–å‚™
	result = commandAllocator_->Reset();
	assert(SUCCEEDED(result));
	result = commandList_->Reset(commandAllocator_.Get(), nullptr);
	assert(SUCCEEDED(result));
}

void DirectXCommon::CreateSamplerHeap()
{
	D3D12_DESCRIPTOR_HEAP_DESC desc{};
	desc.Type = D3D12_DESCRIPTOR_HEAP_TYPE_SAMPLER;
	desc.NumDescriptors = 1;
	desc.Flags = D3D12_DESCRIPTOR_HEAP_FLAG_SHADER_VISIBLE;
	HRESULT hr = device_->CreateDescriptorHeap(&desc, IID_PPV_ARGS(&samplerHeap_));
	assert(SUCCEEDED(hr) && "Failed to create Sampler Heap!");
	hr;

	// ãƒ‡ãƒãƒƒã‚°ãƒ­ã‚°
	D3D12_GPU_DESCRIPTOR_HANDLE samplerHeapBase = samplerHeap_->GetGPUDescriptorHandleForHeapStart();
	OutputDebugStringA(("Sampler Heap Base Address: " + std::to_string(samplerHeapBase.ptr) + "\n").c_str());
	assert(samplerHeap_ != nullptr && "Sampler Descriptor Heap is null!");

	D3D12_SAMPLER_DESC samplerDesc{};
	samplerDesc.Filter = D3D12_FILTER_MIN_MAG_MIP_LINEAR;
	samplerDesc.AddressU = D3D12_TEXTURE_ADDRESS_MODE_CLAMP;
	samplerDesc.AddressV = D3D12_TEXTURE_ADDRESS_MODE_CLAMP;
	samplerDesc.AddressW = D3D12_TEXTURE_ADDRESS_MODE_CLAMP;
	samplerDesc.MinLOD = 0;
	samplerDesc.MaxLOD = D3D12_FLOAT32_MAX;
	samplerDesc.MipLODBias = 0.0f;
	samplerDesc.MaxAnisotropy = 1;
	samplerDesc.ComparisonFunc = D3D12_COMPARISON_FUNC_ALWAYS;

	device_->CreateSampler(&samplerDesc, samplerHeap_->GetCPUDescriptorHandleForHeapStart());
}

Microsoft::WRL::ComPtr<ID3D12Resource> DirectXCommon::CreateUploadBuffer(size_t sizeInBytes)
{
	D3D12_HEAP_PROPERTIES heapProperties = {};
	heapProperties.Type = D3D12_HEAP_TYPE_UPLOAD;
	heapProperties.CPUPageProperty = D3D12_CPU_PAGE_PROPERTY_UNKNOWN;
	heapProperties.MemoryPoolPreference = D3D12_MEMORY_POOL_UNKNOWN;

	D3D12_RESOURCE_DESC resourceDesc = {};
	resourceDesc.Dimension = D3D12_RESOURCE_DIMENSION_BUFFER;
	resourceDesc.Alignment = 0;
	resourceDesc.Width = sizeInBytes;
	resourceDesc.Height = 1;
	resourceDesc.DepthOrArraySize = 1;
	resourceDesc.MipLevels = 1;
	resourceDesc.Format = DXGI_FORMAT_UNKNOWN;
	resourceDesc.SampleDesc.Count = 1;
	resourceDesc.Layout = D3D12_TEXTURE_LAYOUT_ROW_MAJOR;
	resourceDesc.Flags = D3D12_RESOURCE_FLAG_NONE;

	Microsoft::WRL::ComPtr<ID3D12Resource> buffer;
	HRESULT hr = device_->CreateCommittedResource(
		&heapProperties,
		D3D12_HEAP_FLAG_NONE,
		&resourceDesc,
		D3D12_RESOURCE_STATE_GENERIC_READ,
		nullptr,
		IID_PPV_ARGS(&buffer));

	if (FAILED(hr)) {
		Logger::Log("Failed to create upload buffer!");
		return nullptr;
	}

	return buffer;
}

void DirectXCommon::InitializeFixFPS()
{
	// ç¾åœ¨æ™‚é–“ã‚’è¨˜éŒ²ã™ã‚‹
	reference_ = std::chrono::steady_clock::now();
}

void DirectXCommon::UpdateFixFPS()
{
	// 1/60ç§’ãƒ”ãƒƒã‚¿ãƒªã®æ™‚é–“
	const std::chrono::microseconds kMinTime(uint64_t(1000000.0f / 60.0f));
	// 1/60ç§’ã‚ˆã‚Šã‚ãšã‹ã«çŸ­ã„æ™‚é–“
	const std::chrono::microseconds kMinCheckTime(uint64_t(1000000.0f / 65.0f));

	// ç¾åœ¨æ™‚é–“ã‚’å–å¾—ã™ã‚‹
	std::chrono::steady_clock::time_point now = std::chrono::steady_clock::now();
	// å‰å›žæ™‚é–“ã‹ã‚‰ã®çµŒéŽæ™‚é–“ã‚’å–å¾—ã™ã‚‹
	std::chrono::microseconds elapsed = std::chrono::duration_cast<std::chrono::microseconds>(now - reference_);

	// 1/60ç§’ï¼ˆã‚ˆã‚Šã‚ãšã‹ã«çŸ­ã„æ™‚é–“ï¼‰çµŒã£ã¦ã„ãªã„å ´åˆ
	if (elapsed < kMinCheckTime)
	{
		// 1/60çµŒéŽã™ã‚‹ã¾ã§å¾®å°ãªã‚¹ãƒªãƒ¼ãƒ—ã‚’ç¹°ã‚Šè¿”ã™
		while (std::chrono::steady_clock::now() - reference_ < kMinTime)
		{
			// 1ãƒžã‚¤ã‚¯ãƒ­ç§’ã‚¹ãƒªãƒ¼ãƒ—
			std::this_thread::sleep_for(std::chrono::microseconds(1));
		}
	}
	// ç¾åœ¨ã®æ™‚é–“ã‚’è¨˜éŒ²
	reference_ = std::chrono::steady_clock::now();
}


============================================================
File Path: project/gameEngine/base/DirectXCommon.h
============================================================

#pragma once
#include <d3d12.h>
#include <dxgi1_6.h>
#include <wrl.h>
#include <vector>
#include <array>
#include <format>
#include <chrono>

#include "../../externals/DirectXTex/DirectXTex.h"
#include "../../externals/DirectXTex/d3dx12.h"

#include <dxcapi.h>
#pragma comment(lib,"dxcompiler.lib")

//DirectX12
#include <dxgidebug.h>
#pragma comment(lib,"dxguid.lib")

#include "WinApp.h"
#include "StringUtility.h"
#include "Logger.h"

/// <summary>
/// DirectXå…±é€šæ©Ÿèƒ½
/// </summary>
class DirectXCommon
{
public:

	// æœ€å¤§SRVæ•°ï¼ˆæœ€å¤§ãƒ†ã‚¯ã‚¹ãƒãƒ£æžšæ•°ï¼‰
	static const uint32_t kMaxSRVCount;

	// åˆæœŸåŒ–
	void Initialize(WinApp* winApp);

	void ReportLiveObjects();
	void Finalize();

	/// <summary>
	/// ãƒ‡ãƒã‚¤ã‚¹ã®åˆæœŸåŒ–
	/// </summary>
	void InitializeDevice();

	/// <summary>
	/// ã‚³ãƒžãƒ³ãƒ‰é–¢é€£åˆæœŸåŒ–
	/// </summary>
	void InitializeCommand();

	/// <summary>
	/// ã‚¹ãƒ¯ãƒƒãƒ—ãƒã‚§ãƒ¼ãƒ³ã®ç”Ÿæˆ
	/// </summary>
	void CreateSwapChain();

	/// <summary>
	/// æ·±åº¦ãƒãƒƒãƒ•ã‚¡ç”Ÿæˆ
	/// </summary>
	void CreateDepthBuffer();

	/// <summary>
	/// å„ç¨®ãƒ‡ã‚¹ã‚¯ãƒªãƒ—ã‚¿ãƒ’ãƒ¼ãƒ—ã®ç”Ÿæˆ
	/// </summary>
	void CreateDescriptorHeap();

	/// <summary>
	/// ãƒ‡ã‚¹ã‚¯ãƒªãƒ—ã‚¿ãƒ’ãƒ¼ãƒ—ã‚’ç”Ÿæˆã™ã‚‹
	/// </summary>
	/// <param name="heapType">ãƒ’ãƒ¼ãƒ—ã‚¿ã‚¤ãƒ—</param>
	/// <param name="numDescriptor">ãƒ‡ã‚¹ã‚¯ãƒªãƒ—ã‚¿æ•°</param>
	/// <param name="shaderVisible">ã‚·ã‚§ãƒ¼ãƒ€ãƒ¼ã‹ã‚‰è¦‹ãˆã‚‹ã‹</param>
	/// <returns>ãƒ‡ã‚¹ã‚¯ãƒªãƒ—ã‚¿ãƒ’ãƒ¼ãƒ—</returns>
	Microsoft::WRL::ComPtr<ID3D12DescriptorHeap> CreateDescriptorHeap(D3D12_DESCRIPTOR_HEAP_TYPE heapType, UINT numDescriptor, bool shaderVisible);

	/// <summary>
	/// ãƒ¬ãƒ³ãƒ€ãƒ¼ã‚¿ãƒ¼ã‚²ãƒƒãƒˆåˆæœŸåŒ–
	/// </summary>
	void InitializeFinalRenderTargets();

	/// <summary>
	/// CPUã®DescriptorHandleã‚’å–å¾—
	/// </summary>
	/// <param name="descriptorHeap">ãƒ‡ã‚¹ã‚¯ãƒªãƒ—ã‚¿ãƒ’ãƒ¼ãƒ—</param>
	/// <param name="descriptorSize">ãƒ‡ã‚¹ã‚¯ãƒªãƒ—ã‚¿ã‚µã‚¤ã‚º</param>
	/// <param name="index">ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹</param>
	/// <returns>CPUã®ãƒ‡ã‚¹ã‚¯ãƒªãƒ—ã‚¿ãƒãƒ³ãƒ‰ãƒ«</returns>
	/// <returns> ã‚ªãƒ•ã‚»ãƒƒãƒˆã•ã‚ŒãŸCPUãƒ‡ã‚¹ã‚¯ãƒªãƒ—ã‚¿ãƒãƒ³ãƒ‰ãƒ«</returns>
	D3D12_CPU_DESCRIPTOR_HANDLE GetCPUDescriptorHandle(Microsoft::WRL::ComPtr<ID3D12DescriptorHeap> descriptorHeap, uint32_t descriptorSize, uint32_t index);

	/// <summary>
	/// GPUã®DescriptorHandleã‚’å–å¾—
	/// </summary>
	/// <param name="descriptorHeap">ãƒ‡ã‚¹ã‚¯ãƒªãƒ—ã‚¿ãƒ’ãƒ¼ãƒ—</param>
	/// <param name="descriptorSize">ãƒ‡ã‚¹ã‚¯ãƒªãƒ—ã‚¿ã‚µã‚¤ã‚º</param>
	/// <param name="index">ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹</param>
	/// <returns>GPUã®ãƒ‡ã‚¹ã‚¯ãƒªãƒ—ã‚¿ãƒãƒ³ãƒ‰ãƒ«</returns>
	D3D12_GPU_DESCRIPTOR_HANDLE GetGPUDescriptorHandle(Microsoft::WRL::ComPtr<ID3D12DescriptorHeap> descriptorHeap, uint32_t descriptorSize, uint32_t index);

	/// <summary>
	/// SRVã®æŒ‡å®šç•ªå·ã®CPUãƒ‡ã‚¹ã‚¯ãƒªãƒ—ã‚¿ãƒãƒ³ãƒ‰ãƒ«ã‚’å–å¾—ã™ã‚‹
	/// </summary>
	/// <param name="index">SRVç•ªå·</param>
	/// <returns>CPUã®ãƒ‡ã‚¹ã‚¯ãƒªãƒ—ã‚¿ãƒãƒ³ãƒ‰ãƒ«</returns>
	D3D12_CPU_DESCRIPTOR_HANDLE GetSRVCPUDescriptorHandle(uint32_t index);

	/// <summary>
	/// SRVã®æŒ‡å®šç•ªå·ã®GPUãƒ‡ã‚¹ã‚¯ãƒªãƒ—ã‚¿ãƒãƒ³ãƒ‰ãƒ«ã‚’å–å¾—ã™ã‚‹
	/// </summary>
	/// <param name="index">SRVç•ªå·</param>
	/// <returns>GPUã®ãƒ‡ã‚¹ã‚¯ãƒªãƒ—ã‚¿ãƒãƒ³ãƒ‰ãƒ«</returns>
	D3D12_GPU_DESCRIPTOR_HANDLE GetSRVGPUDescriptorHandle(uint32_t index);

	/// <summary>
	/// æ·±åº¦ã‚¹ãƒ†ãƒ³ã‚·ãƒ«ãƒ“ãƒ¥ãƒ¼ã®åˆæœŸåŒ–
	/// </summary>
	void InitializeDepthStencilView();

	/// <summary>
	/// ãƒ•ã‚§ãƒ³ã‚¹ç”Ÿæˆ
	/// </summary>
	void CreateFence();

	/// <summary>
	/// ãƒ“ãƒ¥ãƒ¼ãƒãƒ¼ãƒˆçŸ©å½¢ã®åˆæœŸåŒ–
	/// </summary>
	void InitializeViewPort();

	/// <summary>
	/// ã‚·ã‚¶ãƒªãƒ³ã‚°çŸ©å½¢ã®è¨­å®š
	/// </summary>
	void InitializeScissor();

	/// <summary>
	/// DXCã‚³ãƒ³ãƒ‘ã‚¤ãƒ©ã®ç”Ÿæˆ
	/// </summary>
	void CreateDXCompiler();

	/// <summary>
	/// ImGuiã®åˆæœŸåŒ–
	/// </summary>
	void InitializeImGui();

	/// <summary>
	/// æç”»å‰å‡¦ç†
	/// </summary>
	void PreDraw();

	/// <summary>
	/// æç”»å¾Œå‡¦ç†
	/// </summary>
	void PostDraw();

	/// <summary>
	/// ã‚·ã‚§ãƒ¼ãƒ€ãƒ¼ã®ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«
	/// </summary>
	/// <param name="filePath">ãƒ•ã‚¡ã‚¤ãƒ«ãƒ‘ã‚¹</param>
	/// <param name="profile">ãƒ—ãƒ­ãƒ•ã‚¡ã‚¤ãƒ«</param>
	/// <returns>ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«æ¸ˆã¿ã‚·ã‚§ãƒ¼ãƒ€ãƒ¼ãƒ–ãƒ­ãƒ–</returns>
	Microsoft::WRL::ComPtr<IDxcBlob> CompileShader(const std::wstring& filePath, const wchar_t* profile);

	/// <summary>
	/// ãƒãƒƒãƒ•ã‚¡ãƒªã‚½ãƒ¼ã‚¹ã®ç”Ÿæˆ
	/// </summary>
	/// <param name="sizeInBytes">ã‚µã‚¤ã‚º(ãƒã‚¤ãƒˆå˜ä½)</param>
	/// <returns>ãƒãƒƒãƒ•ã‚¡ãƒªã‚½ãƒ¼ã‚¹</returns>
	Microsoft::WRL::ComPtr<ID3D12Resource> CreateBufferResource(size_t sizeInBytes);

	/// <summary>
	/// ãƒ†ã‚¯ã‚¹ãƒãƒ£ãƒªã‚½ãƒ¼ã‚¹ã®ç”Ÿæˆ
	/// </summary>
	/// <param name="metadata">ãƒ†ã‚¯ã‚¹ãƒãƒ£ãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿</param>
	/// <returns>ãƒ†ã‚¯ã‚¹ãƒãƒ£ãƒªã‚½ãƒ¼ã‚¹</returns>
	Microsoft::WRL::ComPtr<ID3D12Resource> CreateTextureResource(const DirectX::TexMetadata& metadata);

	/// <summary>
	/// ãƒ†ã‚¯ã‚¹ãƒãƒ£ãƒ‡ãƒ¼ã‚¿ã®è»¢é€
	/// </summary>
	/// <param name="texture">ãƒ†ã‚¯ã‚¹ãƒãƒ£ãƒªã‚½ãƒ¼ã‚¹</param>
	/// <param name="mipImages">ãƒŸãƒƒãƒ—ã‚¤ãƒ¡ãƒ¼ã‚¸ç¾¤</param>
	/// <returns>ãƒ†ã‚¯ã‚¹ãƒãƒ£ãƒªã‚½ãƒ¼ã‚¹</returns>
	Microsoft::WRL::ComPtr<ID3D12Resource> UploadTextureData(Microsoft::WRL::ComPtr<ID3D12Resource> texture, const DirectX::ScratchImage& mipImages);

	/// <summary>
	/// ãƒ†ã‚¯ã‚¹ãƒãƒ£ãƒ•ã‚¡ã‚¤ãƒ«ã®èª­ã¿è¾¼ã¿
	/// </summary>
	/// <param name="filePath">ãƒ•ã‚¡ã‚¤ãƒ«ãƒ‘ã‚¹</param>
	/// <returns>ãƒ†ã‚¯ã‚¹ãƒãƒ£ãƒ‡ãƒ¼ã‚¿ç¾¤</returns>
	static DirectX::ScratchImage LoadTexture(const std::string& filePath);

	/// <summary>
	/// DepthStencilTextureã‚’ä½œã‚‹
	/// </summary>
	/// <param name="width">å¹…</param>
	/// <param name="height">é«˜ã•</param>
	/// <returns>æ·±åº¦ã‚¹ãƒ†ãƒ³ã‚·ãƒ«ãƒ†ã‚¯ã‚¹ãƒãƒ£ãƒªã‚½ãƒ¼ã‚¹</returns>
	Microsoft::WRL::ComPtr<ID3D12Resource> CreateDepthStencilTextureResource(int32_t width, int32_t height);

	/// <summary>
	/// ã‚³ãƒžãƒ³ãƒ‰ã®å®Ÿè¡Œ
	/// </summary>
	void CommandPass();

	/// <summary>
	/// Samplerç”¨ãƒ‡ã‚£ã‚¹ã‚¯ãƒªãƒ—ã‚¿ãƒ’ãƒ¼ãƒ—ã®ç”Ÿæˆ
	/// </summary>
	void CreateSamplerHeap();

	/// <summary>
	/// ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰ãƒãƒƒãƒ•ã‚¡ã®ç”Ÿæˆ
	/// </summary>
	/// <param name="sizeInBytes">ã‚µã‚¤ã‚º(ãƒã‚¤ãƒˆå˜ä½)</param>
	/// <returns>ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰ãƒãƒƒãƒ•ã‚¡ãƒªã‚½ãƒ¼ã‚¹</returns>
	Microsoft::WRL::ComPtr<ID3D12Resource> CreateUploadBuffer(size_t sizeInBytes);

public: // ã‚²ãƒƒã‚¿ãƒ¼

	// ãƒ‡ãƒã‚¤ã‚¹
	Microsoft::WRL::ComPtr<ID3D12Device> GetDevice() { return device_; }
	// ã‚³ãƒžãƒ³ãƒ‰ã‚¢ãƒ­ã‚±ãƒ¼ã‚¿
	Microsoft::WRL::ComPtr<ID3D12CommandAllocator> GetCommandAllocator() { return commandAllocator_; }
	// ã‚³ãƒžãƒ³ãƒ‰ãƒªã‚¹ãƒˆ
	Microsoft::WRL::ComPtr<ID3D12GraphicsCommandList> GetCommandList() { return commandList_; }
	// DescriptorHeap
	Microsoft::WRL::ComPtr<ID3D12DescriptorHeap> GetSrvDescriptorHeap() { return srvDescriptorHeap_; }
	// descriptorSizeSRV
	uint32_t GetDescriptorSizeSRV() { return descriptorSizeSRV_; }
	// ãƒ“ãƒ¥ãƒ¼ãƒãƒ¼ãƒˆ
	D3D12_VIEWPORT GetViewport() { return viewport_; }
	// ã‚·ã‚¶ãƒ¼çŸ©å½¢
	D3D12_RECT GetScissorRect() { return scissorRect_; }
	// ãƒãƒƒã‚¯ãƒãƒƒãƒ•ã‚¡ã®æ•°ã‚’å–å¾—
	size_t GetBackBufferCount() const { return backBuffers_.size(); }
	// swapChainDescã‚’å–å¾—
	DXGI_SWAP_CHAIN_DESC1 GetSwapChainDesc() { return swapChainDesc_; }
	// DSVç”¨ãƒ‡ã‚£ã‚¹ã‚¯ãƒªãƒ—ã‚¿ãƒ’ãƒ¼ãƒ—ã‚’å–å¾—ã™ã‚‹é–¢æ•°
	D3D12_CPU_DESCRIPTOR_HANDLE GetDSVHandle() { return dsvDescriptorHeap_->GetCPUDescriptorHandleForHeapStart(); }
	// descriptorSizeDSVã‚’å–å¾—
	size_t GetDescriptorSizeRTV() { return descriptorSizeRTV_; }
	
	// Samplerç”¨ãƒ‡ã‚£ã‚¹ã‚¯ãƒªãƒ—ã‚¿ãƒ’ãƒ¼ãƒ—ã‚’å–å¾—ã™ã‚‹é–¢æ•°
	Microsoft::WRL::ComPtr<ID3D12DescriptorHeap> GetSamplerHeap() const { return samplerHeap_; }
	
	// Samplerç”¨ãƒ‡ã‚£ã‚¹ã‚¯ãƒªãƒ—ã‚¿ãƒ’ãƒ¼ãƒ—ã®ã‚µã‚¤ã‚ºã‚’å–å¾—ã™ã‚‹é–¢æ•°
	D3D12_GPU_DESCRIPTOR_HANDLE GetSamplerHandle() const
	{
		assert(samplerHeap_ != nullptr && "Sampler Heap is not initialized!");
		return samplerHeap_->GetGPUDescriptorHandleForHeapStart();
	}

	// DXC Utilsã‚’å–å¾—
	D3D12_CPU_DESCRIPTOR_HANDLE GetCurrentRTVHandle()  const 
	{
		UINT index = static_cast<UINT>(swapChain_->GetCurrentBackBufferIndex());
		return rtvHandles_[index];
	}

private:

	// FPSå›ºå®šåˆæœŸåŒ–
	void InitializeFixFPS();

	// FPSå›ºå®šæ›´æ–°
	void UpdateFixFPS();

private:

	// WindowsAPI
	WinApp* winApp_ = nullptr;

	// DirectX12ãƒ‡ãƒã‚¤ã‚¹
	Microsoft::WRL::ComPtr<ID3D12Device> device_ = nullptr;
	// DXGIãƒ•ã‚¡ã‚¯ãƒˆãƒª
	Microsoft::WRL::ComPtr<IDXGIFactory7> dxgiFactory_ = nullptr;


	// ã‚³ãƒžãƒ³ãƒ‰ã‚¢ãƒ­ã‚±ãƒ¼ã‚¿
	Microsoft::WRL::ComPtr<ID3D12CommandAllocator> commandAllocator_ = nullptr;
	// ã‚³ãƒžãƒ³ãƒ‰ãƒªã‚¹ãƒˆ
	Microsoft::WRL::ComPtr<ID3D12GraphicsCommandList> commandList_ = nullptr;
	// ã‚³ãƒžãƒ³ãƒ‰ã‚­ãƒ¥ãƒ¼
	Microsoft::WRL::ComPtr<ID3D12CommandQueue> commandQueue_ = nullptr;
	// ã‚¹ãƒ¯ãƒƒãƒ—ãƒã‚§ã‚¤ãƒ³
	Microsoft::WRL::ComPtr<IDXGISwapChain4> swapChain_ = nullptr;
	// ãƒ‡ã‚¹ã‚¯ãƒªãƒ—ã‚¿ãƒ’ãƒ¼ãƒ—
	//Microsoft::WRL::ComPtr<ID3D12DescriptorHeap> descriptorHeap_ = nullptr;
	// resourceã®ç”Ÿæˆ
	Microsoft::WRL::ComPtr<ID3D12Resource> resource_ = nullptr;
	// ã‚¹ãƒ¯ãƒƒãƒ—ãƒã‚§ã‚¤ãƒ³
	DXGI_SWAP_CHAIN_DESC1 swapChainDesc_{};
	// RTV
	D3D12_RENDER_TARGET_VIEW_DESC rtvDesc_{};
	// ãƒãƒªã‚¢
	D3D12_RESOURCE_BARRIER barrier_{};

	D3D12_CPU_DESCRIPTOR_HANDLE dsvHandle_;

	HANDLE fenceEvent_ = nullptr;

	uint32_t descriptorSizeSRV_ = 0;
	uint32_t descriptorSizeRTV_ = 0;
	uint32_t descriptorSizeDSV_ = 0;

	Microsoft::WRL::ComPtr<ID3D12DescriptorHeap> rtvDescriptorHeap_ = nullptr;
	Microsoft::WRL::ComPtr<ID3D12DescriptorHeap> srvDescriptorHeap_ = nullptr;
	Microsoft::WRL::ComPtr<ID3D12DescriptorHeap> dsvDescriptorHeap_ = nullptr;
	// Samplerç”¨ãƒ‡ã‚£ã‚¹ã‚¯ãƒªãƒ—ã‚¿ãƒ’ãƒ¼ãƒ—
	ID3D12DescriptorHeap* samplerHeap_ = nullptr;

	std::vector<Microsoft::WRL::ComPtr<ID3D12Resource>> backBuffers_;

	// RTVã‚’2ã¤ä½œã‚‹ã®ã§ãƒ‡ã‚£ã‚¹ã‚¯ãƒªãƒ—ã‚¿ã‚’ï¼’ã¤ç”¨æ„
	D3D12_CPU_DESCRIPTOR_HANDLE rtvHandles_[2]{};

	// ã‚¹ãƒ¯ãƒƒãƒ—ãƒã‚§ãƒ¼ãƒ³ãƒªã‚½ãƒ¼ã‚¹
	std::array<Microsoft::WRL::ComPtr<ID3D12Resource>, 2> swapChainResources_;

	Microsoft::WRL::ComPtr<ID3D12Fence> fence_ = nullptr;
	uint64_t fenceValue_ = 0;

	// DXC
	IDxcUtils* dxcUtils_ = nullptr;
	IDxcCompiler3* dxcCompiler_ = nullptr;
	IDxcIncludeHandler* includeHandler_ = nullptr;

	// ãƒ“ãƒ¥ãƒ¼ãƒãƒ¼ãƒˆ
	D3D12_VIEWPORT viewport_{};
	// ã‚·ã‚¶ãƒ¼çŸ©å½¢
	D3D12_RECT scissorRect_{};

	// è¨˜éŒ²æ™‚é–“ï¼ˆFPSå›ºå®šï¼‰
	std::chrono::steady_clock::time_point reference_;


};


============================================================
File Path: project/gameEngine/base/Framework.cpp
============================================================
#include "Framework.h"

void Framework::Run()
{
	Initialize();

	while (true)
	{
		// çµ‚äº†ãƒªã‚¯ã‚¨ã‚¹ãƒˆãŒæ¥ãŸã‚‰æŠœã‘ã‚‹
		if (IsEndRequest())
		{
			break;
		}

		// æ™‚é–“ç®¡ç†
		TimeManager::Instance().Tick();

#ifdef USE_IMGUI
		// ImGuié–‹å§‹
		imGuiManager->Begin();

#endif // USE_IMGUI

		// æ¯Žãƒ•ãƒ¬ãƒ¼ãƒ æ›´æ–°
		Update();

#ifdef USE_IMGUI
		// ImGuiçµ‚äº†
		imGuiManager->End();
#endif // USE_IMGUI

		// æç”»
		Draw();
	}

	// ã‚²ãƒ¼ãƒ ã®çµ‚äº†
	Finalize();

}

void Framework::Initialize()
{
	// WindowsAPIã®åˆæœŸåŒ–
	winApp = std::make_unique<WinApp>();
	winApp->Initialize();

	// DirectXã®åˆæœŸåŒ–
	dxCommon = std::make_unique<DirectXCommon>();
	dxCommon->Initialize(winApp.get());

	// SRVãƒžãƒãƒ¼ã‚¸ãƒ£ãƒ¼ã®åˆæœŸåŒ–
	srvManager = std::make_unique<SrvManager>();
	srvManager->Initialize(dxCommon.get());

	modelCommon = std::make_unique<ModelCommon>();
	modelCommon->Initialize(dxCommon.get());

	// ã‚­ãƒ¼ãƒœãƒ¼ãƒ‰å…¥åŠ›
	input = Input::GetInstance();
	input->Initialize(winApp.get());

	// ã‚ªãƒ¼ãƒ‡ã‚£ã‚ª
	audio = Audio::GetInstance();
	audio->Initialize();

	// ã‚·ãƒ¼ãƒ³ãƒžãƒãƒ¼ã‚¸ãƒ£
	sceneManager_ = SceneManager::GetInstance();

	// ã‚¹ãƒ—ãƒ©ã‚¤ãƒˆå…±é€šéƒ¨åˆ†ã®åˆæœŸåŒ–
	spriteCommon = SpriteCommon::GetInstance();
	spriteCommon->Initialize(dxCommon.get());

	// ãƒ†ã‚¯ã‚¹ãƒãƒ£ãƒžãƒãƒ¼ã‚¸ãƒ£ãƒ¼
	textureManager = TextureManager::GetInstance();
	textureManager->Initialize(dxCommon.get(), srvManager.get());

	// 3Dã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ
	object3dCommon = Object3dCommon::GetInstance();
	object3dCommon->Initialize(dxCommon.get());

	// ãƒ¢ãƒ‡ãƒ«å…±é€šéƒ¨åˆ†ã®åˆæœŸåŒ–
	modelManager = ModelManager::GetInstance();
	modelManager->Initialize(dxCommon.get());

	// ãƒ¬ãƒ³ãƒ€ãƒ¼ãƒ†ã‚¯ã‚¹ãƒãƒ£
	renderTexture = std::make_unique<RenderTexture>();
	renderTexture->Initialize(dxCommon.get(), srvManager.get(), WinApp::kClientWidth, WinApp::kClientHeight, DXGI_FORMAT_R8G8B8A8_UNORM_SRGB, Vector4(0.1f, 0.25f, 0.5f, 1.0f));

	// ãƒã‚¹ãƒˆã‚¨ãƒ•ã‚§ã‚¯ãƒˆ
	noneEffectPass = std::make_unique<NoneEffectPass>();
	noneEffectPass->Initialize(dxCommon.get(), srvManager.get(), L"resources/shaders/NoneEffect.VS.hlsl", L"resources/shaders/NoneEffect.PS.hlsl");
	grayscalePass = std::make_unique<GrayscalePass>();
	grayscalePass->Initialize(dxCommon.get(), srvManager.get(), L"resources/shaders/Grayscale.VS.hlsl", L"resources/shaders/Grayscale.PS.hlsl");
	vignettePass = std::make_unique<VignettePass>();
	vignettePass->Initialize(dxCommon.get(), srvManager.get(), L"resources/shaders/Vignette.VS.hlsl", L"resources/shaders/Vignette.PS.hlsl");
	boxFilterPass = std::make_unique<BoxFilterPass>();
	boxFilterPass->Initialize(dxCommon.get(), srvManager.get(), L"resources/shaders/BoxFilter.VS.hlsl", L"resources/shaders/BoxFilter.PS.hlsl");
	gaussianFilterPass = std::make_unique<GaussianFilterPass>();
	gaussianFilterPass->Initialize(dxCommon.get(), srvManager.get(), L"resources/shaders/GaussianFilter.VS.hlsl", L"resources/shaders/GaussianFilter.PS.hlsl");

	postEffectManager = PostEffectManager::GetInstance();
	postEffectManager->SetNoneEffect(std::move(noneEffectPass));
	postEffectManager->AddPass("Grayscale", std::move(grayscalePass));
	postEffectManager->AddPass("Vignette", std::move(vignettePass));
	postEffectManager->AddPass("BoxFilter", std::move(boxFilterPass));
	postEffectManager->AddPass("GaussianFilter", std::move(gaussianFilterPass));
	

	// ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«	
	particleManager = ParticleManager::GetInstance();
	particleManager->Initialize(dxCommon.get(),srvManager.get(),modelCommon.get());

	inputSrv = renderTexture->GetSRVHandle();
	inputRes = renderTexture->GetResource();
	state = renderTexture->GetCurrentState();

	// Skybox
	skybox = std::make_unique<Skybox>();
	skybox->Initialize(dxCommon.get(), srvManager.get());

#ifdef USE_IMGUI

	imGuiManager = std::make_unique<ImGuiManager>();
	imGuiManager->Initialize(winApp.get(), dxCommon.get());

#endif // USE_IMGUI
		
}

void Framework::Finalize()
{
	// WindowsAPIã®çµ‚äº†å‡¦ç†
	winApp->Finalize();
	// WindowsAPIè§£æ”¾
	winApp.reset();
	winApp = nullptr;

	// DirectXè§£æ”¾
	dxCommon.reset();

	// SRVãƒžãƒãƒ¼ã‚¸ãƒ£ãƒ¼è§£æ”¾
	srvManager.reset();

	sceneManager_->Finalize();
	sceneFactory_.reset();

	input->Finalize();

	audio->Finalize();

	// ã‚¹ãƒ—ãƒ©ã‚¤ãƒˆå…±é€šéƒ¨åˆ†è§£æ”¾
	spriteCommon->Finalize();

	textureManager->Finalize();

	object3dCommon->Finalize();

	modelManager->Finalize();

	// ãƒ¬ãƒ³ãƒ€ãƒ¼ãƒ†ã‚¯ã‚¹ãƒãƒ£è§£æ”¾
	renderTexture.reset();
	renderTexture = nullptr;
	


	particleManager->Finalize();

	// skyboxè§£æ”¾
	skybox->Finalize();

#ifdef USE_IMGUI
	// ImGuiManagerè§£æ”¾
	imGuiManager->Finalize();
	imGuiManager.reset();
#endif // USE_IMGUI
}

void Framework::Update()
{
	// ã‚·ãƒ¼ãƒ³ãƒžãƒãƒ¼ã‚¸ãƒ£ãƒ¼ã®æ›´æ–°
	sceneManager_->Update();
	
	// å…¥åŠ›æ›´æ–°
	input->Update();

	// ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«æ›´æ–°
	particleManager->Update();
}


============================================================
File Path: project/gameEngine/base/Framework.h
============================================================
#pragma once

#include <Windows.h>
#include <format>
#include <cassert>
#include <numbers>
#include <vector>
#include <DirectXMath.h>
#include <fstream>
#include <sstream>
#include <iostream>
#include <memory>

#include "Input.h"
#include "WinApp.h"
#include "DirectXCommon.h"
#include "SpriteCommon.h"
#include "Sprite.h"
#include "MyMath.h"
#include "TextureManager.h"
#include "Object3dCommon.h"
#include "Object3d.h"
#include "ModelCommon.h"
#include "Model.h"
#include "ModelManager.h"
#include "SrvManager.h"
#include "Audio.h"
#include "RenderTexture.h"
#include "TimeManager.h"

#include "postEffect/PostEffectManager.h"
#include "postEffect/NoneEffectPass.h"
#include "postEffect/GrayscalePass.h"
#include "postEffect/VignettePass.h"
#include "postEffect/BoxFilterPass.h"
#include "postEffect/GaussianFilterPass.h"

#include "../particle/ParticleManager.h"

#include "../baseScene/SceneManager.h"
#include "../../../application/scene/SceneFactory.h"   

#include "../skybox/Skybox.h"

#ifdef USE_IMGUI

#include "../imgui/ImGuiManager.h"
#include "../../externals/imgui/imgui.h"

#endif // USE_IMGUI

/// <summary>
/// ãƒ•ãƒ¬ãƒ¼ãƒ ãƒ¯ãƒ¼ã‚¯
/// åŸºåº•ã‚¯ãƒ©ã‚¹
/// </summary>
class Framework
{
public:

	virtual ~Framework() = default;

	void Run();

	// åˆæœŸåŒ–
	virtual void Initialize();
	
	// çµ‚äº†
	virtual void Finalize();
	
	// æ›´æ–°
	virtual void Update();
	
	// æç”»	
	virtual void Draw() = 0;

	// çµ‚äº†ãƒã‚§ãƒƒã‚¯
	virtual bool IsEndRequest() const { return winApp->ProcessMessage(); }

protected:

	// ãƒã‚¤ãƒ³ã‚¿
	std::unique_ptr<WinApp> winApp = nullptr;
	std::unique_ptr<DirectXCommon> dxCommon = nullptr;
	std::unique_ptr<SrvManager> srvManager = nullptr;
	std::unique_ptr<ModelCommon> modelCommon = nullptr;
	Input* input = nullptr;
	Audio* audio = nullptr;

	SceneManager* sceneManager_ = nullptr;
	std::unique_ptr<AbstractSceneFactory> sceneFactory_ = nullptr;

	SpriteCommon* spriteCommon = nullptr;
	TextureManager* textureManager = nullptr;
	Object3dCommon* object3dCommon = nullptr;
	ModelManager* modelManager = nullptr;

	std::unique_ptr <RenderTexture> renderTexture = nullptr;

	PostEffectManager* postEffectManager = nullptr;
	std::unique_ptr<NoneEffectPass> noneEffectPass = nullptr;
	std::unique_ptr<GrayscalePass> grayscalePass = nullptr;
	std::unique_ptr<VignettePass> vignettePass = nullptr;
	std::unique_ptr<BoxFilterPass> boxFilterPass = nullptr;
	std::unique_ptr<GaussianFilterPass> gaussianFilterPass = nullptr;

	ParticleManager* particleManager = nullptr;

	D3D12_GPU_DESCRIPTOR_HANDLE inputSrv;
	Microsoft::WRL::ComPtr<ID3D12Resource> inputRes;
	D3D12_RESOURCE_STATES state;

	std::unique_ptr<Skybox> skybox = nullptr;

#ifdef USE_IMGUI

	std::unique_ptr<ImGuiManager> imGuiManager = nullptr;

#endif // USE_IMGUI
};



============================================================
File Path: project/gameEngine/base/RenderTexture.cpp
============================================================
#include "RenderTexture.h"

#include "DirectXCommon.h"
#include "SrvManager.h"

#include <cassert>

void RenderTexture::Initialize(DirectXCommon* dxCommon, SrvManager* srvManager, uint32_t width, uint32_t height, DXGI_FORMAT format, const Vector4& clearColor)
{
	dxCommon_ = dxCommon;
    srvManager_ = srvManager;
    width_ = width;
    height_ = height;
    format_ = format;
    clearColor_ = clearColor;

    D3D12_RESOURCE_DESC desc{};
    desc.Dimension = D3D12_RESOURCE_DIMENSION_TEXTURE2D;
    desc.Width = width;
    desc.Height = height;
    desc.DepthOrArraySize = 1;
    desc.MipLevels = 1;
    desc.Format = format;
    desc.SampleDesc.Count = 1;
    desc.Flags = D3D12_RESOURCE_FLAG_ALLOW_RENDER_TARGET;

    D3D12_HEAP_PROPERTIES heapProps{};
    heapProps.Type = D3D12_HEAP_TYPE_DEFAULT;

    D3D12_CLEAR_VALUE clear{};
    clear.Format = format;
    clear.Color[0] = clearColor.x;
    clear.Color[1] = clearColor.y;
    clear.Color[2] = clearColor.z;
    clear.Color[3] = clearColor.w;

    HRESULT hr = dxCommon_->GetDevice()->CreateCommittedResource(
        &heapProps,
        D3D12_HEAP_FLAG_NONE,
        &desc,
        D3D12_RESOURCE_STATE_RENDER_TARGET,
        &clear,
        IID_PPV_ARGS(&texture_));
    assert(SUCCEEDED(hr));
    hr;

    rtvHeap_ = dxCommon_->CreateDescriptorHeap(D3D12_DESCRIPTOR_HEAP_TYPE_RTV, 1, false);
    rtvHandle_ = dxCommon_->GetCPUDescriptorHandle(rtvHeap_.Get(), static_cast<uint32_t>(dxCommon_->GetDescriptorSizeRTV()), 0);

    dxCommon_->GetDevice()->CreateRenderTargetView(texture_.Get(), nullptr, rtvHandle_);

    // ä»®ã®TexMetadataã‚’ä½œæˆ
    DirectX::TexMetadata metadata = {};
    metadata.width = width_;
    metadata.height = height_;
    metadata.depth = 1;
    metadata.arraySize = 1;
    metadata.mipLevels = 1;
    metadata.format = format_;

    srvIndex_ = srvManager_->Allocate();
    srvManager_->CreateSRVforTexture2D(srvIndex_, texture_.Get(), format, 1, metadata);

    currentState_ = D3D12_RESOURCE_STATE_RENDER_TARGET;
}

void RenderTexture::BeginRender() 
{
    if (currentState_ != D3D12_RESOURCE_STATE_RENDER_TARGET)
    {
        auto barrier = CD3DX12_RESOURCE_BARRIER::Transition(
            texture_.Get(),
            currentState_,
            D3D12_RESOURCE_STATE_RENDER_TARGET);
        dxCommon_->GetCommandList()->ResourceBarrier(1, &barrier);
        currentState_ = D3D12_RESOURCE_STATE_RENDER_TARGET;
    }

    D3D12_CPU_DESCRIPTOR_HANDLE dsvHandle = dxCommon_->GetDSVHandle();
    dxCommon_->GetCommandList()->OMSetRenderTargets(1, &rtvHandle_, FALSE, &dsvHandle);

    // ãƒ“ãƒ¥ãƒ¼ãƒãƒ¼ãƒˆã¨ã‚·ã‚¶ãƒ¼è¨­å®š
    D3D12_VIEWPORT viewport{};
    viewport.TopLeftX = 0.0f;
    viewport.TopLeftY = 0.0f;
    viewport.Width = static_cast<float>(width_);
    viewport.Height = static_cast<float>(height_);
    viewport.MinDepth = 0.0f;
    viewport.MaxDepth = 1.0f;

    D3D12_RECT scissorRect{};
    scissorRect.left = 0;
    scissorRect.top = 0;
    scissorRect.right = static_cast<LONG>(width_);
    scissorRect.bottom = static_cast<LONG>(height_);

    dxCommon_->GetCommandList()->RSSetViewports(1, &viewport);
    dxCommon_->GetCommandList()->RSSetScissorRects(1, &scissorRect);

    float clearColor[] = { clearColor_.x, clearColor_.y, clearColor_.z, clearColor_.w };
    dxCommon_->GetCommandList()->ClearRenderTargetView(rtvHandle_, clearColor, 0, nullptr);
}

void RenderTexture::EndRender()
{
    if (currentState_ != D3D12_RESOURCE_STATE_PIXEL_SHADER_RESOURCE) 
    {
        auto barrier = CD3DX12_RESOURCE_BARRIER::Transition(
            texture_.Get(),
            currentState_,
            D3D12_RESOURCE_STATE_PIXEL_SHADER_RESOURCE);
        dxCommon_->GetCommandList()->ResourceBarrier(1, &barrier);
        currentState_ = D3D12_RESOURCE_STATE_PIXEL_SHADER_RESOURCE;
    }
}

D3D12_GPU_DESCRIPTOR_HANDLE RenderTexture::GetGPUHandle() const 
{
    return srvManager_->GetGPUDescriptorHandle(srvIndex_);
}

D3D12_GPU_DESCRIPTOR_HANDLE RenderTexture::GetSRVHandle() const
{
    return srvManager_->GetGPUDescriptorHandle(srvIndex_);
}


============================================================
File Path: project/gameEngine/base/RenderTexture.h
============================================================
#pragma once

#include <wrl.h>
#include <d3d12.h>  
#include <cstdint>
#include "MyMath.h"

class DirectXCommon;
class SrvManager;

/// <summary>
/// ãƒ¬ãƒ³ãƒ€ãƒ¼ã‚¿ãƒ¼ã‚²ãƒƒãƒˆã¨ã—ã¦ä½¿ã†ãƒ†ã‚¯ã‚¹ãƒãƒ£
/// </summary>
class RenderTexture  
{  
public:

    /// <summary>
	/// åˆæœŸåŒ–
    /// </summary>
	/// <param name="dxCommon"> dxå…±é€šã‚¯ãƒ©ã‚¹</param>
	/// <param name="srvManager"> SRVãƒžãƒãƒ¼ã‚¸ãƒ£ãƒ¼</param>
	/// <param name="width">ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦å¹…</param>
	/// <param name="height">ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦é«˜ã•</param>
	/// <param name="format">ãƒ•ã‚©ãƒ¼ãƒžãƒƒãƒˆ</param>
	/// <param name="clearColor">ã‚¯ãƒªã‚¢ã‚«ãƒ©ãƒ¼</param>
    void Initialize(DirectXCommon* dxCommon, SrvManager* srvManager, uint32_t width, uint32_t height, DXGI_FORMAT format, const Vector4& clearColor);
    /// <summary>
	/// ãƒ¬ãƒ³ãƒ€ãƒ¼ã‚¿ãƒ¼ã‚²ãƒƒãƒˆã¨ã—ã¦ä½¿ç”¨é–‹å§‹
    /// </summary>
    void BeginRender();
	/// <summary>
	/// ãƒ¬ãƒ³ãƒ€ãƒ¼ã‚¿ãƒ¼ã‚²ãƒƒãƒˆã¨ã—ã¦ä½¿ç”¨çµ‚äº†
	/// </summary>
    void EndRender();


public: // ã‚²ãƒƒã‚¿ãƒ¼

	// ãƒªã‚½ãƒ¼ã‚¹ã®å–å¾—
    ID3D12Resource* GetResource() const { return texture_.Get(); }
	
    // RTV ãƒãƒ³ãƒ‰ãƒ«ã®å–å¾—
    D3D12_GPU_DESCRIPTOR_HANDLE GetGPUHandle() const;

	// SRV ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã®å–å¾—
    uint32_t GetSRVIndex() const { return srvIndex_; }

    // SRV ãƒãƒ³ãƒ‰ãƒ«ã®å–å¾—
    D3D12_GPU_DESCRIPTOR_HANDLE GetSRVHandle() const;

    // ç¾åœ¨ã®ãƒªã‚½ãƒ¼ã‚¹çŠ¶æ…‹
	D3D12_RESOURCE_STATES& GetCurrentState() { return currentState_; }

private:

    DirectXCommon* dxCommon_ = nullptr;
    SrvManager* srvManager_ = nullptr;

    Microsoft::WRL::ComPtr<ID3D12Resource> texture_;
    Microsoft::WRL::ComPtr<ID3D12DescriptorHeap> rtvHeap_;
    D3D12_CPU_DESCRIPTOR_HANDLE rtvHandle_{};
    uint32_t srvIndex_ = 0;
    DXGI_FORMAT format_ = DXGI_FORMAT_R8G8B8A8_UNORM_SRGB;
    Vector4 clearColor_ = { 0, 0, 0, 1 };
    uint32_t width_ = 0;
    uint32_t height_ = 0;
    D3D12_RESOURCE_STATES currentState_ = D3D12_RESOURCE_STATE_RENDER_TARGET;

};


============================================================
File Path: project/gameEngine/base/SrvManager.cpp
============================================================
#include "SrvManager.h"

#include <cassert>
#include <comdef.h>
#include <iostream>

const uint32_t SrvManager::kMaxSRVCount_ = 512;

void SrvManager::Initialize(DirectXCommon* dxCommon)
{
    dxCommon_ = dxCommon;

    // ãƒ‡ã‚¹ã‚¯ãƒªãƒ—ã‚¿ãƒ’ãƒ¼ãƒ—ã®ç”Ÿæˆ
    descriptorHeap_ = dxCommon_->CreateDescriptorHeap(D3D12_DESCRIPTOR_HEAP_TYPE_CBV_SRV_UAV, kMaxSRVCount_, true);
    // ãƒ‡ã‚¹ã‚¯ãƒªãƒ—ã‚¿1å€‹åˆ†ã®ã‚µã‚¤ã‚ºã‚’å–å¾—ã—ã¦è¨˜éŒ²
    descriptorSize_ = dxCommon_->GetDevice()->GetDescriptorHandleIncrementSize(D3D12_DESCRIPTOR_HEAP_TYPE_CBV_SRV_UAV);

    // ãƒ‡ãƒãƒƒã‚°ãƒ­ã‚°
    D3D12_GPU_DESCRIPTOR_HANDLE srvHeapBase = descriptorHeap_->GetGPUDescriptorHandleForHeapStart();
    OutputDebugStringA(("SRV Heap Base Address: " + std::to_string(srvHeapBase.ptr) + "\n").c_str());
    assert(descriptorHeap_ != nullptr && "SRV Descriptor Heap is null!");

}

uint32_t SrvManager::Allocate()
{
    // ä¸Šé™ã«é”ã—ã¦ã„ãªã„ã‹ãƒã‚§ãƒƒã‚¯ assert
    assert(kMaxSRVCount_ > useIndex_);

    // return ã™ã‚‹ç•ªå·ã‚’ä¸€æ—¦è¨˜éŒ²ã—ã¦ãŠã
    uint32_t index = useIndex_;
    // æ¬¡å›žã®ç‚ºã«ç•ªå·ã‚’1é€²ã‚ã‚‹
    useIndex_++;
    // ä¸Šã§è¨˜éŒ²ã—ãŸç•ªå·ã‚’return
    return index;
}

bool SrvManager::IsAllocate()
{
    if (kMaxSRVCount_ > useIndex_) {
        return true;
    } else {
        return false;
    }
}

D3D12_CPU_DESCRIPTOR_HANDLE SrvManager::GetCPUDescriptorHandle(uint32_t index)
{
    D3D12_CPU_DESCRIPTOR_HANDLE handleCPU = descriptorHeap_->GetCPUDescriptorHandleForHeapStart();
    handleCPU.ptr += (descriptorSize_ * index);
    return handleCPU;
}

D3D12_GPU_DESCRIPTOR_HANDLE SrvManager::GetGPUDescriptorHandle(uint32_t index)
{
    D3D12_GPU_DESCRIPTOR_HANDLE handleGPU = descriptorHeap_->GetGPUDescriptorHandleForHeapStart();
    handleGPU.ptr += (descriptorSize_ * index);
    return handleGPU;
}

void SrvManager::CreateSRVforTexture2D(uint32_t srvIndex, ID3D12Resource* pResource, DXGI_FORMAT Format, UINT MipLevels, const DirectX::TexMetadata& metadata)
{
    D3D12_SHADER_RESOURCE_VIEW_DESC srvDesc{};

    // å„é …ç›®ã‚’åŸ‹ã‚ã‚‹
    srvDesc.Format = Format;
    srvDesc.Shader4ComponentMapping = D3D12_DEFAULT_SHADER_4_COMPONENT_MAPPING;

    if (metadata.IsCubemap())
    {
		srvDesc.ViewDimension = D3D12_SRV_DIMENSION_TEXTURECUBE;
		srvDesc.TextureCube.MostDetailedMip = 0; // æœ€ã‚‚è©³ç´°ãªãƒŸãƒƒãƒ—ãƒ¬ãƒ™ãƒ«
		srvDesc.TextureCube.MipLevels = UINT_MAX; // ãƒŸãƒƒãƒ—ãƒ¬ãƒ™ãƒ«ã®æ•°
		srvDesc.TextureCube.ResourceMinLODClamp = 0.0f; // æœ€å°LODã‚¯ãƒ©ãƒ³ãƒ—å€¤
    }
    else
    {
        srvDesc.ViewDimension = D3D12_SRV_DIMENSION_TEXTURE2D;
        srvDesc.Texture2D.MipLevels = MipLevels;
    }

    dxCommon_->GetDevice()->CreateShaderResourceView(pResource, &srvDesc, GetCPUDescriptorHandle(srvIndex));

    // ãƒ‡ãƒãƒƒã‚°ãƒ­ã‚°
    D3D12_GPU_DESCRIPTOR_HANDLE srvHandle = GetGPUDescriptorHandle(srvIndex);
    OutputDebugStringA(("Created SRV Handle: " + std::to_string(srvHandle.ptr) + "\n").c_str());
    assert(srvHandle.ptr != 0 && "SRV Handle is invalid!");

}

void SrvManager::CreateSRVforStructuredBuffer(uint32_t srvIndex, ID3D12Resource* pResource, UINT numElements, UINT structureByteStride)
{
    D3D12_SHADER_RESOURCE_VIEW_DESC srvDesc{};

    // å„é …ç›®ã‚’åŸ‹ã‚ã‚‹
    srvDesc.Buffer.FirstElement = 0; // FirstElementã‚’0ã«è¨­å®š
    srvDesc.Buffer.NumElements = numElements;
    srvDesc.Buffer.StructureByteStride = structureByteStride;
    srvDesc.Buffer.Flags = D3D12_BUFFER_SRV_FLAG_NONE; // ãƒ•ãƒ©ã‚°ã‚’è¨­å®š

    srvDesc.Shader4ComponentMapping = D3D12_DEFAULT_SHADER_4_COMPONENT_MAPPING;
    srvDesc.ViewDimension = D3D12_SRV_DIMENSION_BUFFER; // D3D12_SRV_DIMENSION_BUFFERã«å¤‰æ›´

    dxCommon_->GetDevice()->CreateShaderResourceView(pResource, &srvDesc, GetCPUDescriptorHandle(srvIndex));
}

void SrvManager::PreDraw()
{
    // æç”»ç”¨DescriptorHeapã®è¨­å®š
    ID3D12DescriptorHeap* descriptorHeaps[] = { descriptorHeap_.Get() };
    dxCommon_->GetCommandList()->SetDescriptorHeaps(1, descriptorHeaps);
}

void SrvManager::SetGraphicsRootDescriptorTable(UINT RootParameterIndex, uint32_t srvIndex)
{
    dxCommon_->GetCommandList()->SetGraphicsRootDescriptorTable(RootParameterIndex, GetGPUDescriptorHandle(srvIndex));
}

uint32_t SrvManager::LoadTexture(const std::string& textureFilePath)
{
    // ãƒ†ã‚¯ã‚¹ãƒãƒ£ãŒæ—¢ã«ãƒ­ãƒ¼ãƒ‰ã•ã‚Œã¦ã„ã‚‹ã‹ç¢ºèª
    if (textureIndices_.find(textureFilePath) != textureIndices_.end()) {
        return textureIndices_[textureFilePath];
    }

    // DirectXCommonã‚’ä½¿ã£ã¦ãƒ†ã‚¯ã‚¹ãƒãƒ£ã‚’èª­ã¿è¾¼ã‚€
    DirectX::ScratchImage mipImages = dxCommon_->LoadTexture(textureFilePath);
    if (mipImages.GetImageCount() == 0) {
        throw std::runtime_error("Failed to load texture: " + textureFilePath);
    }

    // ãƒŸãƒƒãƒ—ãƒžãƒƒãƒ—ã®ãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿ã‚’å–å¾—
    DirectX::TexMetadata metadata = mipImages.GetMetadata();

    // SRVä½œæˆã«å¿…è¦ãªãƒªã‚½ãƒ¼ã‚¹ã‚’ä½œæˆ
    D3D12_RESOURCE_DESC textureDesc = {};
    textureDesc.Dimension = static_cast<D3D12_RESOURCE_DIMENSION>(metadata.dimension);
    textureDesc.Width = static_cast<UINT>(metadata.width);
    textureDesc.Height = static_cast<UINT>(metadata.height);
    textureDesc.DepthOrArraySize = static_cast<UINT16>(metadata.arraySize);
    textureDesc.MipLevels = static_cast<UINT16>(metadata.mipLevels);
    textureDesc.Format = metadata.format;
    textureDesc.SampleDesc.Count = 1;
    textureDesc.SampleDesc.Quality = 0;
    textureDesc.Layout = D3D12_TEXTURE_LAYOUT_UNKNOWN;
    textureDesc.Flags = D3D12_RESOURCE_FLAG_NONE;


    D3D12_HEAP_PROPERTIES heapProperties{};
    heapProperties.Type = D3D12_HEAP_TYPE_DEFAULT;

    // ãƒ†ã‚¯ã‚¹ãƒãƒ£ãƒªã‚½ãƒ¼ã‚¹ã®ä½œæˆ
    Microsoft::WRL::ComPtr<ID3D12Resource> textureResource;
    HRESULT hr = dxCommon_->GetDevice()->CreateCommittedResource(
        &heapProperties,
        D3D12_HEAP_FLAG_NONE,
        &textureDesc,
        D3D12_RESOURCE_STATE_COPY_DEST,
        nullptr,
        IID_PPV_ARGS(&textureResource)
    );

    if (FAILED(hr)) {
        throw std::runtime_error("Failed to create texture resource.");
    }

    // ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰ç”¨ãƒ’ãƒ¼ãƒ—ã®ä½œæˆ
    const UINT64 uploadBufferSize = GetRequiredIntermediateSize(textureResource.Get(), 0, static_cast<UINT>(metadata.mipLevels));
    Microsoft::WRL::ComPtr<ID3D12Resource> textureUploadHeap;

    //é ‚ç‚¹ãƒªã‚½ãƒ¼ã‚¹ç”¨ã®ãƒ’ãƒ¼ãƒ—è¨­å®š
    D3D12_HEAP_PROPERTIES uploadHeapProperties{};
    uploadHeapProperties.Type = D3D12_HEAP_TYPE_UPLOAD;

    //é ‚ç‚¹ãƒªã‚½ãƒ¼ã‚¹ã®è¨­å®š
    D3D12_RESOURCE_DESC bufferResourceDesc{};
    //ãƒãƒƒãƒ•ã‚¡ãƒªã‚½ãƒ¼ã‚¹ã€‚ãƒ†ã‚¯ã‚¹ãƒãƒ£ã®å ´åˆã¯ã¾ãŸåˆ¥ã®è¨­å®šã‚’ã™ã‚‹
    bufferResourceDesc.Dimension = D3D12_RESOURCE_DIMENSION_BUFFER;
    bufferResourceDesc.Width = uploadBufferSize;
    //ãƒãƒƒãƒ•ã‚¡ã®å ´åˆã¯ã“ã‚Œã‚‰ã¯ï¼‘ã«ã™ã‚‹æ±ºã¾ã‚Š
    bufferResourceDesc.Height = 1;
    bufferResourceDesc.DepthOrArraySize = 1;
    bufferResourceDesc.MipLevels = 1;
    bufferResourceDesc.SampleDesc.Count = 1;


    hr = dxCommon_->GetDevice()->CreateCommittedResource(
        &uploadHeapProperties,
        D3D12_HEAP_FLAG_NONE,
        &bufferResourceDesc,
        D3D12_RESOURCE_STATE_GENERIC_READ,
        nullptr,
        IID_PPV_ARGS(&textureUploadHeap)
    );

    if (FAILED(hr)) {
        throw std::runtime_error("Failed to create upload heap.");
    }

    // ãƒŸãƒƒãƒ—ãƒžãƒƒãƒ—ä»˜ãã®ãƒ‡ãƒ¼ã‚¿ã‚’GPUã«è»¢é€
    D3D12_SUBRESOURCE_DATA textureData = {};
    textureData.pData = mipImages.GetImages()->pixels;
    textureData.RowPitch = static_cast<LONG_PTR>(mipImages.GetImages()->rowPitch);
    textureData.SlicePitch = static_cast<LONG_PTR>(mipImages.GetImages()->slicePitch);
    
    // ã‚µãƒ–ãƒªã‚½ãƒ¼ã‚¹æ›´æ–°
    UpdateSubresources(
        dxCommon_->GetCommandList().Get(),
        textureResource.Get(),
        textureUploadHeap.Get(),
        0,
        0,
        static_cast<UINT>(metadata.mipLevels),
        &textureData
    );

    // ã‚³ãƒ”ãƒ¼å®Œäº†å¾Œã®çŠ¶æ…‹ã‚’å¤‰æ›´
    CD3DX12_RESOURCE_BARRIER barrier = CD3DX12_RESOURCE_BARRIER::Transition(
        textureResource.Get(),
        D3D12_RESOURCE_STATE_COPY_DEST,
        D3D12_RESOURCE_STATE_PIXEL_SHADER_RESOURCE
    );

    dxCommon_->GetCommandList()->ResourceBarrier(1, &barrier);

    // SRVä½œæˆ
    uint32_t srvIndex = Allocate();
    CreateSRVforTexture2D(srvIndex, textureResource.Get(), textureResource->GetDesc().Format, textureResource->GetDesc().MipLevels,metadata);

    // ãƒ‡ãƒãƒƒã‚°ãƒ­ã‚°
    D3D12_GPU_DESCRIPTOR_HANDLE srvHandle = GetGPUDescriptorHandle(srvIndex);
    OutputDebugStringA(("Loaded Texture SRV Handle: " + std::to_string(srvHandle.ptr) + "\n").c_str());
    assert(srvHandle.ptr != 0 && "Loaded Texture SRV Handle is invalid!");

    // ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã‚’ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã«ä¿å­˜
    textureIndices_[textureFilePath] = srvIndex;

    return srvIndex;
}


============================================================
File Path: project/gameEngine/base/SrvManager.h
============================================================
#pragma once

#include "DirectXCommon.h"

/// <summary>
/// SRVãƒžãƒãƒ¼ã‚¸ãƒ£ãƒ¼
/// SRVã®ç¢ºä¿ã€ç”Ÿæˆã€ç®¡ç†ã‚’è¡Œã†
/// </summary>
class SrvManager
{
public:

	/// <summary>
	/// åˆæœŸåŒ–
	/// </summary>
	/// <param name="dxCommon">DirectXå…±é€šã‚¯ãƒ©ã‚¹</param>
	void Initialize(DirectXCommon* dxCommon);

	// ç¢ºä¿é–¢æ•°
	/// <summary>
	/// SRVç¢ºä¿
	/// </summary>
	/// <returns>ç¢ºä¿ã—ãŸSRVã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹</returns>
	uint32_t Allocate();
	/// <summary>
	/// SRVç¢ºä¿ç¢ºèª
	/// </summary>
	/// <returns>ç¢ºä¿æ¸ˆã¿ã‹</returns>
	bool IsAllocate();

	// è¨ˆç®—ç”¨é–¢æ•°
	/// <summary>
	/// CPUãƒ‡ã‚¹ã‚¯ãƒªãƒ—ã‚¿ãƒãƒ³ãƒ‰ãƒ«å–å¾—
	/// </summary>
	/// <param name="index">ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹</param>
	/// <returns>CPUãƒ‡ã‚¹ã‚¯ãƒªãƒ—ã‚¿ãƒãƒ³ãƒ‰ãƒ«</returns>
	D3D12_CPU_DESCRIPTOR_HANDLE GetCPUDescriptorHandle(uint32_t index);
	/// <summary>
	/// GPUãƒ‡ã‚¹ã‚¯ãƒªãƒ—ã‚¿ãƒãƒ³ãƒ‰ãƒ«å–å¾—
	/// </summary>
	/// <param name="index">ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹</param>
	/// <returns>GPUãƒ‡ã‚¹ã‚¯ãƒªãƒ—ã‚¿ãƒãƒ³ãƒ‰ãƒ«</returns>
	D3D12_GPU_DESCRIPTOR_HANDLE GetGPUDescriptorHandle(uint32_t index);

	/// <summary>
	/// SRVç”Ÿæˆ(ãƒ†ã‚¯ã‚¹ãƒãƒ£ç”¨)
	/// </summary>
	/// <param name="srvIndex">SRVã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹</param>
	/// <param name="pResource">ãƒªã‚½ãƒ¼ã‚¹ãƒã‚¤ãƒ³ã‚¿</param>
	/// <param name="Format">ãƒ•ã‚©ãƒ¼ãƒžãƒƒãƒˆ</param>
	/// <param name="MipLevels">ãƒŸãƒƒãƒ—ãƒ¬ãƒ™ãƒ«æ•°</param>
	/// <param name="metadata">ãƒ†ã‚¯ã‚¹ãƒãƒ£ãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿</param>
	void CreateSRVforTexture2D(uint32_t srvIndex, ID3D12Resource* pResource, DXGI_FORMAT Format, UINT MipLevels, const DirectX::TexMetadata& metadata);
	
	/// <summary>
	/// SRVç”Ÿæˆ(Structured Bufferç”¨)
	/// </summary>
	/// <param name="srvIndex">SRVã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹</param>
	/// <param name="pResource">ãƒªã‚½ãƒ¼ã‚¹ãƒã‚¤ãƒ³ã‚¿</param>
	/// <param name="numElements">è¦ç´ æ•°</param>
	/// <param name="structureByteStride">æ§‹é€ ä½“ãƒã‚¤ãƒˆã‚¹ãƒˆãƒ©ã‚¤ãƒ‰</param>
	void CreateSRVforStructuredBuffer(uint32_t srvIndex, ID3D12Resource* pResource, UINT numElements, UINT structureByteStride);

	// æç”»å‰å‡¦ç†
	void PreDraw();

	/// <summary>
	/// ãƒ†ã‚¯ã‚¹ãƒãƒ£èª­ã¿è¾¼ã¿
	/// </summary>
	/// <param name="textureFilePath">ãƒ†ã‚¯ã‚¹ãƒãƒ£ãƒ•ã‚¡ã‚¤ãƒ«ãƒ‘ã‚¹</param>
	/// <returns>SRVã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹</returns>
	uint32_t LoadTexture(const std::string& textureFilePath);

public: // ã‚²ãƒƒã‚¿ãƒ¼

	/// <summary>
	/// SRVã®CPUãƒ‡ã‚£ã‚¹ã‚¯ãƒªãƒ—ã‚¿ãƒãƒ³ãƒ‰ãƒ«ã‚’å–å¾—
	/// </summary>
	/// <param name="srvIndex">SRVã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹</param>
	/// <returns>SRVã®CPUãƒ‡ã‚£ã‚¹ã‚¯ãƒªãƒ—ã‚¿ãƒãƒ³ãƒ‰ãƒ«</returns>
	D3D12_CPU_DESCRIPTOR_HANDLE GetCpuHandle(uint32_t srvIndex) const 
	{
		if (srvIndex >= kMaxSRVCount_) {
			throw std::out_of_range("Invalid SRV index");
		}
		D3D12_CPU_DESCRIPTOR_HANDLE handle = descriptorHeap_->GetCPUDescriptorHandleForHeapStart();
		handle.ptr += descriptorSize_ * srvIndex;
		return handle;
	}

	/// <summary>
	/// SRVç”¨ãƒ‡ã‚¹ã‚¯ãƒªãƒ—ã‚¿ãƒ’ãƒ¼ãƒ—ã‚’å–å¾—
	/// </summary>
	/// <returns>SRVç”¨ãƒ‡ã‚¹ã‚¯ãƒªãƒ—ã‚¿ãƒ’ãƒ¼ãƒ—</returns>
	Microsoft::WRL::ComPtr <ID3D12DescriptorHeap> GetHeap() const
	{
		return descriptorHeap_;
	}

public: // ã‚»ãƒƒã‚¿ãƒ¼

	/// <summary>
	/// ã‚°ãƒ©ãƒ•ã‚£ãƒƒã‚¯ã‚¹ãƒ«ãƒ¼ãƒˆãƒ‡ã‚¹ã‚¯ãƒªãƒ—ã‚¿ãƒ†ãƒ¼ãƒ–ãƒ«ã‚’è¨­å®š
	/// </summary>
	/// <param name="RootParameterIndex">ãƒ«ãƒ¼ãƒˆãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹</param>
	/// <param name="srvIndex"> SRVã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹</param>
	void SetGraphicsRootDescriptorTable(UINT RootParameterIndex, uint32_t srvIndex);

private:

	DirectXCommon* dxCommon_ = nullptr;

	// æœ€å¤§SRVæ•°(æœ€å¤§ãƒ†ã‚¯ã‚¹ãƒãƒ£æ•°)
	static const uint32_t kMaxSRVCount_;
	//SRVç”¨ãƒ‡ã‚¹ã‚¯ãƒªãƒ—ã‚¿ã‚µã‚¤ã‚º
	uint32_t descriptorSize_;
	// SRVç”¨ãƒ‡ã‚¹ã‚¯ãƒªãƒ—ã‚¿ãƒ’ãƒ¼ãƒ—
	Microsoft::WRL::ComPtr<ID3D12DescriptorHeap> descriptorHeap_;

	// æ¬¡ã«ä½¿ç”¨ã™ã‚‹SRVã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹
	uint32_t useIndex_ = 0;

	// ãƒ†ã‚¯ã‚¹ãƒãƒ£ã‚­ãƒ£ãƒƒã‚·ãƒ¥
	std::unordered_map<std::string, uint32_t> textureIndices_;

};



============================================================
File Path: project/gameEngine/base/TextureManager.cpp
============================================================
#include "TextureManager.h"

#include <cassert>
#include <d3d12.h>

uint32_t TextureManager::kSRVIndexTop = 1;

TextureManager* TextureManager::GetInstance()
{
	static TextureManager instance;
	return &instance;
}

void TextureManager::Finalize(){}

void TextureManager::Initialize(DirectXCommon* dxCommon, SrvManager* srvManager)
{
	dxCommon_ = dxCommon;
	srvManager_ = srvManager;

	// SRVã®æ•°ã¨åŒæ•°
	textureDatas.reserve(DirectXCommon::kMaxSRVCount);
}

void TextureManager::LoadTexture(const std::string& filePath, bool forceCubeMap)
{
	// èª­ã¿è¾¼ã¿æ¸ˆã¿ãƒ†ã‚¯ã‚¹ãƒãƒ£ã‚’æ¤œç´¢
	if (textureDatas.contains(filePath)) {
		// èª­ã¿è¾¼ã¿æ¸ˆã¿ãªã‚‰æ—©æœŸreturn
		return;
	}
	// ãƒ†ã‚¯ã‚¹ãƒãƒ£æžšæ•°ä¸Šé™ãƒã‚§ãƒƒã‚¯
	assert(srvManager_->IsAllocate());

	//ãƒ†ã‚¯ã‚¹ãƒãƒ£ãƒ•ã‚¡ã‚¤ãƒ«ã‚’èª­ã‚“ã§ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã§æ‰±ãˆã‚‹ã‚ˆã†ã«ã™ã‚‹
	DirectX::ScratchImage image{};
	std::wstring filePathW = StringUtility::ConvertString(filePath);
	HRESULT hr;
	if (filePathW.ends_with(L".dds"))
	{
		// DDSãƒ•ã‚¡ã‚¤ãƒ«ã®èª­ã¿è¾¼ã¿
		hr = DirectX::LoadFromDDSFile(filePathW.c_str(), DirectX::DDS_FLAGS_NONE, nullptr, image);
	}
	else
	{
		hr = DirectX::LoadFromWICFile(filePathW.c_str(), DirectX::WIC_FLAGS_FORCE_SRGB, nullptr, image);
		assert(SUCCEEDED(hr));
	}

	//ãƒŸãƒƒãƒ—ãƒžãƒƒãƒ—ã®ä½œæˆ
	DirectX::ScratchImage mipImages{};
	if (DirectX::IsCompressed(image.GetMetadata().format))
	{
		// åœ§ç¸®ãƒ†ã‚¯ã‚¹ãƒãƒ£ã®å ´åˆã¯ã€ãƒŸãƒƒãƒ—ãƒžãƒƒãƒ—ã‚’ç”Ÿæˆã—ãªã„
		mipImages = std::move(image);
	} 
	else
	{
		hr = DirectX::GenerateMipMaps(image.GetImages(), image.GetImageCount(), image.GetMetadata(), DirectX::TEX_FILTER_SRGB, 0, mipImages);
	}

	const auto& meta = mipImages.GetMetadata();
	if (filePathW.ends_with(L".dds")) 
	{
		// ã‚­ãƒ¥ãƒ¼ãƒ–ãƒžãƒƒãƒ—ã¨ã—ã¦ä½¿ã„ãŸã„å ´åˆã®ã¿ãƒã‚§ãƒƒã‚¯
		assert(!forceCubeMap or meta.IsCubemap()); // forceCubeMapæ™‚ã¯å¿…ãšã‚­ãƒ¥ãƒ¼ãƒ–ãƒžãƒƒãƒ—
		assert(!forceCubeMap or meta.arraySize == 6);
	}
	meta;
	forceCubeMap;

	// â˜… ã“ã“ã§metaã®å†…å®¹ã‚’å‡ºåŠ›
	const auto& meta2 = mipImages.GetMetadata();
	OutputDebugStringA(std::format(
		"meta2: IsCubemap={}, arraySize={}, mipLevels={}\n",
		meta2.IsCubemap(), meta2.arraySize, meta2.mipLevels
	).c_str());

	// ãƒ†ã‚¯ã‚¹ãƒãƒ£ãƒ‡ãƒ¼ã‚¿ã‚’è¿½åŠ 
	// è¿½åŠ ã—ãŸãƒ†ã‚¯ã‚¹ãƒãƒ£ãƒ‡ãƒ¼ã‚¿ã®å‚ç…§ã‚’å–å¾—ã™ã‚‹
	TextureData& textureData = textureDatas[filePath];

	textureData.metadata = mipImages.GetMetadata();
	textureData.resource = dxCommon_->CreateTextureResource(textureData.metadata);
	textureData.intermediate = dxCommon_->UploadTextureData(textureData.resource, mipImages);
	dxCommon_->CommandPass();

	// ãƒ†ã‚¯ã‚¹ãƒãƒ£ãƒ‡ãƒ¼ã‚¿ã®è¦ç´ ç•ªå·ã‚’SRVã®ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã‚’ã™ã‚‹
	textureData.srvIndex = srvManager_->Allocate();
	textureData.srvHandleCPU = srvManager_->GetCPUDescriptorHandle(textureData.srvIndex);
	textureData.srvHandleGPU = srvManager_->GetGPUDescriptorHandle(textureData.srvIndex);

	D3D12_SHADER_RESOURCE_VIEW_DESC srvDesc{};
	// SRVã®è¨­å®š
	srvDesc.Format = textureData.metadata.format;
	srvDesc.Shader4ComponentMapping = D3D12_DEFAULT_SHADER_4_COMPONENT_MAPPING;

	OutputDebugStringA(std::format(
		"DEBUG: dimension={}, IsCubemap={}, arraySize={}\n",
		static_cast<int>(textureData.metadata.dimension),
		textureData.metadata.IsCubemap(),
		textureData.metadata.arraySize
	).c_str());

	if (textureData.metadata.dimension == DirectX::TEX_DIMENSION_TEXTURE2D && textureData.metadata.IsCubemap() && textureData.metadata.arraySize == 6)
	{
		srvDesc.ViewDimension = D3D12_SRV_DIMENSION_TEXTURECUBE;
		srvDesc.TextureCube.MostDetailedMip = 0; // æœ€ã‚‚è©³ç´°ãªãƒŸãƒƒãƒ—ãƒ¬ãƒ™ãƒ«
		srvDesc.TextureCube.MipLevels = UINT(textureData.metadata.mipLevels);
		srvDesc.TextureCube.ResourceMinLODClamp = 0.0f; // æœ€å°LODã‚¯ãƒ©ãƒ³ãƒ—å€¤
	}
	else
	{
		assert(textureData.metadata.IsCubemap() == false && "2Dãƒ†ã‚¯ã‚¹ãƒãƒ£ãªã®ã«IsCubemap==true");
		srvDesc.ViewDimension = D3D12_SRV_DIMENSION_TEXTURE2D;
		srvDesc.Texture2D.MipLevels = UINT(textureData.metadata.mipLevels);
	}

	// â˜… ã“ã“ã§SRVè¨­å®šå†…å®¹ã‚’å‡ºåŠ›
	OutputDebugStringA(std::format(
		"SRV: ViewDimension={}, TextureCube.MipLevels={}\n",
		static_cast<int>(srvDesc.ViewDimension),
		static_cast<unsigned int>(srvDesc.TextureCube.MipLevels)
	).c_str());


	// è¨­å®šã‚’åŸºã«SRVã®ç”Ÿæˆ
	dxCommon_->GetDevice()->CreateShaderResourceView(textureData.resource.Get(), &srvDesc, textureData.srvHandleCPU);


	// ã“ã“ã§SRVã®å†…å®¹ã‚’å‡ºåŠ›
	OutputDebugStringA(std::format(
		"[SRVç™»éŒ²] filePath={}, srvIndex={}, ViewDimension={}, IsCubemap={}, arraySize={}\n",
		filePath,
		textureData.srvIndex,
		static_cast<int>(srvDesc.ViewDimension),
		textureData.metadata.IsCubemap(),
		textureData.metadata.arraySize
	).c_str());
}

const DirectX::TexMetadata& TextureManager::GetMetaData(const std::string& filePath)
{
	// ãƒ†ã‚¯ã‚¹ãƒãƒ£ãŒå­˜åœ¨ã™ã‚‹ã‹ç¢ºèª
	auto it = textureDatas.find(filePath);
	if (it == textureDatas.end()) {
		// ãªã‹ã£ãŸã‚‰ã‚¨ãƒ©ãƒ¼ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸
		Logger::Log("Error: Texture not found for filePath: " + filePath);
		throw std::runtime_error("Texture not found for filePath: " + filePath);
	}

	// ãƒ†ã‚¯ã‚¹ãƒãƒ£ãƒ‡ãƒ¼ã‚¿ã®å‚ç…§ã‚’å–å¾—
	TextureData& textureData = it->second;
	return textureData.metadata;
}


uint32_t TextureManager::GetTextureIndexByFilePath(const std::string& filePath)
{
	// ãƒ†ã‚¯ã‚¹ãƒãƒ£ãŒå­˜åœ¨ã™ã‚‹ã‹ç¢ºèª
	auto it = textureDatas.find(filePath);
	if (it == textureDatas.end()) {
		// ãªã‹ã£ãŸã‚‰ã‚¨ãƒ©ãƒ¼ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸
		Logger::Log("Error: Texture not found for filePath: " + filePath);
		throw std::runtime_error("Texture not found for filePath: " + filePath);
	}

	// ãƒ†ã‚¯ã‚¹ãƒãƒ£ãƒ‡ãƒ¼ã‚¿ã®å‚ç…§ã‚’å–å¾—
	TextureData& textureData = it->second;
	return textureData.srvIndex;
}

D3D12_GPU_DESCRIPTOR_HANDLE TextureManager::GetSrvHandleGPU(const std::string& filePath)
{

	// ãƒ†ã‚¯ã‚¹ãƒãƒ£ãŒå­˜åœ¨ã™ã‚‹ã‹ç¢ºèª
	auto it = textureDatas.find(filePath);
	if (it == textureDatas.end()) {
		// ãªã‹ã£ãŸã‚‰ã‚¨ãƒ©ãƒ¼ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸
		Logger::Log("Error: Texture not found for filePath: " + filePath);
		throw std::runtime_error("Texture not found for filePath: " + filePath);
	}

	// ãƒ†ã‚¯ã‚¹ãƒãƒ£ãƒ‡ãƒ¼ã‚¿ã®å‚ç…§ã‚’å–å¾—
	TextureData& textureData = it->second;
	return textureData.srvHandleGPU;
}

============================================================
File Path: project/gameEngine/base/TextureManager.h
============================================================
#pragma once

#include <unordered_map>

#include "DirectXCommon.h"
#include "SrvManager.h"

/// <summary>
/// ãƒ†ã‚¯ã‚¹ãƒãƒ£ç®¡ç†ã‚¯ãƒ©ã‚¹
/// ãƒ†ã‚¯ã‚¹ãƒãƒ£ã®èª­ã¿è¾¼ã¿ã€SRVã®ç”Ÿæˆã€SRVãƒãƒ³ãƒ‰ãƒ«ã®å–å¾—ã‚’è¡Œã†
/// </summary>
class TextureManager
{
private:

	TextureManager() = default;
	~TextureManager() = default;
	TextureManager(TextureManager&) = default;
	TextureManager& operator=(TextureManager&) = default;

public:

	/// <summary>
	/// ã‚·ãƒ³ã‚°ãƒ«ãƒˆãƒ³ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã®å–å¾—
	/// </summary>
	/// <returns>ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹</returns>
	static TextureManager* GetInstance();
	// çµ‚äº†
	void Finalize();

	/// <summary>
	/// åˆæœŸåŒ–
	/// </summary>
	/// <param name="dxCommon">DirectXå…±é€šã‚¯ãƒ©ã‚¹</param>
	/// <param name="srvManager">SRVç®¡ç†ã‚¯ãƒ©ã‚¹</param>
	void Initialize(DirectXCommon* dxCommon, SrvManager* srvManager);

	/// <summary>
	/// ãƒ†ã‚¯ã‚¹ãƒãƒ£ãƒ•ã‚¡ã‚¤ãƒ«ã®èª­ã¿è¾¼ã¿
	/// </summary>
	/// <param name="filePath">ãƒ•ã‚¡ã‚¤ãƒ«ãƒ‘ã‚¹</param>
	/// <param name="forceCubeMap">å¼·åˆ¶çš„ã«ã‚­ãƒ¥ãƒ¼ãƒ–ãƒžãƒƒãƒ—ã¨ã—ã¦èª­ã¿è¾¼ã‚€ã‹</param>
	void LoadTexture(const std::string& filePath, bool forceCubeMap = false);

public: // ã‚²ãƒƒã‚¿ãƒ¼

	/// <summary>
	/// ãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿ã‚’å–å¾—
	/// </summary>
	/// <param name="filePath">ãƒ•ã‚¡ã‚¤ãƒ«ãƒ‘ã‚¹</param>
	/// <returns>ãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿</returns>
	const DirectX::TexMetadata& GetMetaData(const std::string& filePath);

	/// <summary>
	/// SRVã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã®å–å¾—
	/// </summary>
	/// <param name="filePath">ãƒ•ã‚¡ã‚¤ãƒ«ãƒ‘ã‚¹</param>
	/// <returns>SRVã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹</returns>
	uint32_t GetTextureIndexByFilePath(const std::string& filePath);

	/// <summary>
	/// ãƒ†ã‚¯ã‚¹ãƒãƒ£ç•ªå·ã‹ã‚‰GPUãƒãƒ³ãƒ‰ãƒ«ã‚’æ‰€å¾—
	/// </summary>
	/// <param name="filePath">ãƒ•ã‚¡ã‚¤ãƒ«ãƒ‘ã‚¹</param>
	/// <returns>GPUãƒ‡ã‚¹ã‚¯ãƒªãƒ—ã‚¿ãƒãƒ³ãƒ‰ãƒ«</returns>
	D3D12_GPU_DESCRIPTOR_HANDLE GetSrvHandleGPU(const std::string& filePath);

	/// <summary>
	/// SRVç®¡ç†ã‚¯ãƒ©ã‚¹ã‚’å–å¾—
	/// </summary>
	/// <returns>SRVç®¡ç†ã‚¯ãƒ©ã‚¹</returns>
	SrvManager* GetSrvManager() const { return srvManager_; }


private: // æ§‹é€ ä½“

	// ãƒ†ã‚¯ã‚¹ãƒãƒ£1æžšåˆ†ã®ãƒ‡ãƒ¼ã‚¿
	struct TextureData
	{
		DirectX::TexMetadata metadata;
		Microsoft::WRL::ComPtr<ID3D12Resource> resource;
		Microsoft::WRL::ComPtr<ID3D12Resource> intermediate;
		uint32_t srvIndex;
		D3D12_CPU_DESCRIPTOR_HANDLE srvHandleCPU;
		D3D12_GPU_DESCRIPTOR_HANDLE srvHandleGPU;
	};

private:

	// ãƒ†ã‚¯ã‚¹ãƒãƒ£ãƒ‡ãƒ¼ã‚¿
	std::unordered_map<std::string, TextureData> textureDatas;

	DirectXCommon* dxCommon_ = nullptr;

	SrvManager* srvManager_ = nullptr;

	// SRVã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã®é–‹å§‹ç•ªå·
	static uint32_t kSRVIndexTop;
};

============================================================
File Path: project/gameEngine/base/WinApp.cpp
============================================================
#include "WinApp.h"

#ifdef USE_IMGUI

#include "../../externals/imgui/imgui_impl_win32.h"

extern  IMGUI_IMPL_API LRESULT ImGui_ImplWin32_WndProcHandler(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);

#endif // USE_IMGUI


//ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ãƒ—ãƒ­ã‚·ãƒ¼ã‚¸ãƒ£
LRESULT WinApp::WindowProc(HWND hwnd, UINT msg, WPARAM wparam, LPARAM lparam)
{
#ifdef USE_IMGUI

	if (ImGui_ImplWin32_WndProcHandler(hwnd, msg, wparam, lparam))
	{
		return true;
	}

#endif // USE_IMGUI

	switch (msg)
	{
	case WM_DESTROY:
		PostQuitMessage(0);
		return 0;
	}

	return DefWindowProc(hwnd, msg, wparam, lparam);
}

void WinApp::Initialize()
{
	//COMã®åˆæœŸåŒ–
	CoInitializeEx(0, COINIT_MULTITHREADED);


	
	//ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ãƒ—ãƒ­ã‚·ãƒ¼ã‚¸ãƒ£
	wc.lpfnWndProc = WindowProc;
	//ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ã‚¯ãƒ©ã‚¹å
	wc.lpszClassName = L"CG2WindowClass";
	//ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ãƒãƒ³ãƒ‰ãƒ«
	wc.hInstance = GetModuleHandle(nullptr);
	//ã‚«ãƒ¼ã‚½ãƒ«
	wc.hCursor = LoadCursor(nullptr, IDC_ARROW);

	//ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ã‚¯ãƒ©ã‚¹ã‚’ç™»éŒ²ã™ã‚‹
	RegisterClass(&wc);

	//ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ã‚µã‚¤ã‚ºã‚’è¡¨ã™æ§‹é€ ä½“ã«ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆé ˜åŸŸã‚’å…¥ã‚Œã‚‹
	RECT wrc = { 0,0,kClientWidth,kClientHeight };

	//ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆé ˜åŸŸã‚’ã‚‚ã¨ã«å®Ÿéš›ã®ã‚µã‚¤ã‚ºã«wrcã‚’å¤‰æ›´ã—ã¦ã‚‚ã‚‰ã†
	AdjustWindowRect(&wrc, WS_OVERLAPPEDWINDOW, false);



	//ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ã®è¨­å®š
	hwnd = CreateWindow(
		wc.lpszClassName,		//åˆ©ç”¨ã™ã‚‹ã‚¯ãƒ©ã‚¹å
		L"ã‚¦ã‚§ãƒ¼ãƒ–ã‚·ãƒ¥ãƒ¼ã‚¿ãƒ¼",	//ã‚¿ã‚¤ãƒˆãƒ«ãƒãƒ¼ã®æ–‡å­—
		WS_OVERLAPPEDWINDOW,	//ã‚ˆãè¦‹ã‚‹ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ã‚¹ã‚¿ã‚¤ãƒ«
		CW_USEDEFAULT,			//è¡¨ç¤ºXåº§æ¨™(WindowsOSã«ä»»ã›ã‚‹)
		CW_USEDEFAULT,			//è¡¨ç¤ºYåº§æ¨™(WindowsOSã«ä»»ã›ã‚‹)
		wrc.right - wrc.left,	//ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦æ¨ªå¹…
		wrc.bottom - wrc.top,	//ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ç¸¦å¹…
		nullptr,				//è¦ªã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ãƒãƒ³ãƒ‰ãƒ«
		nullptr,				//ãƒ¡ãƒ‹ãƒ¥ãƒ¼ãƒãƒ³ãƒ‰ãƒ«
		wc.hInstance,			//ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ãƒãƒ³ãƒ‰ãƒ«
		nullptr					//ã‚ªãƒ—ã‚·ãƒ§ãƒ³
	);



	//ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ã‚’è¡¨ç¤ºã™ã‚‹
	ShowWindow(hwnd, SW_SHOW);

}

void WinApp::Update()
{



}

void WinApp::Finalize()
{
	CloseWindow(hwnd);
	CoUninitialize();
}

bool WinApp::ProcessMessage()
{

	MSG msg{};

	//Windowã«ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ãŒæ¥ã¦ãŸã‚‰æœ€å„ªå…ˆã§å‡¦ç†ã•ã›ã‚‹
	if (PeekMessage(&msg, nullptr, 0, 0, PM_REMOVE))
	{
		TranslateMessage(&msg);
		DispatchMessage(&msg);
	}

	if (msg.message == WM_QUIT)
	{
		return true;
	}

	return false;
}


============================================================
File Path: project/gameEngine/base/WinApp.h
============================================================
#pragma once

#include <windows.h>
#include <cstdint>

#ifdef USE_IMGUI

//ImGui
#include "../../externals/imgui/imgui.h"
#include "../../externals/imgui/imgui_impl_dx12.h"

#endif // USE_IMGUI

/// <summary>
/// Windowsã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã‚¯ãƒ©ã‚¹
/// </summary>
class WinApp
{
public:

	/// <summary>
	/// ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿
	/// </summary>
	/// <param name="hwnd">ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ãƒãƒ³ãƒ‰ãƒ«</param>
	/// <param name="msg">ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸</param>
	/// <param name="wparam">è¿½åŠ æƒ…å ±1</param>
	/// <param name="lparam">è¿½åŠ æƒ…å ±2</param>
	/// <returns>å‡¦ç†çµæžœ</returns>
	static LRESULT CALLBACK WindowProc(HWND hwnd, UINT msg, WPARAM wparam, LPARAM lparam);

public:

	//ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆé ˜åŸŸã®ã‚µã‚¤ã‚º
	static const int32_t kClientWidth = 1200;
	static const int32_t kClientHeight = 720;


	// åˆæœŸåŒ–
	void Initialize();
	// æ›´æ–°
	void Update();
	// çµ‚äº†
	void Finalize();

	/// <summary>
	/// ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã®å‡¦ç†
	/// </summary>
	/// <returns>å‡¦ç†çµæžœ</returns>
	bool ProcessMessage();

public: // ã‚²ãƒƒã‚¿ãƒ¼

	// ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ãƒãƒ³ãƒ‰ãƒ«ã®ã‚²ãƒƒã‚¿ãƒ¼
	HWND GetHwnd() const { return hwnd; }

	// ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ãƒãƒ³ãƒ‰ãƒ«ã®ã‚²ãƒƒã‚¿ãƒ¼
	HINSTANCE GetHInstance() const { return wc.hInstance; }


private:

	// ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ãƒãƒ³ãƒ‰ãƒ«
	HWND hwnd = nullptr;

	//ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ã‚¯ãƒ©ã‚¹ã®è¨­å®š
	WNDCLASS wc{};

};

============================================================
File Path: project/gameEngine/base/postEffect/BasePostEffectPass.cpp
============================================================
#include "BasePostEffectPass.h"

#include "../DirectXCommon.h"
#include "../SrvManager.h"

void BasePostEffectPass::Initialize(DirectXCommon* dxCommon, SrvManager* srvManager, const std::wstring& vsPath, const std::wstring& psPath)
{
    dxCommon_ = dxCommon;
    srvManager_ = srvManager;

    CD3DX12_DESCRIPTOR_RANGE srvRange;
    srvRange.Init(D3D12_DESCRIPTOR_RANGE_TYPE_SRV, 1, 0);

    CD3DX12_DESCRIPTOR_RANGE samplerRange;
    samplerRange.Init(D3D12_DESCRIPTOR_RANGE_TYPE_SAMPLER, 1, 0);

    CD3DX12_ROOT_PARAMETER rootParams[3];
    rootParams[0].InitAsDescriptorTable(1, &srvRange, D3D12_SHADER_VISIBILITY_PIXEL);
    rootParams[1].InitAsDescriptorTable(1, &samplerRange, D3D12_SHADER_VISIBILITY_PIXEL);
    rootParams[2].InitAsConstantBufferView(0, 0, D3D12_SHADER_VISIBILITY_PIXEL);

    CD3DX12_ROOT_SIGNATURE_DESC rootSigDesc;
    rootSigDesc.Init(_countof(rootParams), rootParams, 0, nullptr, D3D12_ROOT_SIGNATURE_FLAG_ALLOW_INPUT_ASSEMBLER_INPUT_LAYOUT);

    Microsoft::WRL::ComPtr<ID3DBlob> sigBlob, errBlob;
    D3D12SerializeRootSignature(&rootSigDesc, D3D_ROOT_SIGNATURE_VERSION_1, &sigBlob, &errBlob);
    dxCommon->GetDevice()->CreateRootSignature(0, sigBlob->GetBufferPointer(), sigBlob->GetBufferSize(), IID_PPV_ARGS(&rootSignature_));

    auto vs = dxCommon->CompileShader(vsPath, L"vs_6_0");
    auto ps = dxCommon->CompileShader(psPath, L"ps_6_0");

    D3D12_GRAPHICS_PIPELINE_STATE_DESC psoDesc = {};
    psoDesc.VS = { vs->GetBufferPointer(), vs->GetBufferSize() };
    psoDesc.PS = { ps->GetBufferPointer(), ps->GetBufferSize() };
    psoDesc.pRootSignature = rootSignature_.Get();
    psoDesc.RTVFormats[0] = DXGI_FORMAT_R8G8B8A8_UNORM_SRGB;
    psoDesc.NumRenderTargets = 1;
    psoDesc.SampleDesc.Count = 1;
    psoDesc.SampleMask = UINT_MAX;
    psoDesc.PrimitiveTopologyType = D3D12_PRIMITIVE_TOPOLOGY_TYPE_TRIANGLE;
    psoDesc.InputLayout = { nullptr, 0 };
    psoDesc.DepthStencilState.DepthEnable = FALSE;
    psoDesc.DepthStencilState.StencilEnable = FALSE;
    psoDesc.DSVFormat = DXGI_FORMAT_UNKNOWN;
    
    psoDesc.BlendState = CD3DX12_BLEND_DESC(D3D12_DEFAULT);
    /*D3D12_BLEND_DESC blendDesc = {};
    blendDesc.RenderTarget[0].BlendEnable = TRUE;
    blendDesc.RenderTarget[0].SrcBlend = D3D12_BLEND_SRC_ALPHA;
    blendDesc.RenderTarget[0].DestBlend = D3D12_BLEND_INV_SRC_ALPHA;
    blendDesc.RenderTarget[0].BlendOp = D3D12_BLEND_OP_ADD;
    blendDesc.RenderTarget[0].SrcBlendAlpha = D3D12_BLEND_ONE;
    blendDesc.RenderTarget[0].DestBlendAlpha = D3D12_BLEND_ZERO;
    blendDesc.RenderTarget[0].BlendOpAlpha = D3D12_BLEND_OP_ADD;
    blendDesc.RenderTarget[0].RenderTargetWriteMask = D3D12_COLOR_WRITE_ENABLE_ALL;
    psoDesc.BlendState = blendDesc;*/

    psoDesc.RasterizerState = CD3DX12_RASTERIZER_DESC(D3D12_DEFAULT);

    dxCommon->GetDevice()->CreateGraphicsPipelineState(&psoDesc, IID_PPV_ARGS(&pipelineState_));

    dxCommon->CreateSamplerHeap();
}

void BasePostEffectPass::EnsureResourceState(Microsoft::WRL::ComPtr<ID3D12GraphicsCommandList> cmdList, ID3D12Resource* resource, D3D12_RESOURCE_STATES& currentState, D3D12_RESOURCE_STATES requiredState)
{
    if (currentState != requiredState) 
    {
        D3D12_RESOURCE_BARRIER barrier{};
        barrier.Type = D3D12_RESOURCE_BARRIER_TYPE_TRANSITION;
        barrier.Flags = D3D12_RESOURCE_BARRIER_FLAG_NONE;
        barrier.Transition.pResource = resource;
        barrier.Transition.Subresource = D3D12_RESOURCE_BARRIER_ALL_SUBRESOURCES;
        barrier.Transition.StateBefore = currentState;
        barrier.Transition.StateAfter = requiredState;

        cmdList->ResourceBarrier(1, &barrier);
        currentState = requiredState;
    }
}


============================================================
File Path: project/gameEngine/base/postEffect/BasePostEffectPass.h
============================================================
#pragma once

#include "IPostEffectPass.h"

#include <wrl.h>
#include <d3d12.h>
#include <string>

class DirectXCommon;
class SrvManager;

/// <summary>
/// ãƒã‚¹ãƒˆã‚¨ãƒ•ã‚§ã‚¯ãƒˆãƒ‘ã‚¹ã®åŸºåº•ã‚¯ãƒ©ã‚¹
/// ç¶™æ‰¿ã—ã¦ä½¿ç”¨ã™ã‚‹
/// </summary>
class BasePostEffectPass : public IPostEffectPass {
public:

    /// <summary>
	/// åˆæœŸåŒ–
    /// </summary>
    /// <param name="dxCommon">DirectXå…±é€šæ©Ÿèƒ½ç®¡ç†ã‚¯ãƒ©ã‚¹ã¸ã®ãƒã‚¤ãƒ³ã‚¿</param>
    /// <param name="srvManager">ã‚·ã‚§ãƒ¼ãƒ€ãƒªã‚½ãƒ¼ã‚¹ãƒ“ãƒ¥ãƒ¼ç®¡ç†ã‚¯ãƒ©ã‚¹ã¸ã®ãƒã‚¤ãƒ³ã‚¿</param>
    /// <param name="vsPath">é ‚ç‚¹ã‚·ã‚§ãƒ¼ãƒ€ãƒ•ã‚¡ã‚¤ãƒ«ã®ãƒ‘ã‚¹</param>
    /// <param name="psPath">ãƒ”ã‚¯ã‚»ãƒ«ã‚·ã‚§ãƒ¼ãƒ€ãƒ•ã‚¡ã‚¤ãƒ«ã®ãƒ‘ã‚¹</param>
    void Initialize(DirectXCommon* dxCommon, SrvManager* srvManager, const std::wstring& vsPath, const std::wstring& psPath) override;
    
    /// <summary>
	/// æç”»
    /// </summary>
    /// <param name="cmdList">æç”»ã‚³ãƒžãƒ³ãƒ‰ãƒªã‚¹ãƒˆ</param>
    /// <param name="inputSrvHandle">å…¥åŠ›ãƒ†ã‚¯ã‚¹ãƒãƒ£ã®SRVãƒãƒ³ãƒ‰ãƒ«</param>
    /// <param name="inputResource">å…¥åŠ›ãƒªã‚½ãƒ¼ã‚¹</param>
    /// <param name="currentState">å…¥åŠ›ãƒªã‚½ãƒ¼ã‚¹ã®ç¾åœ¨ã®çŠ¶æ…‹</param>
    void Draw(ID3D12GraphicsCommandList* cmdList, D3D12_GPU_DESCRIPTOR_HANDLE inputSrvHandle, ID3D12Resource* inputResource, D3D12_RESOURCE_STATES& currentState) override = 0;
    
    /// <summary>
	/// ãƒªã‚½ãƒ¼ã‚¹ã®çŠ¶æ…‹ã‚’é·ç§»ã•ã›ã‚‹
    /// </summary>
    /// <param name="cmdList">ã‚³ãƒžãƒ³ãƒ‰ãƒªã‚¹ãƒˆ</param>
    /// <param name="resource">çŠ¶æ…‹ã‚’é·ç§»ã•ã›ãŸã„ãƒªã‚½ãƒ¼ã‚¹</param>
    /// <param name="currentState">ç¾åœ¨ã®ãƒªã‚½ãƒ¼ã‚¹çŠ¶æ…‹</param>
    /// <param name="requiredState">å¿…è¦ãªãƒªã‚½ãƒ¼ã‚¹çŠ¶æ…‹</param>
    void EnsureResourceState(Microsoft::WRL::ComPtr<ID3D12GraphicsCommandList> cmdList, ID3D12Resource* resource, D3D12_RESOURCE_STATES& currentState, D3D12_RESOURCE_STATES requiredState);

protected:

    DirectXCommon* dxCommon_ = nullptr;
    SrvManager* srvManager_ = nullptr;

    Microsoft::WRL::ComPtr<ID3D12RootSignature> rootSignature_;
    Microsoft::WRL::ComPtr<ID3D12PipelineState> pipelineState_;
};


============================================================
File Path: project/gameEngine/base/postEffect/BoxFilterPass.cpp
============================================================
#include "BoxFilterPass.h"

#include "../DirectXCommon.h"
#include "../SrvManager.h"

void BoxFilterPass::Initialize(DirectXCommon* dxCommon, SrvManager* srvManager, const std::wstring& vsPath, const std::wstring& psPath)
{
    BasePostEffectPass::Initialize(dxCommon, srvManager, vsPath, psPath);

    constantBuffer_ = dxCommon->CreateUploadBuffer(sizeof(cbData_));

    HRESULT hr = constantBuffer_->Map(0, nullptr, reinterpret_cast<void**>(&mappedCB_));
    assert(SUCCEEDED(hr) && "Failed to map constant buffer");
    hr;
}

void BoxFilterPass::Draw(ID3D12GraphicsCommandList* cmdList, D3D12_GPU_DESCRIPTOR_HANDLE inputSrvHandle, ID3D12Resource* inputResource, D3D12_RESOURCE_STATES& currentState)
{
    currentState;
    inputResource;

    if (!isActive_)
    {
        return;
    }

    // CBV(å®šæ•°ãƒãƒƒãƒ•ã‚¡)ã®ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰ç­‰
    UpdateConstantBuffer();

    cmdList->SetPipelineState(pipelineState_.Get());
    cmdList->SetGraphicsRootSignature(rootSignature_.Get());
    cmdList->IASetPrimitiveTopology(D3D_PRIMITIVE_TOPOLOGY_TRIANGLELIST);

    ID3D12DescriptorHeap* heaps[] = {
        srvManager_->GetHeap().Get(),
        dxCommon_->GetSamplerHeap().Get()
    };
    cmdList->SetDescriptorHeaps(_countof(heaps), heaps);

    cmdList->SetGraphicsRootDescriptorTable(0, inputSrvHandle);
    cmdList->SetGraphicsRootDescriptorTable(1, dxCommon_->GetSamplerHandle());
    cmdList->SetGraphicsRootConstantBufferView(2, constantBuffer_->GetGPUVirtualAddress());

    cmdList->DrawInstanced(3, 1, 0, 0);
}

void BoxFilterPass::UpdateConstantBuffer()
{
    if (mappedCB_)
    {
        *mappedCB_ = cbData_;
    }
}


============================================================
File Path: project/gameEngine/base/postEffect/BoxFilterPass.h
============================================================
#pragma once

#include "BasePostEffectPass.h"

#include <d3d12.h>
#include <wrl/client.h>
#include <string>

/// <summary>
/// ãƒœãƒƒã‚¯ã‚¹ãƒ•ã‚£ãƒ«ã‚¿
/// é©åº¦ã«ã¼ã‹ã™ã“ã¨ã§ã‚¸ãƒ£ã‚®ãƒ¼ã‚’ç›®ç«‹ãŸãªãã™ã‚‹
/// </summary>
class BoxFilterPass : public BasePostEffectPass
{
public:

	/// <summary>
	/// åˆæœŸåŒ–
	/// </summary>
	/// <param name="dxCommon">DirectXå…±é€šæ©Ÿèƒ½ç®¡ç†ã‚¯ãƒ©ã‚¹ã¸ã®ãƒã‚¤ãƒ³ã‚¿</param>
	/// <param name="srvManager">SRVç®¡ç†ã‚¯ãƒ©ã‚¹ã¸ã®ãƒã‚¤ãƒ³ã‚¿</param>
	/// <param name="vsPath">é ‚ç‚¹ã‚·ã‚§ãƒ¼ãƒ€ãƒ•ã‚¡ã‚¤ãƒ«ã®ãƒ‘ã‚¹</param>
	/// <param name="psPath">ãƒ”ã‚¯ã‚»ãƒ«ã‚·ã‚§ãƒ¼ãƒ€ãƒ•ã‚¡ã‚¤ãƒ«ã®ãƒ‘ã‚¹</param>
	void Initialize(DirectXCommon* dxCommon, SrvManager* srvManager, const std::wstring& vsPath, const std::wstring& psPath) override;
	
	/// <summary>
	/// æç”»
	/// </summary>
	/// <param name="cmdList">æç”»ã‚³ãƒžãƒ³ãƒ‰ãƒªã‚¹ãƒˆ</param>
	/// <param name="inputSrvHandle">å…¥åŠ›ãƒ†ã‚¯ã‚¹ãƒãƒ£ã®SRVãƒãƒ³ãƒ‰ãƒ«</param>
	/// <param name="inputResource">å…¥åŠ›ãƒªã‚½ãƒ¼ã‚¹</param>
	/// <param name="currentState">å…¥åŠ›ãƒªã‚½ãƒ¼ã‚¹ã®ç¾åœ¨ã®çŠ¶æ…‹</param>
	void Draw(ID3D12GraphicsCommandList* cmdList, D3D12_GPU_DESCRIPTOR_HANDLE inputSrvHandle, ID3D12Resource* inputResource, D3D12_RESOURCE_STATES& currentState) override;
	
	/// <summary>
	/// ãƒ‘ã‚¹åå–å¾—
	/// </summary>
	/// <returns></returns>
	std::string GetName() const override { return "BoxFilter"; }
	
	/// <summary>
	/// å®šæ•°ãƒãƒƒãƒ•ã‚¡ã®æ›´æ–°
	/// </summary>
	void UpdateConstantBuffer();

public: // ã‚»ãƒƒã‚¿ãƒ¼

	/// <summary>
	/// ã¼ã‹ã—å¼·åº¦è¨­å®š
	/// </summary>
	/// <param name="intensity">ã¼ã‹ã—ã®å¼·åº¦(0.0fä»¥ä¸Šã®å€¤)</param>
	void SetIntensity(float intensity) { cbData_.intensity = intensity; }

private:

	struct BoxFilterCB {
		float intensity;
		float padding[3];
	};

	BoxFilterCB cbData_ = {};
	// GPUä¸Šã®å®šæ•°ãƒãƒƒãƒ•ã‚¡ãƒªã‚½ãƒ¼ã‚¹
	Microsoft::WRL::ComPtr<ID3D12Resource> constantBuffer_;
	// ãƒžãƒƒãƒ—ã•ã‚ŒãŸCPUãƒã‚¤ãƒ³ã‚¿ï¼ˆcbData_ã‚’æ›¸ãè¾¼ã‚€å…ˆï¼‰
	BoxFilterCB* mappedCB_ = nullptr;

};



============================================================
File Path: project/gameEngine/base/postEffect/GaussianFilterPass.cpp
============================================================
#include "GaussianFilterPass.h"

#include "../DirectXCommon.h"
#include "../SrvManager.h"

void GaussianFilterPass::Initialize(DirectXCommon* dxCommon, SrvManager* srvManager, const std::wstring& vsPath, const std::wstring& psPath)
{
    BasePostEffectPass::Initialize(dxCommon, srvManager, vsPath, psPath);

    constantBuffer_ = dxCommon->CreateUploadBuffer(sizeof(cbData_));

    HRESULT hr = constantBuffer_->Map(0, nullptr, reinterpret_cast<void**>(&mappedCB_));
    assert(SUCCEEDED(hr) && "Failed to map constant buffer");
    hr;

	cbData_.intensity = 3.0f; // åˆæœŸå€¤
}

void GaussianFilterPass::Draw(ID3D12GraphicsCommandList* cmdList, D3D12_GPU_DESCRIPTOR_HANDLE inputSrvHandle, ID3D12Resource* inputResource, D3D12_RESOURCE_STATES& currentState)
{
    currentState;
    inputResource;

    if (!isActive_)
    {
        return;
    }

    // CBV(å®šæ•°ãƒãƒƒãƒ•ã‚¡)ã®ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰ç­‰
    UpdateConstantBuffer();

    cmdList->SetPipelineState(pipelineState_.Get());
    cmdList->SetGraphicsRootSignature(rootSignature_.Get());
    cmdList->IASetPrimitiveTopology(D3D_PRIMITIVE_TOPOLOGY_TRIANGLELIST);

    ID3D12DescriptorHeap* heaps[] = {
    srvManager_->GetHeap().Get(),
    dxCommon_->GetSamplerHeap().Get()
    };
    cmdList->SetDescriptorHeaps(_countof(heaps), heaps);

    cmdList->SetGraphicsRootDescriptorTable(0, inputSrvHandle);
    cmdList->SetGraphicsRootDescriptorTable(1, dxCommon_->GetSamplerHandle());
    cmdList->SetGraphicsRootConstantBufferView(2, constantBuffer_->GetGPUVirtualAddress());

    cmdList->DrawInstanced(3, 1, 0, 0);
}

void GaussianFilterPass::UpdateConstantBuffer()
{
    if (mappedCB_)
    {
        *mappedCB_ = cbData_;
    }
}


============================================================
File Path: project/gameEngine/base/postEffect/GaussianFilterPass.h
============================================================
#pragma once

#include "BasePostEffectPass.h"

#include <d3d12.h>
#include <wrl/client.h>
#include <string>

/// <summary>
/// ã‚¬ã‚¦ã‚·ã‚¢ãƒ³ãƒ•ã‚£ãƒ«ã‚¿
/// ç”»é¢ã‚’ã¼ã‹ã™ã‚¨ãƒ•ã‚§ã‚¯ãƒˆ
/// </summary>
class GaussianFilterPass : public BasePostEffectPass
{
public:

	/// <summary>
	/// åˆæœŸåŒ–
	/// </summary>
	/// <param name="dxCommon">DirectXå…±é€šæ©Ÿèƒ½ç®¡ç†ã‚¯ãƒ©ã‚¹ã¸ã®ãƒã‚¤ãƒ³ã‚¿</param>
	/// <param name="srvManager">ã‚·ã‚§ãƒ¼ãƒ€ãƒªã‚½ãƒ¼ã‚¹ãƒ“ãƒ¥ãƒ¼ç®¡ç†ã‚¯ãƒ©ã‚¹ã¸ã®ãƒã‚¤ãƒ³ã‚¿</param>
	/// <param name="vsPath">é ‚ç‚¹ã‚·ã‚§ãƒ¼ãƒ€ãƒ•ã‚¡ã‚¤ãƒ«ã®ãƒ‘ã‚¹</param>
	/// <param name="psPath">ãƒ”ã‚¯ã‚»ãƒ«ã‚·ã‚§ãƒ¼ãƒ€ãƒ•ã‚¡ã‚¤ãƒ«ã®ãƒ‘ã‚¹</param>
	void Initialize(DirectXCommon* dxCommon, SrvManager* srvManager, const std::wstring& vsPath, const std::wstring& psPath) override;
	
	/// <summary>
	/// æç”»
	/// </summary>
	/// <param name="cmdList">æç”»ã‚³ãƒžãƒ³ãƒ‰ãƒªã‚¹ãƒˆ</param>
	/// <param name="inputSrvHandle">å…¥åŠ›ãƒ†ã‚¯ã‚¹ãƒãƒ£ã®SRVãƒãƒ³ãƒ‰ãƒ«</param>
	/// <param name="inputResource">å…¥åŠ›ãƒªã‚½ãƒ¼ã‚¹</param>
	/// <param name="currentState">å…¥åŠ›ãƒªã‚½ãƒ¼ã‚¹ã®ç¾åœ¨ã®çŠ¶æ…‹</param>
	void Draw(ID3D12GraphicsCommandList* cmdList, D3D12_GPU_DESCRIPTOR_HANDLE inputSrvHandle, ID3D12Resource* inputResource, D3D12_RESOURCE_STATES& currentState) override;
	
	/// <summary>
	/// ãƒ‘ã‚¹åå–å¾—
	/// </summary>
	/// <returns>ãƒ‘ã‚¹å</returns>
	std::string GetName() const override { return "GaussianFilter"; }
	
	/// <summary>
	/// å®šæ•°ãƒãƒƒãƒ•ã‚¡æ›´æ–°
	/// </summary>
	void UpdateConstantBuffer();

public: // ã‚»ãƒƒã‚¿ãƒ¼

	/// <summary>
	/// å¼·åº¦è¨­å®š
	/// </summary>
	/// <param name="intensity">å¼·åº¦</param>
	void SetIntensity(float intensity) { cbData_.intensity = intensity; }

private:

	struct GaussianFilterCB {
		float intensity;
		float padding[3];
	};

	GaussianFilterCB cbData_ = {};
	// GPUä¸Šã®å®šæ•°ãƒãƒƒãƒ•ã‚¡ãƒªã‚½ãƒ¼ã‚¹
	Microsoft::WRL::ComPtr<ID3D12Resource> constantBuffer_;
	// ãƒžãƒƒãƒ—ã•ã‚ŒãŸCPUãƒã‚¤ãƒ³ã‚¿ï¼ˆcbData_ã‚’æ›¸ãè¾¼ã‚€å…ˆï¼‰
	GaussianFilterCB* mappedCB_ = nullptr;

};



============================================================
File Path: project/gameEngine/base/postEffect/GrayscalePass.cpp
============================================================
#include "GrayscalePass.h"

#include "../DirectXCommon.h"
#include "../SrvManager.h"

void GrayscalePass::Initialize(DirectXCommon* dxCommon, SrvManager* srvManager, const std::wstring& vsPath, const std::wstring& psPath)
{
    BasePostEffectPass::Initialize(dxCommon, srvManager, vsPath, psPath);

    constantBuffer_ = dxCommon->CreateUploadBuffer(sizeof(cbData_));

    HRESULT hr = constantBuffer_->Map(0, nullptr, reinterpret_cast<void**>(&mappedCB_));
    assert(SUCCEEDED(hr) && "Failed to map constant buffer");
    hr;

}

void GrayscalePass::Draw(ID3D12GraphicsCommandList* cmdList, D3D12_GPU_DESCRIPTOR_HANDLE inputSrvHandle, ID3D12Resource* inputResource, D3D12_RESOURCE_STATES& currentState)
{
    currentState;
    inputResource;

    if (!isActive_)
    {
        return;
    }
    
    // CBV(å®šæ•°ãƒãƒƒãƒ•ã‚¡)ã®ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰ç­‰
    UpdateConstantBuffer();

    cmdList->SetPipelineState(pipelineState_.Get());
    cmdList->SetGraphicsRootSignature(rootSignature_.Get());
    cmdList->IASetPrimitiveTopology(D3D_PRIMITIVE_TOPOLOGY_TRIANGLELIST);

    ID3D12DescriptorHeap* heaps[] = { 
        srvManager_->GetHeap().Get(),
        dxCommon_->GetSamplerHeap().Get() 
    };
    cmdList->SetDescriptorHeaps(_countof(heaps), heaps);

    cmdList->SetGraphicsRootDescriptorTable(0, inputSrvHandle);
    cmdList->SetGraphicsRootDescriptorTable(1, dxCommon_->GetSamplerHandle());
    cmdList->SetGraphicsRootConstantBufferView(2, constantBuffer_->GetGPUVirtualAddress());

    cmdList->DrawInstanced(3, 1, 0, 0);
}

void GrayscalePass::UpdateConstantBuffer()
{
    if (mappedCB_) 
    {
        *mappedCB_ = cbData_;
    }
}


============================================================
File Path: project/gameEngine/base/postEffect/GrayscalePass.h
============================================================
#pragma once

#include "BasePostEffectPass.h"

#include <d3d12.h>
#include <wrl/client.h>
#include <string>

/// <summary>
/// ã‚°ãƒ¬ãƒ¼ã‚¹ã‚±ãƒ¼ãƒ«ã‚¨ãƒ•ã‚§ã‚¯ãƒˆ
/// ã‚°ãƒ¬ãƒ¼ã‚¹ã‚±ãƒ¼ãƒ«åŒ–ã™ã‚‹ã‹ã©ã†ã‹ã‚’åˆ‡ã‚Šæ›¿ãˆå¯èƒ½
/// </summary>
class GrayscalePass : public BasePostEffectPass
{
public:
 
	/// <summary>
	/// åˆæœŸåŒ–
	/// </summary>
	/// <param name="dxCommon">DirectXå…±é€šæ©Ÿèƒ½ç®¡ç†ã‚¯ãƒ©ã‚¹ã¸ã®ãƒã‚¤ãƒ³ã‚¿</param>
	/// <param name="srvManager">ã‚·ã‚§ãƒ¼ãƒ€ãƒªã‚½ãƒ¼ã‚¹ãƒ“ãƒ¥ãƒ¼ç®¡ç†ã‚¯ãƒ©ã‚¹ã¸ã®ãƒã‚¤ãƒ³ã‚¿</param>
	/// <param name="vsPath">é ‚ç‚¹ã‚·ã‚§ãƒ¼ãƒ€ãƒ•ã‚¡ã‚¤ãƒ«ã®ãƒ‘ã‚¹</param>
	/// <param name="psPath">ãƒ”ã‚¯ã‚»ãƒ«ã‚·ã‚§ãƒ¼ãƒ€ãƒ•ã‚¡ã‚¤ãƒ«ã®ãƒ‘ã‚¹</param>
    void Initialize(DirectXCommon* dxCommon, SrvManager* srvManager, const std::wstring& vsPath, const std::wstring& psPath) override;
    
	/// <summary>
	/// æç”»
	/// </summary>
	/// <param name="cmdList">æç”»ã‚³ãƒžãƒ³ãƒ‰ãƒªã‚¹ãƒˆ</param>
	/// <param name="inputSrvHandle">å…¥åŠ›ãƒ†ã‚¯ã‚¹ãƒãƒ£ã®SRVãƒãƒ³ãƒ‰ãƒ«</param>
	/// <param name="inputResource">å…¥åŠ›ãƒªã‚½ãƒ¼ã‚¹</param>
	/// <param name="currentState">å…¥åŠ›ãƒªã‚½ãƒ¼ã‚¹ã®ç¾åœ¨ã®çŠ¶æ…‹</param>
    void Draw(ID3D12GraphicsCommandList* cmdList, D3D12_GPU_DESCRIPTOR_HANDLE inputSrvHandle, ID3D12Resource* inputResource, D3D12_RESOURCE_STATES& currentState) override;
    
	/// <summary>
	/// ãƒ‘ã‚¹åã®å–å¾—
	/// </summary>
	/// <returns>ãƒ‘ã‚¹å</returns>
    std::string GetName() const override { return "Grayscale"; }
    
	/// <summary>
	/// å®šæ•°ãƒãƒƒãƒ•ã‚¡ã®æ›´æ–°
	/// </summary>
    void UpdateConstantBuffer();

public: // ã‚»ãƒƒã‚¿ãƒ¼

	/// <summary>
	/// ã‚°ãƒ¬ãƒ¼ã‚¹ã‚±ãƒ¼ãƒ«ä½¿ç”¨è¨­å®š
	/// </summary>
	/// <param name="enable">æœ‰åŠ¹åŒ–ãƒ•ãƒ©ã‚°</param>
	void SetUseGrayscale(uint32_t enable) { cbData_.useGrayscale = enable; }

private:
    struct GrayscaleCB {
        uint32_t useGrayscale;
        float padding[3];
    };

    GrayscaleCB cbData_ = {};

    // GPUä¸Šã®å®šæ•°ãƒãƒƒãƒ•ã‚¡ãƒªã‚½ãƒ¼ã‚¹
    Microsoft::WRL::ComPtr<ID3D12Resource> constantBuffer_;  
    // ãƒžãƒƒãƒ—ã•ã‚ŒãŸCPUãƒã‚¤ãƒ³ã‚¿ï¼ˆcbData_ã‚’æ›¸ãè¾¼ã‚€å…ˆï¼‰
    GrayscaleCB* mappedCB_ = nullptr;  

};


============================================================
File Path: project/gameEngine/base/postEffect/IPostEffectPass.cpp
============================================================
#include "IPostEffectPass.h"

#include "../DirectXCommon.h"
#include "../SrvManager.h"

============================================================
File Path: project/gameEngine/base/postEffect/IPostEffectPass.h
============================================================
#pragma once

#include <wrl.h>
#include <d3d12.h>
#include <string>

class DirectXCommon;
class SrvManager;

/// <summary>
/// ãƒã‚¹ãƒˆã‚¨ãƒ•ã‚§ã‚¯ãƒˆãƒ‘ã‚¹ã®ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹
/// ç¶™æ‰¿ã—ã¦å„ãƒã‚¹ãƒˆã‚¨ãƒ•ã‚§ã‚¯ãƒˆãƒ‘ã‚¹ã‚’å®Ÿè£…ã™ã‚‹
/// </summary>
class IPostEffectPass
{
public:

	// ãƒ‡ã‚¹ãƒˆãƒ©ã‚¯ã‚¿
    virtual ~IPostEffectPass() = default;
   
	/// <summary>
	/// åˆæœŸåŒ–
	/// </summary>
	/// <param name="dxCommon">DirectXå…±é€šæ©Ÿèƒ½ç®¡ç†ã‚¯ãƒ©ã‚¹ã¸ã®ãƒã‚¤ãƒ³ã‚¿</param>
	/// <param name="srvManager">ã‚·ã‚§ãƒ¼ãƒ€ãƒªã‚½ãƒ¼ã‚¹ãƒ“ãƒ¥ãƒ¼ç®¡ç†ã‚¯ãƒ©ã‚¹ã¸ã®ãƒã‚¤ãƒ³ã‚¿</param>
	/// <param name="vsPath">é ‚ç‚¹ã‚·ã‚§ãƒ¼ãƒ€ãƒ•ã‚¡ã‚¤ãƒ«ã®ãƒ‘ã‚¹</param>
	/// <param name="psPath">ãƒ”ã‚¯ã‚»ãƒ«ã‚·ã‚§ãƒ¼ãƒ€ãƒ•ã‚¡ã‚¤ãƒ«ã®ãƒ‘ã‚¹</param>
    virtual void Initialize(DirectXCommon* dxCommon, SrvManager* srvManager, const std::wstring& vsPath, const std::wstring& psPath) = 0;
    
	/// <summary>
	/// æç”»
	/// </summary>
	/// <param name="cmdList">æç”»ã‚³ãƒžãƒ³ãƒ‰ãƒªã‚¹ãƒˆ</param>
	/// <param name="inputSrvHandle">å…¥åŠ›ãƒ†ã‚¯ã‚¹ãƒãƒ£ã®SRVãƒãƒ³ãƒ‰ãƒ«</param>
	/// <param name="inputResource">å…¥åŠ›ãƒªã‚½ãƒ¼ã‚¹</param>
	/// <param name="currentState">å…¥åŠ›ãƒªã‚½ãƒ¼ã‚¹ã®ç¾åœ¨ã®çŠ¶æ…‹</param>
    virtual void Draw(ID3D12GraphicsCommandList* cmdList, D3D12_GPU_DESCRIPTOR_HANDLE inputSrvHandle, ID3D12Resource* inputResource, D3D12_RESOURCE_STATES& currentState) = 0;
  
public: // ã‚»ãƒƒã‚¿ãƒ¼
    
	/// <summary>
	/// ã‚¢ã‚¯ãƒ†ã‚£ãƒ–è¨­å®š
	/// </summary>
	/// <param name="active">ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ãƒ•ãƒ©ã‚°</param>
    virtual void SetActive(bool active) { isActive_ = active; }
    
    
public: // ã‚²ãƒƒã‚¿ãƒ¼

	/// <summary>
	/// ã‚¢ã‚¯ãƒ†ã‚£ãƒ–å–å¾—
	/// </summary>
	/// <returns>ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ãƒ•ãƒ©ã‚°</returns>
    virtual bool IsActive() const { return isActive_; }
   
	/// <summary>
	/// ãƒ‘ã‚¹åå–å¾—
	/// </summary>
	/// <returns>ãƒ‘ã‚¹å</returns>
	virtual std::string GetName() const = 0;

protected:

    bool isActive_ = true;

};



============================================================
File Path: project/gameEngine/base/postEffect/NoneEffectPass.cpp
============================================================
#include "NoneEffectPass.h"

#include "../DirectXCommon.h"
#include "../SrvManager.h"

void NoneEffectPass::Initialize(DirectXCommon* dxCommon, SrvManager* srvManager, const std::wstring& vsPath, const std::wstring& psPath)
{
	BasePostEffectPass::Initialize(dxCommon, srvManager, vsPath, psPath);
	
	constantBuffer_ = dxCommon->CreateUploadBuffer(sizeof(cbData_));
	HRESULT hr = constantBuffer_->Map(0, nullptr, reinterpret_cast<void**>(&mappedCB_));
	assert(SUCCEEDED(hr) && "Failed to map constant buffer");
	hr;

	cbData_.dummy = 0.0f; // ãƒ€ãƒŸãƒ¼å€¤
}

void NoneEffectPass::Draw(ID3D12GraphicsCommandList* cmdList, D3D12_GPU_DESCRIPTOR_HANDLE inputSrvHandle, ID3D12Resource* inputResource, D3D12_RESOURCE_STATES& currentState)
{
	currentState;
	inputResource;

	if (!isActive_)
	{
		return;
	}

	// CBV(å®šæ•°ãƒãƒƒãƒ•ã‚¡)ã®ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰ç­‰
	UpdateConstantBuffer();

	cmdList->SetPipelineState(pipelineState_.Get());
	cmdList->SetGraphicsRootSignature(rootSignature_.Get());
	cmdList->IASetPrimitiveTopology(D3D_PRIMITIVE_TOPOLOGY_TRIANGLELIST);

	ID3D12DescriptorHeap* heaps[] = {
		srvManager_->GetHeap().Get(),
		dxCommon_->GetSamplerHeap().Get()
	};

	cmdList->SetDescriptorHeaps(_countof(heaps), heaps);
	cmdList->SetGraphicsRootDescriptorTable(0, inputSrvHandle);
	cmdList->SetGraphicsRootDescriptorTable(1, dxCommon_->GetSamplerHandle());
	cmdList->SetGraphicsRootConstantBufferView(2, constantBuffer_->GetGPUVirtualAddress());

	cmdList->DrawInstanced(3, 1, 0, 0);
}

void NoneEffectPass::UpdateConstantBuffer()
{
	if (mappedCB_)
	{
		*mappedCB_ = cbData_;
	}
}


============================================================
File Path: project/gameEngine/base/postEffect/NoneEffectPass.h
============================================================
#pragma once

#include "BasePostEffectPass.h"

#include <d3d12.h>
#include <wrl/client.h>
#include <string>

/// <summary>
/// ã‚¨ãƒ•ã‚§ã‚¯ãƒˆãªã—ãƒ‘ã‚¹
/// DirectXTexã‚’ä½¿ã£ã¦ãƒªã‚µã‚¤ã‚ºã™ã‚‹ã ã‘
/// </summary>
class NoneEffectPass : public BasePostEffectPass
{
public:

	/// <summary>
	/// åˆæœŸåŒ–
	/// </summary>
	/// <param name="dxCommon">DirectXå…±é€šæ©Ÿèƒ½ç®¡ç†ã‚¯ãƒ©ã‚¹ã¸ã®ãƒã‚¤ãƒ³ã‚¿</param>
	/// <param name="srvManager">ã‚·ã‚§ãƒ¼ãƒ€ãƒªã‚½ãƒ¼ã‚¹ãƒ“ãƒ¥ãƒ¼ç®¡ç†ã‚¯ãƒ©ã‚¹ã¸ã®ãƒã‚¤ãƒ³ã‚¿</param>
	/// <param name="vsPath">é ‚ç‚¹ã‚·ã‚§ãƒ¼ãƒ€ãƒ•ã‚¡ã‚¤ãƒ«ã®ãƒ‘ã‚¹</param>
	/// <param name="psPath">ãƒ”ã‚¯ã‚»ãƒ«ã‚·ã‚§ãƒ¼ãƒ€ãƒ•ã‚¡ã‚¤ãƒ«ã®ãƒ‘ã‚¹</param>
	void Initialize(DirectXCommon* dxCommon, SrvManager* srvManager, const std::wstring& vsPath, const std::wstring& psPath) override;
	
	/// <summary>
	/// æç”»
	/// </summary>
	/// <param name="cmdList">æç”»ã‚³ãƒžãƒ³ãƒ‰ãƒªã‚¹ãƒˆ</param>
	/// <param name="inputSrvHandle">å…¥åŠ›ãƒ†ã‚¯ã‚¹ãƒãƒ£ã®SRVãƒãƒ³ãƒ‰ãƒ«</param>
	/// <param name="inputResource">å…¥åŠ›ãƒªã‚½ãƒ¼ã‚¹</param>
	/// <param name="currentState">å…¥åŠ›ãƒªã‚½ãƒ¼ã‚¹ã®ç¾åœ¨ã®çŠ¶æ…‹</param>
	void Draw(ID3D12GraphicsCommandList* cmdList, D3D12_GPU_DESCRIPTOR_HANDLE inputSrvHandle, ID3D12Resource* inputResource, D3D12_RESOURCE_STATES& currentState) override;
	
	/// <summary>
	/// ãƒ‘ã‚¹åå–å¾—
	/// </summary>
	std::string GetName() const override { return "NoneEffect"; }
	
	/// <summary>
	/// å®šæ•°ãƒãƒƒãƒ•ã‚¡æ›´æ–°
	/// </summary>
	void UpdateConstantBuffer();


private:

	struct NoneEffectCB 
	{
		float dummy; // ä½•ã‚‚ãªã„ã®ã§ãƒ€ãƒŸãƒ¼
	};

	
	// GPUä¸Šã®å®šæ•°ãƒãƒƒãƒ•ã‚¡ãƒªã‚½ãƒ¼ã‚¹
	Microsoft::WRL::ComPtr<ID3D12Resource> constantBuffer_;
	// ãƒžãƒƒãƒ—ã•ã‚ŒãŸCPUãƒã‚¤ãƒ³ã‚¿ï¼ˆcbData_ã‚’æ›¸ãè¾¼ã‚€å…ˆï¼‰
	NoneEffectCB* mappedCB_ = nullptr;
	// å®šæ•°ãƒãƒƒãƒ•ã‚¡ã®ãƒ‡ãƒ¼ã‚¿
	NoneEffectCB cbData_ = {};
	
};



============================================================
File Path: project/gameEngine/base/postEffect/PostEffectManager.cpp
============================================================
#include "PostEffectManager.h"

PostEffectManager* PostEffectManager::GetInstance()
{
    static PostEffectManager instance;
    return &instance;
}

void PostEffectManager::AddPass(const std::string& name, std::unique_ptr<IPostEffectPass> pass)
{
    pass->SetActive(false);
    passes_[name] = std::move(pass);
}

void PostEffectManager::SetActiveEffect(const std::string& name, bool active)
{
    auto it = passes_.find(name);

    if (it != passes_.end())
    {
        it->second->SetActive(active);
    }
}

void PostEffectManager::SetActiveEffects(const std::vector<std::string>& names) 
{
    for (auto& [n, pass] : passes_) 
    {
        pass->SetActive(std::find(names.begin(), names.end(), n) != names.end());
    }
}

void PostEffectManager::DrawAll(Microsoft::WRL::ComPtr<ID3D12GraphicsCommandList> cmdList, D3D12_GPU_DESCRIPTOR_HANDLE inputSrvHandle, ID3D12Resource* inputResource, D3D12_RESOURCE_STATES& currentState)
{
    bool anyActive = false;

    for (auto& [_, pass] : passes_)
    {
        if (pass->IsActive()) 
        {
            pass->Draw(cmdList.Get(), inputSrvHandle, inputResource, currentState);
            anyActive = true;
        }
    }

    if (!anyActive && noneEffect_) {
        noneEffect_->Draw(cmdList.Get(), inputSrvHandle, inputResource, currentState);
    }
}

void PostEffectManager::SetNoneEffect(std::unique_ptr<IPostEffectPass> pass)
{
    noneEffect_ = std::move(pass);
}


============================================================
File Path: project/gameEngine/base/postEffect/PostEffectManager.h
============================================================
#pragma once

#include "IPostEffectPass.h"

#include <unordered_map>
#include <string>
#include <memory>
#include <vector>

/// <summary>
/// ãƒã‚¹ãƒˆã‚¨ãƒ•ã‚§ã‚¯ãƒˆãƒžãƒãƒ¼ã‚¸ãƒ£ãƒ¼
/// ãƒã‚¹ãƒˆã‚¨ãƒ•ã‚§ã‚¯ãƒˆã®ãƒ‘ã‚¹ã‚’ç®¡ç†ã—ã€æç”»ã‚’è¡Œã†
/// </summary>
class PostEffectManager 
{
public:

    static PostEffectManager* GetInstance();

    /// <summary>
	/// ãƒã‚¹ãƒˆã‚¨ãƒ•ã‚§ã‚¯ãƒˆãƒ‘ã‚¹ã®è¿½åŠ 
    /// </summary>
	/// <param name="name">ãƒ‘ã‚¹å</param>
	/// <param name="pass">ãƒã‚¹ãƒˆã‚¨ãƒ•ã‚§ã‚¯ãƒˆãƒ‘ã‚¹ã®ãƒ¦ãƒ‹ãƒ¼ã‚¯ãƒã‚¤ãƒ³ã‚¿</param>
    void AddPass(const std::string& name, std::unique_ptr<IPostEffectPass> pass);
    
	/// <summary>
	/// ã‚¢ã‚¯ãƒ†ã‚£ãƒ–è¨­å®š
    /// 1ã¤ã®ã¿æœ‰åŠ¹
    /// </summary>
	/// <param name="name">ãƒ‘ã‚¹å</param>
	/// <param name="active">ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ãƒ•ãƒ©ã‚°</param>
    void SetActiveEffect(const std::string& name, bool active);
    
    /// <summary>
	/// ã‚¢ã‚¯ãƒ†ã‚£ãƒ–è¨­å®š
    /// è¤‡æ•°å¯
    /// </summary>
	/// <param name="names">ãƒ‘ã‚¹åãƒªã‚¹ãƒˆ</param>
    void SetActiveEffects(const std::vector<std::string>& names); 
    
	/// <summary>
	/// å…¨ãƒã‚¹ãƒˆã‚¨ãƒ•ã‚§ã‚¯ãƒˆãƒ‘ã‚¹æç”»
	/// </summary>
	/// <param name="cmdList">æç”»ã‚³ãƒžãƒ³ãƒ‰ãƒªã‚¹ãƒˆ</param>
	/// <param name="inputSrvHandle">å…¥åŠ›ãƒ†ã‚¯ã‚¹ãƒãƒ£ã®SRVãƒãƒ³ãƒ‰ãƒ«</param>
	/// <param name="inputResource">å…¥åŠ›ãƒªã‚½ãƒ¼ã‚¹</param>
	/// <param name="currentState">å…¥åŠ›ãƒªã‚½ãƒ¼ã‚¹ã®ç¾åœ¨ã®çŠ¶æ…‹</param>
    void DrawAll(Microsoft::WRL::ComPtr<ID3D12GraphicsCommandList> cmdList, D3D12_GPU_DESCRIPTOR_HANDLE inputSrvHandle, ID3D12Resource* inputResource, D3D12_RESOURCE_STATES& currentState);

	/// <summary>
	/// Noneã‚¨ãƒ•ã‚§ã‚¯ãƒˆè¨­å®š
	/// ä½•ã‚‚åŠ¹æžœã‚’ã‹ã‘ãªã„ãƒ‘ã‚¹
	/// </summary>
	/// <param name="pass">ãƒã‚¹ãƒˆã‚¨ãƒ•ã‚§ã‚¯ãƒˆãƒ‘ã‚¹ã®ãƒ¦ãƒ‹ãƒ¼ã‚¯ãƒã‚¤ãƒ³ã‚¿</param>
    void SetNoneEffect(std::unique_ptr<IPostEffectPass> pass);

    template<typename T>
    T* GetPassAs(const std::string& name)
    {
        auto it = passes_.find(name);
        if (it != passes_.end()) {
            return dynamic_cast<T*>(it->second.get());
        }
        return nullptr;
    }

private:

    std::unordered_map<std::string, std::unique_ptr<IPostEffectPass>> passes_;

    std::unique_ptr<IPostEffectPass> noneEffect_;

};


============================================================
File Path: project/gameEngine/base/postEffect/VignettePass.cpp
============================================================
#include "VignettePass.h"

#include "../DirectXCommon.h"
#include "../SrvManager.h"

void VignettePass::Initialize(DirectXCommon* dxCommon, SrvManager* srvManager, const std::wstring& vsPath, const std::wstring& psPath) 
{
    BasePostEffectPass::Initialize(dxCommon, srvManager, vsPath, psPath);

    constantBuffer_ = dxCommon->CreateUploadBuffer(sizeof(VignetteCB));
    HRESULT hr = constantBuffer_->Map(0, nullptr, reinterpret_cast<void**>(&mappedCB_));
    assert(SUCCEEDED(hr) && "Failed to map constant buffer");
    hr;

}

void VignettePass::Draw(ID3D12GraphicsCommandList* cmdList, D3D12_GPU_DESCRIPTOR_HANDLE inputSrvHandle, ID3D12Resource* inputResource, D3D12_RESOURCE_STATES& currentState)
{
    currentState;
    inputResource;

    if (!isActive_)
    {
        return;
    }

    // CB ã®æ›´æ–°
    UpdateConstantBuffer();

    // æç”»ã‚³ãƒžãƒ³ãƒ‰è¨­å®š
    cmdList->SetPipelineState(pipelineState_.Get());
    cmdList->SetGraphicsRootSignature(rootSignature_.Get());
    cmdList->IASetPrimitiveTopology(D3D_PRIMITIVE_TOPOLOGY_TRIANGLELIST);

    ID3D12DescriptorHeap* heaps[] = {
        srvManager_->GetHeap().Get(),
        dxCommon_->GetSamplerHeap().Get()
    };
    cmdList->SetDescriptorHeaps(_countof(heaps), heaps);

    cmdList->SetGraphicsRootDescriptorTable(0, inputSrvHandle);
    cmdList->SetGraphicsRootDescriptorTable(1, dxCommon_->GetSamplerHandle());
    cmdList->SetGraphicsRootConstantBufferView(2, constantBuffer_->GetGPUVirtualAddress());

    cmdList->DrawInstanced(3, 1, 0, 0);
}

void VignettePass::UpdateConstantBuffer()
{
    if (mappedCB_) 
    {
        *mappedCB_ = cbData_;
    }
}

============================================================
File Path: project/gameEngine/base/postEffect/VignettePass.h
============================================================
#pragma once

#include "BasePostEffectPass.h"

#include <d3d12.h>
#include <wrl/client.h>
#include <string>
#include <MyMath.h>

/// <summary>
/// ãƒ“ãƒãƒƒãƒˆå‡¦ç†
/// ã‚«ãƒ¡ãƒ©ã®å‘¨è¾ºã‚’æš—ãã™ã‚‹
/// </summary>
class VignettePass :public BasePostEffectPass 
{
public:
   
    /// <summary>
	/// åˆæœŸåŒ–
    /// </summary>
	/// <param name="dxCommon">DirectXå…±é€šæ©Ÿèƒ½ç®¡ç†ã‚¯ãƒ©ã‚¹ã¸ã®ãƒã‚¤ãƒ³ã‚¿</param>
	/// <param name="srvManager">ã‚·ã‚§ãƒ¼ãƒ€ãƒªã‚½ãƒ¼ã‚¹ãƒ“ãƒ¥ãƒ¼ç®¡ç†ã‚¯ãƒ©ã‚¹ã¸ã®ãƒã‚¤ãƒ³ã‚¿</param>
	/// <param name="vsPath">é ‚ç‚¹ã‚·ã‚§ãƒ¼ãƒ€ãƒ•ã‚¡ã‚¤ãƒ«ã®ãƒ‘ã‚¹</param>
	/// <param name="psPath">ãƒ”ã‚¯ã‚»ãƒ«ã‚·ã‚§ãƒ¼ãƒ€ãƒ•ã‚¡ã‚¤ãƒ«ã®ãƒ‘ã‚¹</param>
    void Initialize(DirectXCommon* dxCommon, SrvManager* srvManager, const std::wstring& vsPath, const std::wstring& psPath) override;
    
	/// <summary>
	/// æç”»
	/// </summary>
	/// <param name="cmdList">æç”»ã‚³ãƒžãƒ³ãƒ‰ãƒªã‚¹ãƒˆ</param>
	/// <param name="inputSrvHandle">å…¥åŠ›ãƒ†ã‚¯ã‚¹ãƒãƒ£ã®SRVãƒãƒ³ãƒ‰ãƒ«</param>
	/// <param name="inputResource">å…¥åŠ›ãƒªã‚½ãƒ¼ã‚¹</param>
	/// <param name="currentState">å…¥åŠ›ãƒªã‚½ãƒ¼ã‚¹ã®ç¾åœ¨ã®çŠ¶æ…‹</param>
    void Draw(ID3D12GraphicsCommandList* cmdList, D3D12_GPU_DESCRIPTOR_HANDLE inputSrvHandle, ID3D12Resource* inputResource, D3D12_RESOURCE_STATES& currentState) override;

    /// <summary>
	/// ã‚³ãƒ³ã‚¹ã‚¿ãƒ³ãƒˆãƒãƒƒãƒ•ã‚¡æ›´æ–°
    /// </summary>
    void UpdateConstantBuffer();

public: // ã‚»ãƒƒã‚¿ãƒ¼

	/// <summary>
	/// å¼·ã•è¨­å®š
	/// </summary>
	/// <param name="strength">å¼·ã•</param>
    void SetStrength(float strength) { cbData_.strength = strength; }

public: // ã‚²ãƒƒã‚¿ãƒ¼

	/// <summary>
	/// ã‚¨ãƒ•ã‚§ã‚¯ãƒˆåå–å¾—
	/// </summary>
    std::string GetName() const override { return "Vignette"; }


private:

    struct VignetteCB
    {
        float strength = 1.0f;
        float padding[3];
    };

    VignetteCB cbData_ = {};
    Microsoft::WRL::ComPtr<ID3D12Resource> constantBuffer_;
    VignetteCB* mappedCB_ = nullptr;

};



============================================================
File Path: project/gameEngine/baseScene/AbstractSceneFactory.h
============================================================
#pragma once

#include "BaseScene.h"
#include <memory>
#include <string>

/// <summary>
/// ã‚·ãƒ¼ãƒ³ç”Ÿæˆã®æŠ½è±¡ã‚¯ãƒ©ã‚¹
/// ç¶™æ‰¿å…ˆã§CreateSceneã‚’å®Ÿè£…ã—ã¦ã‚·ãƒ¼ãƒ³ã‚’ç”Ÿæˆã™ã‚‹
/// </summary>
class AbstractSceneFactory
{
public:

	// ä»®æƒ³ãƒ‡ã‚¹ãƒˆãƒ©ã‚¯ã‚¿
	virtual ~AbstractSceneFactory() = default;

	/// <summary>
	/// ã‚·ãƒ¼ãƒ³ç”Ÿæˆ
	/// </summary>
	/// <param name="sceneName">ç”Ÿæˆã—ãŸã„ã‚·ãƒ¼ãƒ³ã®åå‰</param>
	/// <returns>ç”Ÿæˆã•ã‚ŒãŸã‚·ãƒ¼ãƒ³ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹</returns>
	virtual std::unique_ptr<BaseScene> CreateScene(const std::string& sceneName) = 0;
};

============================================================
File Path: project/gameEngine/baseScene/BaseScene.cpp
============================================================
#include "BaseScene.h"

void BaseScene::Initialize()
{
}

void BaseScene::Finalize()
{
}

void BaseScene::Update()
{
}

void BaseScene::Draw()
{
}


============================================================
File Path: project/gameEngine/baseScene/BaseScene.h
============================================================
#pragma once

class SceneManager;

/// <summary>
/// ã‚·ãƒ¼ãƒ³ã®åŸºåº•ã‚¯ãƒ©ã‚¹
/// ç¶™æ‰¿ã—ã¦ä½¿ç”¨ã™ã‚‹
/// </summary>
class BaseScene
{
public:
    // ãƒ‡ã‚¹ãƒˆãƒ©ã‚¯ã‚¿
    virtual ~BaseScene() = default;

    /// <summary>
    /// åˆæœŸåŒ–
    /// </summary>
    virtual void Initialize();

    /// <summary>
    /// çµ‚äº†
    /// </summary>
    virtual void Finalize();

    /// <summary>
    /// æ›´æ–°å‡¦ç†
    /// </summary>
    virtual void Update();

    /// <summary>
    /// æç”»å‡¦ç†
    /// </summary>
    virtual void Draw();

public:

    /// <summary>
	/// ã‚·ãƒ¼ãƒ³ãƒžãƒãƒ¼ã‚¸ãƒ£ã®ã‚»ãƒƒãƒˆ
    /// </summary>
    /// <param name="sceneManager">ã‚·ãƒ¼ãƒ³ç®¡ç†ã‚’è¡Œã†SceneManagerã®ãƒã‚¤ãƒ³ã‚¿</param>
    virtual void SetSceneManager(SceneManager* sceneManager) { sceneManager_ = sceneManager; }

protected:

    // ã‚·ãƒ¼ãƒ³ãƒžãƒãƒ¼ã‚¸ãƒ£
    SceneManager* sceneManager_ = nullptr;
};

============================================================
File Path: project/gameEngine/baseScene/MyGame.cpp
============================================================
#include "MyGame.h"

#include <thread>

void MyGame::Initialize()
{
	Framework::Initialize();

	// ã‚·ãƒ¼ãƒ³ãƒžãƒãƒ¼ã‚¸ãƒ£ã«æœ€åˆã®ã‚·ãƒ¼ãƒ³ã‚’ã‚»ãƒƒãƒˆ
	sceneFactory_ = std::make_unique<SceneFactory>();
	SceneManager::GetInstance()->SetSceneFactory(sceneFactory_.get());

	// æœ€åˆã®ã‚·ãƒ¼ãƒ³ã‚’è¨­å®š
	SceneManager::GetInstance()->ChangeScene("TITLE");


	// ãƒ¢ãƒ‡ãƒ«ã®èª­ã¿è¾¼ã¿å‡¦ç†ã‚’ã‚¹ãƒ¬ãƒƒãƒ‰ã§å®Ÿè¡Œ
	std::thread loadModelThread(&MyGame::LoadModel, this);
	std::thread loadAudioThread(&MyGame::LoadSound, this);

	// ã‚¹ãƒ¬ãƒƒãƒ‰ã®çµ‚äº†ã‚’å¾…ã¤
	loadModelThread.join(); 
	loadAudioThread.join();

	// ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã‚°ãƒ«ãƒ¼ãƒ—ã®ç”Ÿæˆ
	particleManager->CreateParticleGroup("slash", "resources/images/gradationLine.png", "plane.obj", "Ring", "Slash");
	particleManager->CreateParticleGroup("magic1Group", "resources/images/gradationLine.png", "plane.obj", "Cylinder", "Magic1");
	particleManager->CreateParticleGroup("magic2Group", "resources/images/white.png", "plane.obj", "Triangle", "Magic2");
	particleManager->CreateParticleGroup("laserGroup", "resources/images/white.png", "plane.obj", "Cylinder", "Laser");
	particleManager->CreateParticleGroup("petalGroup", "resources/images/white.png", "plane.obj", "Petal", "Petal");

	particleManager->CreateParticleGroup("homingGroup", "resources/images/white.png", "plane.obj", "Ring", "Homing");
	particleManager->CreateParticleGroup("flameGroup", "resources/images/white.png", "plane.obj", "Ring", "Flame");

	particleManager->CreateParticleGroup("explosionGroup", "resources/images/white.png", "plane.obj", "Ring", "Explosion");
	particleManager->CreateParticleGroup("vignetteGroup", "resources/images/black.png", "plane.obj", "Ring", "Wiggle");
	particleManager->CreateParticleGroup("walk", "resources/images/white.png", "plane.obj", "Cube", "Dust");
	particleManager->CreateParticleGroup("enemyWalk", "resources/images/white.png", "plane.obj", "Cube", "EnemyDust");
	particleManager->CreateParticleGroup("debuff", "resources/images/white.png", "plane.obj", "Line", "Debuff");
	particleManager->CreateParticleGroup("spark", "resources/images/white.png", "plane.obj", "Triangle", "Spark");
	particleManager->CreateParticleGroup("sparkBurst", "resources/images/white.png", "plane.obj", "Triangle", "SparkBurst");
	particleManager->CreateParticleGroup("rupture", "resources/images/white.png", "plane.obj", "Triangle", "Rupture");
	particleManager->CreateParticleGroup("goal", "resources/images/white.png", "plane.obj", "Cube", "Fountain");
	particleManager->CreateParticleGroup("HitReaction", "resources/images/white.png", "plane.obj", "Cube", "HitReaction");
	particleManager->CreateParticleGroup("BltReaction", "resources/images/gradationLine.png", "plane.obj", "Ring", "BltReaction");

	// Cylinderã‚’å‡ºã™ã¨ãã«å‘ãæŒ‡å®šã™ã‚‹
	ParticleMotion::SetDirection("UP");

	useExampleGroup_ = true;


	TextureManager::GetInstance()->LoadTexture("resources/images/studio.dds",true);
	uint32_t cubeSrvIndex = TextureManager::GetInstance()->GetTextureIndexByFilePath("resources/images/studio.dds");
	skybox->SetCubeMapSrvIndex(cubeSrvIndex);
}

void MyGame::Finalize()
{
	Microsoft::WRL::ComPtr<IDXGIDebug1> debug;
	if (SUCCEEDED(DXGIGetDebugInterface1(0, IID_PPV_ARGS(&debug))))
	{
		debug->ReportLiveObjects(DXGI_DEBUG_ALL, DXGI_DEBUG_RLO_ALL);
		debug->ReportLiveObjects(DXGI_DEBUG_APP, DXGI_DEBUG_RLO_ALL);
		debug->ReportLiveObjects(DXGI_DEBUG_D3D12, DXGI_DEBUG_RLO_ALL);
	}


	sceneFactory_.reset();

	Framework::Finalize();

}

void MyGame::Update()
{
	Framework::Update();

	// Skyboxã®æ›´æ–°
	skybox->Update();

	if (time > 9.0f)
	{
		time = 0.0f;
	}

	time += 1.0f / 60.0f;


	if (Input::GetInstance()->TriggerKey(DIK_1))
	{
		particleManager->Emit("sparkBurst", { 0.0f,2.0f,0.0f }, 3);
	}

	if (Input::GetInstance()->TriggerKey(DIK_2))
	{
		particleManager->Emit("laserGroup", { 0.0f,1.0f,0.0f }, 3);
	}

	if (Input::GetInstance()->TriggerKey(DIK_3))
	{
		particleManager->Emit("petalGroup", { 0.0f,1.0f,0.0f }, 10);
		isPetal_ = !isPetal_;
	}

	if (Input::GetInstance()->TriggerKey(DIK_4))
	{
		particleManager->Emit("homingGroup", { 0.0f,1.0f,0.0f }, 3);
		isHoming_ = !isHoming_;
	}

	if (Input::GetInstance()->TriggerKey(DIK_5))
	{
		particleManager->Emit("flameGroup", { 0.0f,1.0f,0.0f }, 5);
		isFlame_ = !isFlame_;
	}

	if (Input::GetInstance()->TriggerKey(DIK_6))
	{
		particleManager->Emit("explosionGroup", { 0.0f,1.0f,0.0f }, 3);
		isExplosion_ = !isExplosion_;
	}

	if (std::fmod(time, 0.8f) < 0.1f && isPetal_)
	{
		particleManager->Emit("petalGroup", { 0.0f,1.0f,0.0f }, 8);
	}

	if (std::fmod(time, 1.0f) < 0.1f && isHoming_)
	{
		particleManager->Emit("homingGroup", { 0.0f,1.0f,0.0f }, 3);
	}

	if (std::fmod(time, 0.8f) < 0.1f && isFlame_)
	{
		particleManager->Emit("flameGroup", { 0.0f,1.0f,0.0f }, 5);
	}

	if (std::fmod(time, 1.0f) < 0.1f && isExplosion_)
	{
		particleManager->Emit("explosionGroup", { 0.0f,1.0f,0.0f }, 3);
	}




#ifdef USE_IMGUI

	//particleManager->DebugUI();

	if (ImGui::CollapsingHeader("Grayscale"))
	{
		static bool useGrayscale = false;
		if (ImGui::Checkbox("UseGrayscale", &useGrayscale))
		{
			postEffectManager->SetActiveEffect("Grayscale", useGrayscale);
		}
		if (ImGui::Button("1"))
		{
			if (useGrayscale_ == 1)
			{
				useGrayscale_ = 0;
			} 
			else 
			{
				useGrayscale_ = 1;
			}
		}
		if (ImGui::Button("2"))
		{
			if (useGrayscale_ == 2)
			{
				useGrayscale_ = 0;
			}
			else
			{
				useGrayscale_ = 2;
			}
		}

		// ç¾åœ¨å€¤ã‚’è¡¨ç¤º
		ImGui::Text("useGrayscale_ = %u", useGrayscale_);

		// å€¤ã‚’GrayscalePassã«åæ˜ 
		postEffectManager->GetPassAs<GrayscalePass>("Grayscale")->SetUseGrayscale(useGrayscale_);

	}

	if (ImGui::CollapsingHeader("Vignette"))
	{

		static bool useVignette = false;
		if (ImGui::Checkbox("Use Vignette", &useVignette))
		{
			// ãƒã‚¹ãƒˆã‚¨ãƒ•ã‚§ã‚¯ãƒˆãƒžãƒãƒ¼ã‚¸ãƒ£ã«åˆ‡ã‚Šæ›¿ãˆã‚’ä¼ãˆã‚‹é–¢æ•°ã‚’ä½œã‚‹æƒ³å®š
			postEffectManager->SetActiveEffect("Vignette",useVignette);
		}

		// Vignetteã®ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã‚’ImGuiã§èª¿æ•´ã™ã‚‹
		if (ImGui::SliderFloat("Vignette Radius", &vignetteRadius_, 0.0f, 5.0f))
		{
			postEffectManager->GetPassAs<VignettePass>("Vignette")->SetStrength(vignetteRadius_);
		}
	}

	if (ImGui::CollapsingHeader("BoxFilter"))
	{
		static bool useBoxFilter = false;
		if (ImGui::Checkbox("Use BoxFilter", &useBoxFilter))
		{
			postEffectManager->SetActiveEffect("BoxFilter", useBoxFilter);
		}

		static float blurIntensity = 1.0f;
		ImGui::SliderFloat("Box Blur Intensity", &blurIntensity, 0.1f, 1.0f);
		postEffectManager->GetPassAs<BoxFilterPass>("BoxFilter")->SetIntensity(blurIntensity);
	}

	if (ImGui::CollapsingHeader("GaussianFilter"))
	{
		static bool useGaussianFilter = false;
		if (ImGui::Checkbox("Use GaussianFilter", &useGaussianFilter))
		{
			postEffectManager->SetActiveEffect("GaussianFilter", useGaussianFilter);
		}

		static float gaussianIntensity = 1.0f;
		ImGui::SliderFloat("Gaussian Blur Intensity", &gaussianIntensity, 0.1f, 5.0f);
		postEffectManager->GetPassAs<GaussianFilterPass>("GaussianFilter")->SetIntensity(gaussianIntensity);
	}

	// TimeManager ç”¨ã® ImGui æ“ä½œãƒ‘ãƒãƒ«ã‚’è¿½åŠ 
	if (ImGui::CollapsingHeader("TimeManager"))
	{
		// ç¾åœ¨ã®ã‚¿ã‚¤ãƒ ã‚¹ã‚±ãƒ¼ãƒ«ã‚’å–å¾—
		float currentScale = TimeManager::Instance().GetTimeScale();

		// ã‚¹ãƒ©ã‚¤ãƒ€ãƒ¼ã®è¡¨ç¤ºå€¤ï¼ˆãƒ¦ãƒ¼ã‚¶ãƒ¼æ“ä½œæ™‚ã«å„ªå…ˆã—ã¦åæ˜ ï¼‰
		static float timeScaleSlider = currentScale;
		// å¤–éƒ¨ã‹ã‚‰ã‚¿ã‚¤ãƒ ã‚¹ã‚±ãƒ¼ãƒ«ãŒå¤‰æ›´ã•ã‚ŒãŸå ´åˆã€ãƒ¦ãƒ¼ã‚¶ãƒ¼æ“ä½œä¸­ã§ãªã‘ã‚Œã°åŒæœŸã™ã‚‹
		if (!ImGui::IsAnyItemActive() && std::abs(timeScaleSlider - currentScale) > 1e-6f)
		{
			timeScaleSlider = currentScale;
		}

		// ã‚¹ãƒ©ã‚¤ãƒ€ãƒ¼ã§ç›´æŽ¥å¤‰æ›´
		if (ImGui::SliderFloat("Time Scale", &timeScaleSlider, 0.0f, 2.0f))
		{
			TimeManager::Instance().SetTimeScale(timeScaleSlider);
		}

		// ä¸€æ™‚åœæ­¢ / å†é–‹ ãƒœã‚¿ãƒ³
		if (ImGui::Button("Pause"))
		{
			TimeManager::Instance().Pause();
		}
		ImGui::SameLine();
		if (ImGui::Button("Resume"))
		{
			TimeManager::Instance().Resume();
		}
		ImGui::SameLine();
		if (ImGui::Button("Reset"))
		{
			TimeManager::Instance().SetTimeScale(1.0f);
			timeScaleSlider = 1.0f;
		}

		// ã‚¹ãƒ ãƒ¼ã‚ºå¤‰æ›´ã®å…¥åŠ›
		static float smoothTarget = 0.0f;
		static float smoothDuration = 0.5f;
		ImGui::InputFloat("Smooth Target", &smoothTarget, 0.1f, 1.0f, "%.2f");
		ImGui::InputFloat("Smooth Duration (s)", &smoothDuration, 0.1f, 1.0f, "%.2f");

		if (ImGui::Button("Smooth To Target"))
		{
			// duration ãŒè² ã«ãªã‚‰ãªã„ã‚ˆã†ã«ä¿è­·
			TimeManager::Instance().SmoothTimeScale(smoothTarget, std::max(0.0f, smoothDuration));
		}

		// ã‚¹ãƒ†ãƒƒãƒ—å®Ÿè¡Œ
		static float stepSeconds = 0.016f;
		ImGui::InputFloat("Step Seconds", &stepSeconds, 0.001f, 0.1f, "%.3f");
		if (ImGui::Button("Step"))
		{
			TimeManager::Instance().Step(stepSeconds);
		}

		// ç¾åœ¨ã®å€¤ã‚’è¡¨ç¤º
		ImGui::Text("Current TimeScale = %.3f", currentScale);
	}


#endif // USE_IMGUI

}

void MyGame::Draw()
{
	//ã‚²ãƒ¼ãƒ ã®å‡¦ç†		æç”»å‡¦ç†

	//ã‚³ãƒžãƒ³ãƒ‰ã‚’ç©ã¿è¾¼ã‚“ã§ç¢ºå®šã•ã›ã‚‹

	// ---------- ã‚ªãƒ•ã‚¹ã‚¯ãƒªãƒ¼ãƒ³æç”» ----------
	renderTexture->BeginRender();

	srvManager->PreDraw();

	// Skyboxã®æç”»
	skybox->Draw();

	sceneManager_->Draw();   // å®Ÿéš›ã®æç”»

	particleManager->Draw();

	renderTexture->EndRender();


	// ---------- SwapChainã¸ã®æç”» ----------
	dxCommon->PreDraw();
	
	postEffectManager->DrawAll(dxCommon->GetCommandList(), renderTexture->GetGPUHandle(), inputRes.Get(), state);

#ifdef USE_IMGUI
	// ImGuiæç”»
	imGuiManager->Draw();
#endif // USE_IMGUI

	dxCommon->PostDraw();


}

void MyGame::LoadModel()
{
	ModelManager::GetInstance()->LoadModel("cube.obj");
	ModelManager::GetInstance()->LoadModel("plane.obj");
	ModelManager::GetInstance()->LoadModel("sphere.obj");
	ModelManager::GetInstance()->LoadModel("terrain.obj");
	ModelManager::GetInstance()->LoadModel("player/player.obj");
	ModelManager::GetInstance()->LoadModel("player/bullet/playerBullet.obj");
	ModelManager::GetInstance()->LoadModel("enemy/normal/normalEnemy.obj");
	ModelManager::GetInstance()->LoadModel("enemy/normal/bullet/enemyBullet.obj");
	ModelManager::GetInstance()->LoadModel("enemy/trap/trapEnemy.obj");
	ModelManager::GetInstance()->LoadModel("enemy/trap/timeBomb/bomb.obj");
	ModelManager::GetInstance()->LoadModel("enemy/trap/vignette/vignette.obj");
	ModelManager::GetInstance()->LoadModel("wall/wall.obj");
	ModelManager::GetInstance()->LoadModel("field/field.obj");
	ModelManager::GetInstance()->LoadModel("goal/goal.obj");
	ModelManager::GetInstance()->LoadModel("logo/logo.obj");
	ModelManager::GetInstance()->LoadModel("barrie/barrie.obj");
	
}

void MyGame::LoadSound()
{
	soundData_ = Audio::GetInstance()->LoadWav("fanfare.wav");
	soundData2_ = Audio::GetInstance()->LoadWav("BGM.wav");
}

============================================================
File Path: project/gameEngine/baseScene/MyGame.h
============================================================
#pragma once

#include "Framework.h"
#include "../../../application/scene/SceneFactory.h"

/// <summary>
/// ã‚²ãƒ¼ãƒ å›ºæœ‰ã®ãƒ•ãƒ¬ãƒ¼ãƒ ãƒ¯ãƒ¼ã‚¯
/// ã‚²ãƒ¼ãƒ å›ºæœ‰ã®åˆæœŸåŒ–ã€çµ‚äº†ã€æ›´æ–°ã€æç”»ã‚’è¡Œã†
/// </summary>
class MyGame : public Framework
{
public:

	// åˆæœŸåŒ–
	void Initialize() override;

	// çµ‚äº†
	void Finalize() override;

	// æ›´æ–°
	void Update() override;

	// æç”»	
	void Draw() override;

	// ãƒ¢ãƒ‡ãƒ«èª­ã¿è¾¼ã¿
	void LoadModel();

	// ã‚µã‚¦ãƒ³ãƒ‰èª­ã¿è¾¼ã¿
	void LoadSound();

	// ã‚µã‚¦ãƒ³ãƒ‰
	SoundData soundData_;
	SoundData soundData2_;

private:

	bool useExampleGroup_ = true;

	// 0 : ã‚°ãƒ¬ãƒ¼ã‚¹ã‚±ãƒ¼ãƒ«ç„¡åŠ¹, 1: ã‚°ãƒ¬ãƒ¼ã‚¹ã‚±ãƒ¼ãƒ«æœ‰åŠ¹
	uint32_t useGrayscale_ = 0;

	// Vignetteã®å¼·åº¦
	float vignetteRadius_ = 0.5f;

	float time = 0.0f;
	bool isPetal_ = false;
	bool isHoming_ = false;
	bool isFlame_ = false;
	bool isExplosion_ = false;
};

============================================================
File Path: project/gameEngine/baseScene/SceneManager.cpp
============================================================
#include "SceneManager.h"
#include <cassert>

SceneManager* SceneManager::GetInstance()
{
    static SceneManager instance;
    return &instance;
}

void SceneManager::Finalize()
{
    if (scene_) 
    {
        scene_->Finalize();
        scene_.reset();
    }
}

void SceneManager::Update()
{
    if (nextScene_)
    {
        // æ—§ã‚·ãƒ¼ãƒ³çµ‚äº†
        if (scene_)
        {
            scene_->Finalize();
            scene_.reset();
        }

        // ã‚·ãƒ¼ãƒ³åˆ‡ã‚Šæ›¿ãˆ
        scene_ = std::move(nextScene_);
        nextScene_.reset();

        // ã‚·ãƒ¼ãƒ³ãƒžãƒãƒ¼ã‚¸ãƒ£ã‚’ã‚»ãƒƒãƒˆ
        scene_->SetSceneManager(this);

        // æ¬¡ã®ã‚·ãƒ¼ãƒ³ã‚’åˆæœŸåŒ–
        scene_->Initialize();
    }

    // å®Ÿè¡Œä¸­ã‚·ãƒ¼ãƒ³ã‚’æ›´æ–°ã™ã‚‹
    if (scene_) 
    {
        scene_->Update();
    }
}

void SceneManager::Draw()
{
    // å®Ÿè¡Œä¸­ã‚·ãƒ¼ãƒ³ã‚’æç”»ã™ã‚‹
    if (scene_)
    {
        scene_->Draw();
    }
}

void SceneManager::ChangeScene(const std::string& sceneName)
{
    assert(sceneFactory_);
    assert(nextScene_ == nullptr);

    // æ¬¡ã®ã‚·ãƒ¼ãƒ³ã‚’ç”Ÿæˆ
    nextScene_ = sceneFactory_->CreateScene(sceneName);
}

============================================================
File Path: project/gameEngine/baseScene/SceneManager.h
============================================================
#pragma once

#include <memory>
#include <string>

#include "BaseScene.h"
#include "AbstractSceneFactory.h"

/// <summary>
/// ã‚·ãƒ¼ãƒ³ãƒžãƒãƒ¼ã‚¸ãƒ£
/// ã“ã“ã§ã‚·ãƒ¼ãƒ³ã®æ›´æ–°ã€æç”»ã‚’è¡Œã†
/// </summary>
class SceneManager
{
#pragma region ã‚·ãƒ³ã‚°ãƒ«ãƒˆãƒ³ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹
private:

	SceneManager() = default;
	~SceneManager() = default;
	SceneManager(SceneManager&) = delete;
	SceneManager& operator = (SceneManager&) = delete;

public:
	// ã‚·ãƒ³ã‚°ãƒ«ãƒˆãƒ³ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã®å–å¾—
	static SceneManager* GetInstance();
	// çµ‚äº†
	void Finalize();
#pragma endregion ã‚·ãƒ³ã‚°ãƒ«ãƒˆãƒ³ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹
public:

	// æ›´æ–°
	void Update();

	// æç”»
	void Draw();

	/// <summary>
	/// ã‚·ãƒ¼ãƒ³å¤‰æ›´
	/// </summary>
	/// <param name="sceneName">æ¬¡ã®ã‚·ãƒ¼ãƒ³å</param>
	void ChangeScene(const std::string& sceneName);

	/// <summary>
	/// ã‚·ãƒ¼ãƒ³ãƒ•ã‚¡ã‚¯ãƒˆãƒªãƒ¼ã‚’è¨­å®š
	/// </summary>
	/// <param name="sceneFactory">ã‚·ãƒ¼ãƒ³ãƒ•ã‚¡ã‚¯ãƒˆãƒªãƒ¼ã®ãƒã‚¤ãƒ³ã‚¿</param>
	void SetSceneFactory(AbstractSceneFactory* sceneFactory) { sceneFactory_ = sceneFactory; }

private:

	// ä»Šã®ã‚·ãƒ¼ãƒ³
	std::unique_ptr<BaseScene> scene_ = nullptr;

	// æ¬¡ã®ã‚·ãƒ¼ãƒ³
	std::unique_ptr<BaseScene> nextScene_ = nullptr;

	// ã‚·ãƒ¼ãƒ³ãƒ•ã‚¡ã‚¯ãƒˆãƒªãƒ¼
	AbstractSceneFactory* sceneFactory_ = nullptr;
};



============================================================
File Path: project/gameEngine/imgui/ImGuiManager.cpp
============================================================
#include "ImGuiManager.h"

#ifdef USE_IMGUI

//#include <imgui.h>
#include "../../externals/imgui/imgui_impl_win32.h"
//#include <imgui_impl_dx12.h>

#endif // USE_IMGUI

void ImGuiManager::Initialize(WinApp* winApp, DirectXCommon* dxCommon)
{

	winApp_ = winApp;
	dxCommon_ = dxCommon;

#ifdef USE_IMGUI
	// ImGuiã®ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã‚’ç”Ÿæˆ
	ImGui::CreateContext();
	// ImGuiã®ã‚¹ã‚¿ã‚¤ãƒ«ã‚’è¨­å®š
	ImGui::StyleColorsDark();

	ImGui_ImplWin32_Init(winApp_->GetHwnd());

	// ãƒ‡ã‚¹ã‚¯ãƒªãƒ—ã‚¿ãƒ’ãƒ¼ãƒ—è¨­å®š
	D3D12_DESCRIPTOR_HEAP_DESC desc = {};
	desc.Type = D3D12_DESCRIPTOR_HEAP_TYPE_CBV_SRV_UAV;
	desc.NumDescriptors = 1;
	desc.Flags = D3D12_DESCRIPTOR_HEAP_FLAG_SHADER_VISIBLE;
	// ãƒ‡ã‚¹ã‚¯ãƒªãƒ—ã‚¿ãƒ’ãƒ¼ãƒ—ç”Ÿæˆ
	HRESULT result = S_FALSE;
	result = dxCommon_->GetDevice()->CreateDescriptorHeap(&desc, IID_PPV_ARGS(&srvHeap_));
	assert(SUCCEEDED(result));

	// DirectX12ç”¨åˆæœŸåŒ–
	ImGui_ImplDX12_Init(
		dxCommon_->GetDevice().Get(),
		dxCommon_->GetSwapChainDesc().BufferCount,
		DXGI_FORMAT_R8G8B8A8_UNORM_SRGB,
		srvHeap_.Get(),
		srvHeap_->GetCPUDescriptorHandleForHeapStart(),
		srvHeap_->GetGPUDescriptorHandleForHeapStart()
	);

#endif // USE_IMGUI
}

void ImGuiManager::Finalize()
{
#ifdef USE_IMGUI

	// å¾Œå§‹æœ«
	ImGui_ImplDX12_Shutdown();
	ImGui_ImplWin32_Shutdown();
	ImGui::DestroyContext();

	// ãƒ‡ã‚¹ã‚¯ãƒªãƒ—ã‚¿ãƒ’ãƒ¼ãƒ—ã‚’è§£æ”¾
	srvHeap_.Reset();

#endif // USE_IMGUI
}

void ImGuiManager::Begin()
{
#ifdef USE_IMGUI

	// ImGuiãƒ•ãƒ¬ãƒ¼ãƒ é–‹å§‹
	ImGui_ImplDX12_NewFrame();
	ImGui_ImplWin32_NewFrame();
	ImGui::NewFrame();

#endif // USE_IMGUI
}

void ImGuiManager::End()
{
#ifdef USE_IMGUI

	// ImGuiæç”»å‰æº–å‚™
	ImGui::Render();

#endif // USE_IMGUI
}

void ImGuiManager::Draw()
{
#ifdef USE_IMGUI

	ID3D12GraphicsCommandList* commandList = dxCommon_->GetCommandList().Get();

	// ãƒ‡ã‚¹ã‚¯ãƒªãƒ—ã‚¿ãƒ’ãƒ¼ãƒ—ã®é…åˆ—ã‚’è¨­å®š
	ID3D12DescriptorHeap* ppHeaps[] = { srvHeap_.Get() };
	commandList->SetDescriptorHeaps(_countof(ppHeaps), ppHeaps);
	// æç”»ã‚³ãƒžãƒ³ãƒ‰ã‚’ç™ºè¡Œ
	ImGui_ImplDX12_RenderDrawData(ImGui::GetDrawData(), commandList);

#endif // USE_IMGUI
}


============================================================
File Path: project/gameEngine/imgui/ImGuiManager.h
============================================================
#pragma once

#include "DirectXCommon.h"

/// <summary>
/// ImGuiç®¡ç†ã‚¯ãƒ©ã‚¹
/// <para>ImGuiã®åˆæœŸåŒ–ã€çµ‚äº†ã€æç”»ã‚’è¡Œã†</para>
/// </summary>
class ImGuiManager
{
public:

	/// <summary>
	/// åˆæœŸåŒ–
	/// </summary>
	/// <param name="winApp">WindowsAPI</param>
	/// <param name="dxCommon">DirectXå…±é€šæ©Ÿèƒ½ç®¡ç†ã‚¯ãƒ©ã‚¹ã¸ã®ãƒã‚¤ãƒ³ã‚¿</param>
	void Initialize(WinApp* winApp, DirectXCommon* dxCommon);

	/// <summary>
	/// çµ‚äº†
	/// </summary>
	void Finalize();

	/// <summary>
	/// ImGuiå—ä»˜é–‹å§‹
	/// </summary>
	void Begin();

	/// <summary>
	/// ImGuiå—ä»˜çµ‚äº†
	/// </summary>
	void End();

	/// <summary>
	/// æç”»
	/// </summary>
	void Draw();

private:

	// WindowsAPI
	WinApp* winApp_ = nullptr;

	DirectXCommon* dxCommon_ = nullptr;

	// SRVç”¨ãƒ‡ã‚¹ã‚¯ãƒªãƒ—ã‚¿ãƒ’ãƒ¼ãƒ—
	Microsoft::WRL::ComPtr<ID3D12DescriptorHeap> srvHeap_ = nullptr;

};



============================================================
File Path: project/gameEngine/io/Input.cpp
============================================================
#include "Input.h"

#include <cassert>

#pragma comment(lib,"dinput8.lib")
#pragma comment(lib,"dxguid.lib")

Input* Input::GetInstance()
{
	static Input instance;
	return &instance;
}

void Input::Finalize(){}

void Input::Initialize(WinApp* winApp)
{
	// å€Ÿã‚Šã¦ããŸWinAppã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚’è¨˜éŒ²
	this->winApp_ = winApp;

	HRESULT result; /* = CreateDXGIFactory(IID_PPV_ARGS(&dxgiFactory));*/

	// DirectInputã®åˆæœŸåŒ–
	result = DirectInput8Create(winApp_->GetHInstance(), DIRECTINPUT_VERSION, IID_IDirectInput8, (void**)&directInput, nullptr);
	assert(SUCCEEDED(result));

	// ã‚­ãƒ¼ãƒœãƒ¼ãƒ‰ãƒ‡ãƒã‚¤ã‚¹ã®ç”Ÿæˆ
	
	result = directInput->CreateDevice(GUID_SysKeyboard, &keyboard, NULL);
	assert(SUCCEEDED(result));

	// å…¥åŠ›ãƒ‡ãƒ¼ã‚¿å½¢å¼ã®ã‚»ãƒƒãƒˆ
	result = keyboard->SetDataFormat(&c_dfDIKeyboard);
	assert(SUCCEEDED(result));

	// æŽ’ä»–çš„åˆ¶å¾¡ãƒ¬ãƒ™ãƒ«ã®ã‚»ãƒƒãƒˆ
	result = keyboard->SetCooperativeLevel(winApp_->GetHwnd(), DISCL_FOREGROUND | DISCL_NONEXCLUSIVE | DISCL_NOWINKEY);
	assert(SUCCEEDED(result));
}

void Input::Update()
{

	// å‰å›žã®ã‚­ãƒ¼å…¥åŠ›ã‚’ä¿å­˜
	memcpy(keyPre, key, sizeof(key));

	// ã‚­ãƒ¼ãƒœãƒ¼ãƒ‰æƒ…å ±ã®å–å¾—é–‹å§‹
	keyboard->Acquire();
	// å…¨ã‚­ãƒ¼ã®å…¥åŠ›çŠ¶æ…‹ã‚’å–å¾—ã™ã‚‹
	keyboard->GetDeviceState(sizeof(key), key);
}

bool Input::PushKey(BYTE keyNumber)
{
	// æŒ‡å®šã‚­ãƒ¼ã‚’æŠ¼ã—ã¦ã„ã‚Œã° trueã‚’è¿”ã™
	if (key[keyNumber])
	{
		return true;
	}

	// ãã†ã§ãªã‘ã‚Œã° falseã‚’è¿”ã™
	return false;
}

bool Input::TriggerKey(BYTE keyNumber)
{
	if (!keyPre[keyNumber] && key[keyNumber])
	{
		return true;
	}

	return false;
}


============================================================
File Path: project/gameEngine/io/Input.h
============================================================
#pragma once
#include <windows.h>
#include <wrl.h>
using namespace Microsoft::WRL;

//Input
#define DIRECTINPUT_VERSION  0x0800
#include <dinput.h>

#include "WinApp.h"

/// <summary>
/// å…¥åŠ›ã‚¯ãƒ©ã‚¹
/// DirectInputã‚’ä½¿ç”¨ã—ã¦ã‚­ãƒ¼ãƒœãƒ¼ãƒ‰ã®å…¥åŠ›ã‚’ç®¡ç†
/// </summary>
class Input
{
#pragma region ã‚·ãƒ³ã‚°ãƒ«ãƒˆãƒ³ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹
private:

	Input() = default;
	~Input() = default;
	Input(Input&) = delete;
	Input& operator = (Input&) = delete;

public:
	// ã‚·ãƒ³ã‚°ãƒ«ãƒˆãƒ³ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã®å–å¾—
	static Input* GetInstance();
	// çµ‚äº†
	void Finalize();
#pragma endregion ã‚·ãƒ³ã‚°ãƒ«ãƒˆãƒ³ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹

public:

	// namespaceçœç•¥
	template<class T> using ComPtr = Microsoft::WRL::ComPtr<T>;

public:

	/// <summary>
	/// åˆæœŸåŒ–
	/// </summary>
	/// <param name="winApp">WindowsAPI</param>
	void Initialize(WinApp* winApp);

	/// <summary>
	/// æ›´æ–°
	/// </summary>
	void Update();

    /// <summary>
    /// ã‚­ãƒ¼ã®æŠ¼ä¸‹ã‚’ãƒã‚§ãƒƒã‚¯
    /// </summary>
    /// <perm name="keyNumber">ã‚­ãƒ¼ç•ªå·( DIK_0 ç­‰)</param>
	///<returns>æŠ¼ã•ã‚Œã¦ã„ã‚‹ã‹</returns>
	bool PushKey(BYTE keyNumber);

    /// <summary>
    /// ã‚­ãƒ¼ã®ãƒˆãƒªã‚¬ãƒ¼ã‚’ãƒã‚§ãƒƒã‚¯
    /// </summary>
	/// <param name="KeyNumber">ã‚­ãƒ¼ç•ªå·( DIK_0 ç­‰ )</param>
	/// <returns>ãƒˆãƒªã‚¬ãƒ¼ã‹</returns>
	bool TriggerKey(BYTE keyNumber);

private:

	// WindowsAPI
	WinApp* winApp_ = nullptr;

	// DirectInputã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹
	ComPtr<IDirectInput8> directInput;

	// ã‚­ãƒ¼ãƒœãƒ¼ãƒ‰ã®ãƒ‡ãƒã‚¤ã‚¹
	ComPtr<IDirectInputDevice8> keyboard = nullptr;

	// å…¨ã‚­ãƒ¼ã®çŠ¶æ…‹
	BYTE key[256] = {};
	// å‰å›žã®å…¨ã‚­ãƒ¼ã®çŠ¶æ…‹
	BYTE keyPre[256] = {};
};



============================================================
File Path: project/gameEngine/level_editor/LevelDataLoader.cpp
============================================================
#include "LevelDataLoader.h"

std::unique_ptr<LevelData> LevelDataLoader::LoadLevelData(const std::string& fileName)
{
	std::string fullPath = kDefaultBaseDirectory + fileName + kExtension;

	std::ifstream file(fullPath);
	if (file.fail())
	{
		assert(false && "Failed to open level data file.");
		return nullptr;
	}

	nlohmann::json deserialized;
	file >> deserialized;

	assert(deserialized.is_object());
	assert(deserialized.contains("name") && deserialized["name"].is_string());
	assert(deserialized["name"] == "scene");

	auto levelData = std::make_unique<LevelData>();

	for (const auto& object : deserialized["objects"])
	{
		LoadObjectRecursive(object, levelData.get());
	}

	return levelData;
}

void LevelDataLoader::LoadObjectRecursive(const nlohmann::json& objectJson, LevelData* levelData)
{
    assert(objectJson.contains("type") && objectJson["type"].is_string());

    if (objectJson.contains("disable_export"))
    {
        // æœ‰åŠ¹ç„¡åŠ¹ãƒ•ãƒ©ã‚°
        bool disabled = objectJson["disable_export"].get<bool>();
        if (!disabled)
        {
            // ã“ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯é…ç½®ã—ãªã„
            return;
        }
    }

    std::string type = objectJson["type"];

    if (type == "MESH")
    {
        LevelData::ObjectData data;
        data.type = type;

        if (objectJson.contains("file_name")) 
        {
            std::string fileName = objectJson["file_name"];
            // ã™ã§ã« .obj ã§çµ‚ã‚ã£ã¦ã„ãªã‘ã‚Œã°ä»˜ä¸Ž
			// 4æ–‡å­—ä»¥ä¸‹ã®å ´åˆ or æœ€å¾Œã®4æ–‡å­—ãŒ ".obj" ã§ãªã„å ´åˆ
            if (fileName.length() < 4 or fileName.substr(fileName.length() - 4) != ".obj") 
            {
                fileName += ".obj";
            }
            data.fileName = objectJson["file_name"];
        }

        if (objectJson.contains("transform"))
        {
            const auto& t = objectJson["transform"];
            data.translation = { -1.0f * t["translation"][0], t["translation"][1], -1.0f * t["translation"][2] };
            data.rotation = { -1.0f * t["rotation"][0],  3.14f + t["rotation"][1], -1.0f * t["rotation"][2] };
            data.scale = { t["scaling"][0], t["scaling"][1], t["scaling"][2] };
        }

        levelData->objects.emplace_back(std::move(data));
    }
    // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ç™ºç”Ÿãƒã‚¤ãƒ³ãƒˆ
    else if (type == "PlayerSpawn")
    {
        // players ã«è¦ç´ ã‚’ 1 ã¤è¿½åŠ 
        LevelData::PlayerSpawnData playerData;

        // transform æƒ…å ±ãŒå­˜åœ¨ã™ã‚Œã°ä½ç½®ã¨å›žè»¢ã‚’å–å¾—
        if (objectJson.contains("transform")) 
        {
            const auto& t = objectJson["transform"];

            // position ã®æ•°å€¤ã‚’æ›¸ãè¾¼ã‚€
            if (t.contains("translation")) 
            {
                const auto& pos = t["translation"];
                playerData.position = {-1.0f * pos[0], pos[2], -1.0f * pos[1] };
            }

            // rotation ã®æ•°å€¤ã‚’æ›¸ãè¾¼ã‚€ï¼ˆBlenderã¨ã®åº§æ¨™ç³»è£œæ­£ãŒå¿…è¦ãªã‚‰ -1.0f ã‚’æŽ›ã‘ã‚‹ï¼‰
            if (t.contains("rotation")) 
            {
                const auto& rot = t["rotation"];
                playerData.rotation = { -1.0f * rot[0], 3.14f + rot[1], -1.0f * rot[2] };
            }
        }

        levelData->players.push_back(playerData);
    }
	// æ•µã‚­ãƒ£ãƒ©ç™ºç”Ÿãƒã‚¤ãƒ³ãƒˆ
	else if (type == "EnemySpawn")
	{
		// enemies ã«è¦ç´ ã‚’ 1 ã¤è¿½åŠ 
		LevelData::EnemySpawnData enemyData;
		// transform æƒ…å ±ãŒå­˜åœ¨ã™ã‚Œã°æƒ…å ±ã‚’å–å¾—
		if (objectJson.contains("transform"))
		{
			const auto& t = objectJson["transform"];
			// position ã®æ•°å€¤ã‚’æ›¸ãè¾¼ã‚€
			if (t.contains("translation"))
			{
				const auto& pos = t["translation"];
				enemyData.position = { -1.0f * pos[0], pos[2], -1.0f * pos[1] };
			}
			// rotation ã®æ•°å€¤ã‚’æ›¸ãè¾¼ã‚€ï¼ˆBlenderã¨ã®åº§æ¨™ç³»è£œæ­£ãŒå¿…è¦ãªã‚‰ -1.0f ã‚’æŽ›ã‘ã‚‹ï¼‰
			if (t.contains("rotation"))
			{
				const auto& rot = t["rotation"];
				enemyData.rotation = { -1.0f * rot[0], 3.14f + rot[1], -1.0f * rot[2] };
			}
		}

        // wave_id ã¨ delay ã¯ transform ã®å¤–ã«ã‚ã‚‹ã®ã§ objectJson ã‹ã‚‰èª­ã‚€
        if (objectJson.contains("wave_id"))
        {
            enemyData.waveNum = objectJson["wave_id"].get<uint32_t>();
        }
        if (objectJson.contains("delay"))
        {
            enemyData.spawnDelay = objectJson["delay"].get<uint32_t>();
        }

		levelData->enemies.push_back(enemyData);
	}
    // ç½ æ•µç™ºç”Ÿãƒã‚¤ãƒ³ãƒˆ
    else if (type == "Trap")
    {
        // enemies ã«è¦ç´ ã‚’ 1 ã¤è¿½åŠ 
        LevelData::EnemySpawnData enemyData;
        // transform æƒ…å ±ãŒå­˜åœ¨ã™ã‚Œã°æƒ…å ±ã‚’å–å¾—
        if (objectJson.contains("transform"))
        {
            const auto& t = objectJson["transform"];
            // position ã®æ•°å€¤ã‚’æ›¸ãè¾¼ã‚€
            if (t.contains("translation"))
            {
                const auto& pos = t["translation"];
                enemyData.position = { -1.0f * pos[0], pos[2], -1.0f * pos[1] };
            }
            // rotation ã®æ•°å€¤ã‚’æ›¸ãè¾¼ã‚€ï¼ˆBlenderã¨ã®åº§æ¨™ç³»è£œæ­£ãŒå¿…è¦ãªã‚‰ -1.0f ã‚’æŽ›ã‘ã‚‹ï¼‰
            if (t.contains("rotation"))
            {
                const auto& rot = t["rotation"];
                enemyData.rotation = { -1.0f * rot[0], 3.14f + rot[1], -1.0f * rot[2] };
            }
        }

        // wave_id ã¨ delay ã¯ transform ã®å¤–ã«ã‚ã‚‹ã®ã§ objectJson ã‹ã‚‰èª­ã‚€
        if (objectJson.contains("wave_id"))
        {
            enemyData.waveNum = objectJson["wave_id"].get<uint32_t>();
        }
        if (objectJson.contains("delay"))
        {
            enemyData.spawnDelay = objectJson["delay"].get<uint32_t>();
        }
        
        levelData->trapEnemies.push_back(enemyData);
	}
    // å£ç™ºç”Ÿãƒã‚¤ãƒ³ãƒˆ
    else if (type == "Wall")
    {
        // walls ã«è¦ç´ ã‚’ 1 ã¤è¿½åŠ 
        LevelData::WallData wallData;

        // transform æƒ…å ±ãŒå­˜åœ¨ã™ã‚Œã°ä½ç½®ã¨å›žè»¢ã‚’å–å¾—
        if (objectJson.contains("transform"))
        {
            const auto& t = objectJson["transform"];

            // position ã®æ•°å€¤ã‚’æ›¸ãè¾¼ã‚€
            if (t.contains("translation"))
            {
                const auto& pos = t["translation"];
                wallData.position = { -1.0f * pos[0], pos[2], -1.0f * pos[1] };
            }

            // rotation ã®æ•°å€¤ã‚’æ›¸ãè¾¼ã‚€ï¼ˆBlenderã¨ã®åº§æ¨™ç³»è£œæ­£ãŒå¿…è¦ãªã‚‰ -1.0f ã‚’æŽ›ã‘ã‚‹ï¼‰
            if (t.contains("rotation"))
            {
                const auto& rot = t["rotation"];
                wallData.rotation = { -1.0f * rot[0], 3.14f + rot[1], -1.0f * rot[2] };
            }

			// scale ã®æ•°å€¤ã‚’æ›¸ãè¾¼ã‚€
            if (t.contains("scaling"))
            {
                const auto& scl = t["scaling"];
                wallData.scale = { scl[0], scl[2], scl[1] };
            }

        }

        levelData->walls.push_back(wallData);

    }

    // å†å¸° å­ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®èµ°æŸ»
    if (objectJson.contains("children")) 
    {
        for (const auto& child : objectJson["children"]) 
        {
            LoadObjectRecursive(child, levelData);
        }
    }
}


============================================================
File Path: project/gameEngine/level_editor/LevelDataLoader.h
============================================================
#pragma once

#include <fstream>
#include <string>
#include <cassert>
#include <vector>
#include <unordered_map>

#include <Model.h>
#include <Object3d.h>

#include "../../externals/json/json.hpp"

/// <summary>
/// ãƒ¬ãƒ™ãƒ«ãƒ‡ãƒ¼ã‚¿
/// ãƒ¬ãƒ™ãƒ«ã‚¨ãƒ‡ã‚£ã‚¿ã§ä½œæˆã—ãŸãƒ‡ãƒ¼ã‚¿ã‚’èª­ã¿è¾¼ã‚€ãŸã‚ã®ã‚¯ãƒ©ã‚¹
/// </summary>
class LevelData 
{
public:

	// ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®ã‚¹ãƒãƒ¼ãƒ³ãƒ‡ãƒ¼ã‚¿
	struct PlayerSpawnData
	{
		Vector3 position;
		Vector3 rotation;
	};

	// æ•µã‚­ãƒ£ãƒ©ã®ã‚¹ãƒãƒ¼ãƒ³ãƒ‡ãƒ¼ã‚¿
	struct EnemySpawnData
	{
		Vector3 position;
		Vector3 rotation;
		uint32_t waveNum = 1;
		uint32_t spawnDelay = 0;
		bool isSpawned = false; // æ•µãŒã‚¹ãƒãƒ¼ãƒ³ã—ãŸã‹ã©ã†ã‹
	};

	// å£ã®ãƒ‡ãƒ¼ã‚¿
	struct WallData
	{
		Vector3 position;
		Vector3 rotation;
		Vector3 scale;
	};

	// ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãƒ‡ãƒ¼ã‚¿
	struct ObjectData 
	{
		std::string type;
		std::string fileName;
		Vector3 translation;
		Vector3 rotation;
		Vector3 scale;
	};

	// ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆé…åˆ—
	std::vector<ObjectData> objects;


	// ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼é…åˆ—
	std::vector<PlayerSpawnData> players;

	// æ•µã‚­ãƒ£ãƒ©é…åˆ—
	std::vector<EnemySpawnData> enemies;
	std::vector<EnemySpawnData> trapEnemies;

	// å£é…åˆ—
	std::vector<WallData> walls;

};

/// <summary>
/// ãƒ¬ãƒ™ãƒ«ãƒ‡ãƒ¼ã‚¿ãƒ­ãƒ¼ãƒ€ãƒ¼
/// ãƒ¬ãƒ™ãƒ«ã‚¨ãƒ‡ã‚£ã‚¿ã§ä½œæˆã—ãŸãƒ‡ãƒ¼ã‚¿ã‚’èª­ã¿è¾¼ã‚€ãŸã‚ã®ã‚¯ãƒ©ã‚¹
/// </summary>
class LevelDataLoader
{
public:

	static constexpr const char* kDefaultBaseDirectory = "resources/levels/";
	static constexpr const char* kExtension = ".json";

	/// <summary>
	/// ãƒ¬ãƒ™ãƒ«ãƒ‡ãƒ¼ã‚¿ã®èª­ã¿è¾¼ã¿
	/// </summary>
	/// <param name="fileName">ãƒ•ã‚¡ã‚¤ãƒ«åï¼ˆæ‹¡å¼µå­ä¸è¦ï¼‰</param>
	/// <returns>ãƒ¬ãƒ™ãƒ«ãƒ‡ãƒ¼ã‚¿ã®ãƒã‚¤ãƒ³ã‚¿</returns>
	static std::unique_ptr<LevelData> LoadLevelData(const std::string& fileName);

private:

	/// <summary>
	/// ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®å†å¸°çš„èª­ã¿è¾¼ã¿
	/// </summary>
	/// <param name="objectJson">ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®JSONãƒ‡ãƒ¼ã‚¿</param>
	/// <param name="levelData">ãƒ¬ãƒ™ãƒ«ãƒ‡ãƒ¼ã‚¿ã®ãƒã‚¤ãƒ³ã‚¿</param>
	static void LoadObjectRecursive(const nlohmann::json& objectJson, LevelData* levelData);

};

============================================================
File Path: project/gameEngine/math/Ease.h
============================================================
#pragma once

#include <cmath>
#include <numbers>

/// <summary>
/// ã‚¤ãƒ¼ã‚¸ãƒ³ã‚°
/// </summary>
class Ease 
{
public:

   static constexpr float pi = std::numbers::pi_v<float>;

   /// <summary>
   /// ç·šå½¢è£œé–“
   /// </summary>
   /// <param name="t">0.0ã€œ1.0ã®è£œé–“å€¤</param>
   /// <returns>è£œé–“å¾Œã®å€¤</returns>
   static float Linear(float t) 
   {
       return t;
   }

   /// <summary>
   /// ã‚¤ãƒ¼ã‚ºã‚¤ãƒ³(åŠ é€Ÿ)
   /// </summary>
   /// <param name="t">0.0ã€œ1.0ã®è£œé–“å€¤</param>
   /// <returns>è£œé–“å¾Œã®å€¤</returns>
   static float InQuad(float t)
   {
       return t * t;
   }

   /// <summary>
   /// ã‚¤ãƒ¼ã‚ºã‚¤ãƒ³(åŠ é€Ÿ)
   /// </summary>
   /// <param name="t">0.0ã€œ1.0ã®è£œé–“å€¤</param>
   /// <returns>è£œé–“å¾Œã®å€¤</returns>
   static float InCubic(float t) 
   {
       return t * t * t;
   }

   /// <summary>
   /// ã‚¤ãƒ¼ã‚ºã‚¤ãƒ³(åŠ é€Ÿ)
   /// </summary>
   /// <param name="t">0.0ã€œ1.0ã®è£œé–“å€¤</param>
   /// <returns>è£œé–“å¾Œã®å€¤</returns>
   static float InQuart(float t) 
   {
       return t * t * t * t;
   }

   /// <summary>
   /// ã‚¤ãƒ¼ã‚ºã‚¤ãƒ³(åŠ é€Ÿ)
   /// </summary>
   /// <param name="t">0.0ã€œ1.0ã®è£œé–“å€¤</param>
   /// <returns>è£œé–“å¾Œã®å€¤</returns>
   static float InQuint(float t) 
   {
       return t * t * t * t * t;
   }

   /// <summary>
   /// ã‚¤ãƒ¼ã‚ºã‚¢ã‚¦ãƒˆ(æ¸›é€Ÿ)
   /// </summary>
   /// <param name="t">0.0ã€œ1.0ã®è£œé–“å€¤</param>
   /// <returns>è£œé–“å¾Œã®å€¤</returns>
   static float OutQuad(float t)
   {
       return 1.0f - (1.0f - t) * (1.0f - t);
   }

   /// <summary>
   /// ã‚¤ãƒ¼ã‚ºã‚¢ã‚¦ãƒˆ(æ¸›é€Ÿ)
   /// </summary>
   /// <param name="t">0.0ã€œ1.0ã®è£œé–“å€¤</param>
   /// <returns>è£œé–“å¾Œã®å€¤</returns>
   static float OutCubic(float t)
   {
       return 1.0f - std::pow(1.0f - t, 3.0f);
   }

   /// <summary>
   /// ã‚¤ãƒ¼ã‚ºã‚¢ã‚¦ãƒˆ(æ¸›é€Ÿ)
   /// </summary>
   /// <param name="t">0.0ã€œ1.0ã®è£œé–“å€¤</param>
   /// <returns>è£œé–“å¾Œã®å€¤</returns>
   static float OutQuart(float t)
   {
       return 1.0f - std::pow(1.0f - t, 4.0f);
   }

   /// <summary>
   /// ã‚¤ãƒ¼ã‚ºã‚¢ã‚¦ãƒˆ(æ¸›é€Ÿ)
   /// </summary>
   /// <param name="t">0.0ã€œ1.0ã®è£œé–“å€¤</param>
   /// <returns>è£œé–“å¾Œã®å€¤</returns>
   static float OutQuint(float t) 
   {
       return 1.0f - std::pow(1.0f - t, 5.0f);
   }

   /// <summary>
   /// ã‚¤ãƒ¼ã‚ºã‚¤ãƒ³ã‚¢ã‚¦ãƒˆ(åŠ é€Ÿâ†’æ¸›é€Ÿ)
   /// </summary>
   /// <param name="t">0.0ã€œ1.0ã®è£œé–“å€¤</param>
   /// <returns>è£œé–“å¾Œã®å€¤</returns>
   static float InOutQuad(float t)
   {
       return t < 0.5f ? 2.0f * t * t : 1.0f - std::pow(-2.0f * t + 2.0f, 2.0f) / 2.0f;
   }

   /// <summary>
   /// ã‚¤ãƒ¼ã‚ºã‚¤ãƒ³ã‚¢ã‚¦ãƒˆ(åŠ é€Ÿâ†’æ¸›é€Ÿ)
   /// </summary>
   /// <param name="t">0.0ã€œ1.0ã®è£œé–“å€¤</param>
   /// <returns>è£œé–“å¾Œã®å€¤</returns>
   static float InOutCubic(float t)
   {
       return t < 0.5f ? 4.0f * t * t * t : 1.0f - static_cast<float>(std::pow(-2.0f * t + 2.0f, 3.0f)) / 2.0f;
   }

   /// <summary>
   /// ã‚¤ãƒ¼ã‚ºã‚¤ãƒ³ã‚¢ã‚¦ãƒˆ(åŠ é€Ÿâ†’æ¸›é€Ÿ)
   /// </summary>
   /// <param name="t">0.0ã€œ1.0ã®è£œé–“å€¤</param>
   /// <returns>è£œé–“å¾Œã®å€¤</returns>
   static float InOutQuart(float t) 
   {
       return t < 0.5f ? 8.0f * static_cast<float>(std::pow(t, 4.0f)) : 1.0f - static_cast<float>(std::pow(-2.0f * t + 2.0f, 4.0f)) / 2.0f;
   }

   /// <summary>
   /// ã‚¤ãƒ¼ã‚ºã‚¤ãƒ³ã‚¢ã‚¦ãƒˆ(åŠ é€Ÿâ†’æ¸›é€Ÿ)
   /// </summary>
   /// <param name="t">0.0ã€œ1.0ã®è£œé–“å€¤</param>
   /// <returns>è£œé–“å¾Œã®å€¤</returns>
   static float InOutQuint(float t)
   {
       return t < 0.5f ? 16.0f * static_cast<float>(std::pow(t, 5.0f)) : 1.0f - static_cast<float>(std::pow(-2.0f * t + 2.0f, 5.0f)) / 2.0f;
   }
   
   /// <summary>
   /// ãƒã‚¦ãƒ³ã‚¹
   /// </summary>
   /// <param name="t">0.0ã€œ1.0ã®è£œé–“å€¤</param>
   /// <returns>è£œé–“å¾Œã®å€¤</returns>
   static float OutBounce(float t) 
   {
       const float n1 = 7.5625f;
       const float d1 = 2.75f;

       if (t < 1 / d1)
       {
           return n1 * t * t;
       }
       else if (t < 2 / d1) 
       {
           t -= 1.5f / d1;
           return n1 * t * t + 0.75f;
       }
       else if (t < 2.5f / d1) 
       {
           t -= 2.25f / d1;
           return n1 * t * t + 0.9375f;
       }
       else
       {
           t -= 2.625f / d1;
           return n1 * t * t + 0.984375f;
       }
   }

   /// <summary>
   /// ãƒãƒƒã‚¯ã‚¢ã‚¦ãƒˆ(ãƒã‚¦ãƒ³ãƒ‰çš„ã«å‡ºç¾)
   /// </summary>
   /// <param name="t">0.0ã€œ1.0ã®è£œé–“å€¤</param>
   /// <returns>è£œé–“å¾Œã®å€¤</returns>
   static float OutBack(float t) 
   {
       const float c1 = 1.70158f;
       const float c3 = c1 + 1.0f;

       float t1 = t - 1.0f;
       return 1.0f + c3 * static_cast<float>(std::pow(t1, 3.0f)) + c1 * static_cast<float>(std::pow(t1, 2.0f));
   }

   /// <summary>
   /// ã‚¤ãƒ¼ã‚ºã‚¤ãƒ³ã‚µã‚¤ãƒ³
   /// </summary>
   /// <param name="t">0.0ã€œ1.0ã®è£œé–“å€¤</param>
   /// <returns>è£œé–“å¾Œã®å€¤</returns>
   static float InSine(float t)
   {
       return 1.0f - std::cos((t * pi) / 2.0f);
   }

   /// <summary>
   /// ã‚¤ãƒ¼ã‚ºã‚¢ã‚¦ãƒˆã‚µã‚¤ãƒ³
   /// </summary>
   /// <param name="t">0.0ã€œ1.0ã®è£œé–“å€¤</param>
   /// <returns>è£œé–“å¾Œã®å€¤</returns>
   static float OutSine(float t)
   {
       return std::sin((t * pi) / 2.0f);
   }

   /// <summary>
   /// ã‚¤ãƒ¼ã‚ºã‚¤ãƒ³ã‚¢ã‚¦ãƒˆã‚µã‚¤ãƒ³
   /// </summary>
   /// <param name="t">0.0ã€œ1.0ã®è£œé–“å€¤</param>
   /// <returns>è£œé–“å¾Œã®å€¤</returns>
   static float InOutSine(float t)
   {
       return -(std::cos(pi * t) - 1.0f) / 2.0f;
   }

};


============================================================
File Path: project/gameEngine/math/Matrix4x4.cpp
============================================================
#include "Matrix4x4.h"
#include "Vector3.h"

#include <cmath>

Matrix4x4 Matrix4x4::operator-() const
{
    Matrix4x4 result{};

    for (int i = 0; i < 4; i++)
        for (int j = 0; j < 4; j++)
            result.m[i][j] = -m[i][j];

    return result;
}

void Matrix4x4::SetIdentity()
{
    for (int i = 0; i < 4; i++)
        m[i][i] = 1;
    return;
}

Matrix4x4 Matrix4x4::Identity()
{
    Matrix4x4 result{};

    for (int i = 0; i < 4; i++)
        result.m[i][i] = 1;

    return result;
}

Matrix4x4 Matrix4x4::RotateXMatrix(float _radian)
{
    Matrix4x4 result{};

    result.m[0][0] = 1.0f;
    result.m[1][1] = std::cosf(_radian);
    result.m[1][2] = std::sinf(_radian);
    result.m[2][1] = -std::sinf(_radian);
    result.m[2][2] = std::cosf(_radian);
    result.m[3][3] = 1.0f;

    return result;
}

Matrix4x4 Matrix4x4::RotateYMatrix(float _radian)
{
    Matrix4x4 result{};

    result.m[1][1] = 1.0f;
    result.m[3][3] = 1.0f;
    result.m[0][0] = std::cosf(_radian);
    result.m[0][2] = -std::sinf(_radian);
    result.m[2][0] = std::sinf(_radian);
    result.m[2][2] = std::cosf(_radian);

    return result;
}

Matrix4x4 Matrix4x4::RotateZMatrix(float _radian)
{
    Matrix4x4 result{};

    for (int i = 3; i > 1; --i)
    {
        result.m[i][i] = 1.0f;
    }
    result.m[0][0] = std::cos(_radian);
    result.m[1][0] = -std::sin(_radian);
    result.m[0][1] = std::sin(_radian);
    result.m[1][1] = std::cos(_radian);

    return result;
}

Matrix4x4 Matrix4x4::AffineMatrix(const Vector3& _scale, const Vector3& _rotate, const Vector3& _translate)
{
    Matrix4x4 result{};
    Matrix4x4 rotateMatrix = RotateXMatrix(_rotate.x) * (RotateYMatrix(_rotate.y) * RotateZMatrix(_rotate.z));

    for (int i = 0; i < 3; i++)
    {
        result.m[0][i] = _scale.x * rotateMatrix.m[0][i];
        result.m[1][i] = _scale.y * rotateMatrix.m[1][i];
        result.m[2][i] = _scale.z * rotateMatrix.m[2][i];
    }
    result.m[3][0] = _translate.x;
    result.m[3][1] = _translate.y;
    result.m[3][2] = _translate.z;

    result.m[3][3] = 1.0f;

    return result;
}

Matrix4x4 Matrix4x4::PerspectiveFovMatrix(float _fovY, float _aspectRatio, float _nearClip, float _farClip)
{
    Matrix4x4 result{};

    float _h = 1.0f / std::tan(_fovY / 2.0f);
    float _w = _h / _aspectRatio;

    result.m[0][0] = _w;
    result.m[1][1] = _h;
    result.m[2][2] = _farClip / (_farClip - _nearClip);
    result.m[2][3] = 1.0f;
    result.m[3][2] = -_nearClip * _farClip / (_farClip - _nearClip);
    result.m[3][3] = 0.0f;

    return result;
}

Matrix4x4 Matrix4x4::OrthographicMatrix(float _left, float _top, float _right, float _bottom, float _nearClip, float _farClip)
{
    Matrix4x4 result{};

    result.m[0][0] = 2.0f / (_right - _left);
    result.m[1][1] = 2.0f / (_top - _bottom);
    result.m[2][2] = 1.0f / (_farClip - _nearClip);
    result.m[3][0] = -(_right + _left) / (_right - _left);
    result.m[3][1] = -(_top + _bottom) / (_top - _bottom);
    result.m[3][2] = -_nearClip / (_farClip - _nearClip);
    result.m[3][3] = 1.0f;

    return result;
}

Matrix4x4 Matrix4x4::ViewportMatrix(float _left, float _top, float _width, float _height, float _minDepth, float _maxDepth)
{
    Matrix4x4 result{};

    result.m[0][0] = _width / 2.0f;
    result.m[1][1] = -_height / 2.0f;
    result.m[2][2] = _maxDepth - _minDepth;
    result.m[3][0] = _left + _width / 2.0f;
    result.m[3][1] = _top + _height / 2.0f;
    result.m[3][2] = _minDepth;

    return result;
}

Matrix4x4 Matrix4x4::ScaleMatrix(const Vector3& _scale)
{
    Matrix4x4 result{};

    for (int i = 0; i < 4; i++)
    {
        if (i == 3)
        {
            result.m[i][i] = 1.0f;
            break;
        }
        result.m[i][i] = *(&_scale.x + i);
    }

    return result;
}

Matrix4x4 Matrix4x4::TranslateMatrix(const Vector3& _translate)
{
    Matrix4x4 result{};

    for (int i = 0; i < 4; i++) result.m[i][i] = 1.0f;

    result.m[3][0] += _translate.x;
    result.m[3][1] += _translate.y;
    result.m[3][2] += _translate.z;

    return result;
}

Matrix4x4 Matrix4x4::Inverse() const
{
    Matrix4x4 result{};

#pragma region è¡Œåˆ—å¼ã®è¨ˆç®—
    float _a_ =
        m[0][0] * m[1][1] * m[2][2] * m[3][3] +
        m[0][0] * m[1][2] * m[2][3] * m[3][1] +
        m[0][0] * m[1][3] * m[2][1] * m[3][2] -
        m[0][0] * m[1][3] * m[2][2] * m[3][1] -
        m[0][0] * m[1][2] * m[2][1] * m[3][3] -
        m[0][0] * m[1][1] * m[2][3] * m[3][2] -
        m[0][1] * m[1][0] * m[2][2] * m[3][3] -
        m[0][2] * m[1][0] * m[2][3] * m[3][1] -
        m[0][3] * m[1][0] * m[2][1] * m[3][2] +
        m[0][3] * m[1][0] * m[2][2] * m[3][1] +
        m[0][2] * m[1][0] * m[2][1] * m[3][3] +
        m[0][1] * m[1][0] * m[2][3] * m[3][2] +
        m[0][1] * m[1][2] * m[2][0] * m[3][3] +
        m[0][2] * m[1][3] * m[2][0] * m[3][1] +
        m[0][3] * m[1][1] * m[2][0] * m[3][2] -
        m[0][3] * m[1][2] * m[2][0] * m[3][1] -
        m[0][2] * m[1][1] * m[2][0] * m[3][3] -
        m[0][1] * m[1][3] * m[2][0] * m[3][2] -
        m[0][1] * m[1][2] * m[2][3] * m[3][0] -
        m[0][2] * m[1][3] * m[2][1] * m[3][0] -
        m[0][3] * m[1][1] * m[2][2] * m[3][0] +
        m[0][3] * m[1][2] * m[2][1] * m[3][0] +
        m[0][2] * m[1][1] * m[2][3] * m[3][0] +
        m[0][1] * m[1][3] * m[2][2] * m[3][0];
#pragma endregion

#pragma region å„æˆåˆ†ã®è¨ˆç®—
    // ä¸€è¡Œç›®
    result.m[0][0] =
        m[1][1] * m[2][2] * m[3][3] +
        m[1][2] * m[2][3] * m[3][1] +
        m[1][3] * m[2][1] * m[3][2] -
        m[1][3] * m[2][2] * m[3][1] -
        m[1][2] * m[2][1] * m[3][3] -
        m[1][1] * m[2][3] * m[3][2];
    result.m[0][1] =
        -m[0][1] * m[2][2] * m[3][3] -
        m[0][2] * m[2][3] * m[3][1] -
        m[0][3] * m[2][1] * m[3][2] +
        m[0][3] * m[2][2] * m[3][1] +
        m[0][2] * m[2][1] * m[3][3] +
        m[0][1] * m[2][3] * m[3][2];
    result.m[0][2] =
        m[0][1] * m[1][2] * m[3][3] +
        m[0][2] * m[1][3] * m[3][1] +
        m[0][3] * m[1][1] * m[3][2] -
        m[0][3] * m[1][2] * m[3][1] -
        m[0][2] * m[1][1] * m[3][3] -
        m[0][1] * m[1][3] * m[3][2];
    result.m[0][3] =
        -m[0][1] * m[1][2] * m[2][3] -
        m[0][2] * m[1][3] * m[2][1] -
        m[0][3] * m[1][1] * m[2][2] +
        m[0][3] * m[1][2] * m[2][1] +
        m[0][2] * m[1][1] * m[2][3] +
        m[0][1] * m[1][3] * m[2][2];
    // 2è¡Œç›®
    result.m[1][0] =
        -m[1][0] * m[2][2] * m[3][3] -
        m[1][2] * m[2][3] * m[3][0] -
        m[1][3] * m[2][0] * m[3][2] +
        m[1][3] * m[2][2] * m[3][0] +
        m[1][2] * m[2][0] * m[3][3] +
        m[1][0] * m[2][3] * m[3][2];
    result.m[1][1] =
        m[0][0] * m[2][2] * m[3][3] +
        m[0][2] * m[2][3] * m[3][0] +
        m[0][3] * m[2][0] * m[3][2] -
        m[0][3] * m[2][2] * m[3][0] -
        m[0][2] * m[2][0] * m[3][3] -
        m[0][0] * m[2][3] * m[3][2];
    result.m[1][2] =
        -m[0][0] * m[1][2] * m[3][3] -
        m[0][2] * m[1][3] * m[3][0] -
        m[0][3] * m[1][0] * m[3][2] +
        m[0][3] * m[1][2] * m[3][0] +
        m[0][2] * m[1][0] * m[3][3] +
        m[0][0] * m[1][3] * m[3][2];
    result.m[1][3] =
        m[0][0] * m[1][2] * m[2][3] +
        m[0][2] * m[1][3] * m[2][0] +
        m[0][3] * m[1][0] * m[2][2] -
        m[0][3] * m[1][2] * m[2][0] -
        m[0][2] * m[1][0] * m[2][3] -
        m[0][0] * m[1][3] * m[2][2];
    // 3è¡Œç›®
    result.m[2][0] =
        m[1][0] * m[2][1] * m[3][3] +
        m[1][1] * m[2][3] * m[3][0] +
        m[1][3] * m[2][0] * m[3][1] -
        m[1][3] * m[2][1] * m[3][0] -
        m[1][1] * m[2][0] * m[3][3] -
        m[1][0] * m[2][3] * m[3][1];
    result.m[2][1] =
        -m[0][0] * m[2][1] * m[3][3] -
        m[0][1] * m[2][3] * m[3][0] -
        m[0][3] * m[2][0] * m[3][1] +
        m[0][3] * m[2][1] * m[3][0] +
        m[0][1] * m[2][0] * m[3][3] +
        m[0][0] * m[2][3] * m[3][1];
    result.m[2][2] =
        m[0][0] * m[1][1] * m[3][3] +
        m[0][1] * m[1][3] * m[3][0] +
        m[0][3] * m[1][0] * m[3][1] -
        m[0][3] * m[1][1] * m[3][0] -
        m[0][1] * m[1][0] * m[3][3] -
        m[0][0] * m[1][3] * m[3][1];
    result.m[2][3] =
        -m[0][0] * m[1][1] * m[2][3] -
        m[0][1] * m[1][3] * m[2][0] -
        m[0][3] * m[1][0] * m[2][1] +
        m[0][3] * m[1][1] * m[2][0] +
        m[0][1] * m[1][0] * m[2][3] +
        m[0][0] * m[1][3] * m[2][1];
    // 4è¡Œç›®
    result.m[3][0] =
        -m[1][0] * m[2][1] * m[3][2] -
        m[1][1] * m[2][2] * m[3][0] -
        m[1][2] * m[2][0] * m[3][1] +
        m[1][2] * m[2][1] * m[3][0] +
        m[1][1] * m[2][0] * m[3][2] +
        m[1][0] * m[2][2] * m[3][1];
    result.m[3][1] =
        m[0][0] * m[2][1] * m[3][2] +
        m[0][1] * m[2][2] * m[3][0] +
        m[0][2] * m[2][0] * m[3][1] -
        m[0][2] * m[2][1] * m[3][0] -
        m[0][1] * m[2][0] * m[3][2] -
        m[0][0] * m[2][2] * m[3][1];
    result.m[3][2] =
        -m[0][0] * m[1][1] * m[3][2] -
        m[0][1] * m[1][2] * m[3][0] -
        m[0][2] * m[1][0] * m[3][1] +
        m[0][2] * m[1][1] * m[3][0] +
        m[0][1] * m[1][0] * m[3][2] +
        m[0][0] * m[1][2] * m[3][1];
    result.m[3][3] =
        m[0][0] * m[1][1] * m[2][2] +
        m[0][1] * m[1][2] * m[2][0] +
        m[0][2] * m[1][0] * m[2][1] -
        m[0][2] * m[1][1] * m[2][0] -
        m[0][1] * m[1][0] * m[2][2] -
        m[0][0] * m[1][2] * m[2][1];

#pragma endregion

#pragma region å„æˆåˆ† / è¡Œåˆ—å¼
    for (int i = 0; i < 4; i++)
        for (int j = 0; j < 4; j++)
        {
            result.m[i][j] /= _a_;
        }
#pragma endregion

    return result;
}

Matrix4x4 Matrix4x4::Transpose() const
{
    Matrix4x4 result{};

    for (int i = 0; i < 4; i++)
        for (int j = 0; j < 4; j++)
            result.m[i][j] = m[j][i];

    return result;
}

Matrix4x4& Matrix4x4::operator+=(const Matrix4x4& _rm)
{
    for (int i = 0; i < 4; i++)
    {
        for (int j = 0; j < 4; j++)
        {
            m[i][j] += _rm.m[i][j];
        }
    }
    return *this;
}

Matrix4x4& Matrix4x4::operator-=(const Matrix4x4& _rm)
{
    for (int i = 0; i < 4; i++)
    {
        for (int j = 0; j < 4; j++)
        {
            m[i][j] -= _rm.m[i][j];
        }
    }
    return *this;
}

Matrix4x4& Matrix4x4::operator*=(const Matrix4x4& _rm)
{
    for (int i = 0; i < 4; i++)
    {
        for (int j = 0; j < 4; j++)
        {
            m[i][j] *= _rm.m[i][j];
        }
    }
    return *this;
}

Matrix4x4 Matrix4x4::operator*(const Matrix4x4& _rm) const
{
    Matrix4x4 result{};

    for (int off = 0; off < 4; off++)
        for (int i = 0; i < 4; i++)
            for (int j = 0; j < 4; j++)
                result.m[off][i] += m[off][j] * _rm.m[j][i];

    return result;
}

Matrix4x4 Matrix4x4::operator+(const Matrix4x4& _rm) const
{
    Matrix4x4 result{};

    for (int i = 0; i < 4; i++)
        for (int j = 0; j < 4; j++)
            result.m[i][j] = m[i][j] + _rm.m[i][j];

    return result;
}

Matrix4x4 Matrix4x4::operator-(const Matrix4x4& _rm) const
{
    Matrix4x4 result{};

    for (int i = 0; i < 4; i++)
        for (int j = 0; j < 4; j++)
            result.m[i][j] = m[i][j] - _rm.m[i][j];

    return result;
}


============================================================
File Path: project/gameEngine/math/Matrix4x4.h
============================================================
#pragma once

// å‰æ–¹å®£è¨€
class Vector3;

/// <summary>
/// 4x4è¡Œåˆ—
/// </summary>
class Matrix4x4 {
public:
    float m[4][4];

    /// ====================
    /// Minus Sign
    /// ====================
    Matrix4x4 operator-() const;

    /// =====================
    /// Make Matrix
    /// =====================

    /// <summary>
    /// å˜ä½è¡Œåˆ—ã‚’è¨­å®š
    /// </summary>
    void SetIdentity();

	/// <summary>
	/// å˜ä½è¡Œåˆ—ã‚’å–å¾—
	/// </summary>
    /// <returns>å˜ä½è¡Œåˆ—</returns>
    static Matrix4x4 Identity();

	/// <summary>
	/// Xå›žè»¢è¡Œåˆ—
	/// </summary>
	/// <param name="_radian">ãƒ©ã‚¸ã‚¢ãƒ³</param>
    /// <returns>Xå›žè»¢è¡Œåˆ—</returns>
    static Matrix4x4 RotateXMatrix(float _radian);

	/// <summary>
	/// Yå›žè»¢è¡Œåˆ—
	/// </summary>
	/// <param name="_radian">ãƒ©ã‚¸ã‚¢ãƒ³</param>
    /// <returns>Yå›žè»¢è¡Œåˆ—</returns>
    static Matrix4x4 RotateYMatrix(float _radian);

	/// <summary>
	/// Zå›žè»¢è¡Œåˆ—
	/// </summary>
	/// <param name="_radian">ãƒ©ã‚¸ã‚¢ãƒ³</param>
    /// <returns>Zå›žè»¢è¡Œåˆ—</returns>
    static Matrix4x4 RotateZMatrix(float _radian);

    /// <summary>
    /// ã‚¢ãƒ•ã‚£ãƒ³å¤‰æ›è¡Œåˆ—
    /// </summary>
    /// <param name="_scale">æ‹¡ç¸®å€çŽ‡</param>
    /// <param name="_rotate">è§’åº¦</param>
    /// <param name="_translate">åº§æ¨™</param>
	/// <returns>ã‚¢ãƒ•ã‚£ãƒ³å¤‰æ›è¡Œåˆ—</returns>
    static Matrix4x4 AffineMatrix(
        const Vector3& _scale,
        const Vector3& _rotate,
        const Vector3& _translate
    );

    /// <summary>
    /// é€è¦–æŠ•å½±è¡Œåˆ—
    /// </summary>
    /// <param name="_fovY">è¦–é‡Žè§’</param>
    /// <param name="_aspectRatio">ã‚¢ã‚¹ãƒšã‚¯ãƒˆæ¯”</param>
    /// <param name="_nearClip">è¿‘ã‚¯ãƒªãƒƒãƒ—</param>
    /// <param name="_farClip">é ã‚¯ãƒªãƒƒãƒ—</param>
	/// <returns>é€è¦–æŠ•å½±è¡Œåˆ—</returns>
    static Matrix4x4 PerspectiveFovMatrix(
        float _fovY,
        float _aspectRatio,
        float _nearClip,
        float _farClip
    );

    /// <summary>
    /// æ­£å°„å½±è¡Œåˆ—
    /// </summary>
    /// <param name="_left">å·¦</param>
    /// <param name="_top">ä¸Š</param>
    /// <param name="_right">å³</param>
    /// <param name="_bottom">ä¸‹</param>
    /// <param name="_nearClip">è¿‘ã‚¯ãƒªãƒƒãƒ—</param>
    /// <param name="_farClip">é ã‚¯ãƒªãƒƒãƒ—</param>
	/// <returns>æ­£å°„å½±è¡Œåˆ—</returns>
    static Matrix4x4 OrthographicMatrix(
        float _left,
        float _top,
        float _right,
        float _bottom,
        float _nearClip,
        float _farClip
    );

    /// <summary>
    /// ãƒ“ãƒ¥ãƒ¼ãƒãƒ¼ãƒˆå¤‰æ›è¡Œåˆ—
    /// </summary>
    /// <param name="_left">å·¦</param>
    /// <param name="_top">ä¸Š</param>
    /// <param name="_width">å¹…</param>
    /// <param name="_height">é«˜ã•</param>
    /// <param name="_minDepth">æœ€å°æ·±åº¦</param>
    /// <param name="_maxDepth">æœ€å¤§æ·±åº¦</param>
	/// <returns>ãƒ“ãƒ¥ãƒ¼ãƒãƒ¼ãƒˆå¤‰æ›è¡Œåˆ—</returns>
    static Matrix4x4 ViewportMatrix(
        float _left,
        float _top,
        float _width,
        float _height,
        float _minDepth,
        float _maxDepth
    );

    /// <summary>
    /// æ‹¡å¤§è¡Œåˆ—
    /// </summary>
    /// <param name="_scale">æ‹¡å¤§çŽ‡</param>
	/// <returns>æ‹¡å¤§è¡Œåˆ—</returns>
    static Matrix4x4 ScaleMatrix(const Vector3& _scale);

    /// <summary>
    /// ç§»å‹•è¡Œåˆ—
    /// </summary>
    /// <param name="_translate">ç§»å‹•é‡</param>
	/// <returns>ç§»å‹•è¡Œåˆ—</returns>
    static Matrix4x4 TranslateMatrix(const Vector3& _translate);

	/// <summary>
	/// é€†è¡Œåˆ—
	/// </summary>
    /// <returns>é€†è¡Œåˆ—</returns>
    Matrix4x4 Inverse() const;

	/// <summary>
	/// è»¢ç½®è¡Œåˆ—
	/// </summary>
    /// <returns>è»¢ç½®è¡Œåˆ—</returns>
    Matrix4x4 Transpose() const;

    
    Matrix4x4& operator+=(const Matrix4x4& _rm);
    Matrix4x4& operator-=(const Matrix4x4& _rm);
    Matrix4x4& operator*=(const Matrix4x4& _rm);
    Matrix4x4 operator*(const Matrix4x4& _rm) const;
    Matrix4x4 operator+(const Matrix4x4& _rm) const;
    Matrix4x4 operator-(const Matrix4x4& _rm) const;
};

============================================================
File Path: project/gameEngine/math/MyMath.cpp
============================================================
#include "MyMath.h"

// å†…ç©
float Dot(const Vector3& v1, const Vector3& v2) {
	float result;
	result = v1.x * v2.x + v1.y * v2.y + v1.z * v2.z;
	return result;
}
// é•·ã•
float Length(const Vector3& v) {
	float result;
	result = sqrtf(v.x * v.x + v.y * v.y + v.z * v.z);
	return result;
}
// æ­£è¦åŒ– v/||v||
Vector3 Normalize(const Vector3& v) {
	Vector3 result;
	result.x = v.x / sqrtf(v.x * v.x + v.y * v.y + v.z * v.z);
	result.y = v.y / sqrtf(v.x * v.x + v.y * v.y + v.z * v.z);
	result.z = v.z / sqrtf(v.x * v.x + v.y * v.y + v.z * v.z);
	return result;
}
// ã‚¯ãƒ­ã‚¹ç©
Vector3 Cross(const Vector3& v1, const Vector3& v2) {
	Vector3 result;
	result = { v1.y * v2.z - v1.z * v2.y, v1.z * v2.x - v1.x * v2.z, v1.x * v2.y - v1.y * v2.x };

	return result;
}
// ãƒ™ã‚¯ãƒˆãƒ«å¤‰æ›
Vector3 TransformNormal(const Vector3& v, const Matrix4x4& m) {
	Vector3 result{
		v.x * m.m[0][0] + v.y * m.m[1][0] + v.z * m.m[2][0],
		v.x * m.m[0][1] + v.y * m.m[1][1] + v.z * m.m[2][1],
		v.x * m.m[0][2] + v.y * m.m[1][2] + v.z * m.m[2][2],
	};

	return result;
}

// -----è¡Œåˆ—-----
// è¡Œåˆ—ã®ç©
Matrix4x4 Multiply(const Matrix4x4& m1, const Matrix4x4& m2) {
	Matrix4x4 result;

	for (int row = 0; row < 4; row++) {
		for (int column = 0; column < 4; column++) {
			result.m[row][column] = m1.m[row][0] * m2.m[0][column] + m1.m[row][1] * m2.m[1][column] + m1.m[row][2] * m2.m[2][column] + m1.m[row][3] * m2.m[3][column];
		}
	}
	return result;
}

// å¹³è¡Œç§»å‹•è¡Œåˆ—
Matrix4x4 MakeTranslateMatrix(const Vector3& translate) {
	Matrix4x4 result;

	result.m[0][0] = 1;
	result.m[0][1] = 0;
	result.m[0][2] = 0;
	result.m[0][3] = 0;

	result.m[1][0] = 0;
	result.m[1][1] = 1;
	result.m[1][2] = 0;
	result.m[1][3] = 0;

	result.m[2][0] = 0;
	result.m[2][1] = 0;
	result.m[2][2] = 1;
	result.m[2][3] = 0;

	result.m[3][0] = translate.x;
	result.m[3][1] = translate.y;
	result.m[3][2] = translate.z;
	result.m[3][3] = 1;

	return result;
}
// æ‹¡å¤§ç¸®å°è¡Œåˆ—
Matrix4x4 MakeScaleMatrix(const Vector3& scale) {
	Matrix4x4 result = {
			scale.x,0.0f,0.0f,0.0f,
			0.0f,scale.y,0.0f,0.0f,
			0.0f,0.0f,scale.z,0.0f,
			0.0f,0.0f,0.0f,1.0f
	};
	return result;
}
// å›žè»¢è¡Œåˆ—
Matrix4x4 MakeRotateXMatrix(float radian) {
	Matrix4x4 result;
	result = {
		1.0f, 0.0f, 0.0f, 0.0f, 0.0f, std::cos(radian), std::sin(radian), 0.0f, 0.0f, -std::sin(radian), std::cos(radian), 0.0f, 0.0f, 0.0f, 0.0f, 1.0f,
	};

	return result;
}

Matrix4x4 MakeRotateYMatrix(float radian) {
	Matrix4x4 result;
	result = {
		std::cos(radian), 0.0f, -std::sin(radian), 0.0f, 0.0f, 1.0f, 0.0f, 0.0f, std::sin(radian), 0.0f, std::cos(radian), 0.0f, 0.0f, 0.0f, 0.0f, 1.0f,
	};

	return result;
}

Matrix4x4 MakeRotateZMatrix(float radian) {
	Matrix4x4 result;
	result = {
		std::cos(radian), std::sin(radian), 0.0f, 0.0f, -std::sin(radian), std::cos(radian), 0.0f, 0.0f, 0.0f, 0.0f, 1.0f, 0.0f, 0.0f, 0.0f, 0.0f, 1.0f,
	};

	return result;
}
// ä»»æ„è»¸å›žè»¢è¡Œåˆ—
Matrix4x4 MakeRotateAxisAngle(const Vector3& axis, float angle)
{
	Vector3 normalizedAxis = Normalize(axis);
	float x = normalizedAxis.x;
	float y = normalizedAxis.y;
	float z = normalizedAxis.z;
	float cosAngle = cos(angle);
	float sinAngle = sin(angle);
	float oneMinusCos = 1.0f - cosAngle;

	Matrix4x4 rotationMatrix = {
	  cosAngle + x * x * oneMinusCos,       x * y * oneMinusCos + z * sinAngle, x * z * oneMinusCos - y * sinAngle, 0.0f,
	  y * x * oneMinusCos - z * sinAngle,   cosAngle + y * y * oneMinusCos,     y * z * oneMinusCos + x * sinAngle, 0.0f,
	  z * x * oneMinusCos + y * sinAngle,   z * y * oneMinusCos - x * sinAngle, cosAngle + z * z * oneMinusCos,     0.0f,
	  0.0f,                                 0.0f,                               0.0f,                               1.0f
	};

	return rotationMatrix;
}
// ãƒ™ã‚¯ãƒˆãƒ«ã‹ã‚‰ãƒ™ã‚¯ãƒˆãƒ«ã¸ã®å¤‰æ›è¡Œåˆ—
Matrix4x4 DirectionToDirection(const Vector3& from, const Vector3& to)
{
	Vector3 fromNormalized = Normalize(from);
	Vector3 toNormalized = Normalize(to);
	float dotProduct = Dot(fromNormalized, toNormalized);

	// from ã¨ to ãŒå¹³è¡Œã¾ãŸã¯åå¹³è¡Œã®å ´åˆã®ç‰¹åˆ¥ãªå‡¦ç†
	if (dotProduct > 0.9999f) {
		// from ã¨ to ãŒåŒã˜æ–¹å‘ã‚’å‘ã„ã¦ã„ã‚‹å ´åˆã€å˜ä½è¡Œåˆ—ã‚’è¿”ã™
		return Matrix4x4{
			1.0f, 0.0f, 0.0f, 0.0f,
			0.0f, 1.0f, 0.0f, 0.0f,
			0.0f, 0.0f, 1.0f, 0.0f,
			0.0f, 0.0f, 0.0f, 1.0f
		};
	}
	else if (dotProduct < -0.9999f) {
		// from ã¨ to ãŒåå¯¾æ–¹å‘ã‚’å‘ã„ã¦ã„ã‚‹å ´åˆã€ä»»æ„ã®åž‚ç›´ãƒ™ã‚¯ãƒˆãƒ«ã‚’è»¸ã¨ã—ã¦180åº¦å›žè»¢è¡Œåˆ—ã‚’ä½œæˆ
		Vector3 orthogonalAxis = (fabs(fromNormalized.x) > fabs(fromNormalized.z)) ? Vector3{ -fromNormalized.y, fromNormalized.x, 0.0f } : Vector3{ 0.0f, -fromNormalized.z, fromNormalized.y };
		orthogonalAxis = Normalize(orthogonalAxis);
		return MakeRotateAxisAngle(orthogonalAxis, 3.14159265358979323846f); // 180åº¦å›žè»¢
	}

	Vector3 axis = Cross(fromNormalized, toNormalized);
	float angle = acos(dotProduct);
	return MakeRotateAxisAngle(axis, angle);
}
// ã‚¢ãƒ•ã‚£ãƒ³å¤‰æ›è¡Œåˆ—
Matrix4x4 MakeAffineMatrix(const Vector3& scale, const Vector3& rotate, const Vector3& translate) {
	Matrix4x4 result;
	Matrix4x4 rotateXMatrix = MakeRotateXMatrix(rotate.x);
	Matrix4x4 rotateYMatrix = MakeRotateYMatrix(rotate.y);
	Matrix4x4 rotateZMatrix = MakeRotateZMatrix(rotate.z);
	Matrix4x4 rotateXYZMatrix = Multiply(rotateXMatrix, Multiply(rotateYMatrix, rotateZMatrix)); // R

	result = {
		scale.x * rotateXYZMatrix.m[0][0],
		scale.x * rotateXYZMatrix.m[0][1],
		scale.x * rotateXYZMatrix.m[0][2],
		0.0f,
		scale.y * rotateXYZMatrix.m[1][0],
		scale.y * rotateXYZMatrix.m[1][1],
		scale.y * rotateXYZMatrix.m[1][2],
		0.0f,
		scale.z * rotateXYZMatrix.m[2][0],
		scale.z * rotateXYZMatrix.m[2][1],
		scale.z * rotateXYZMatrix.m[2][2],
		0.0f,
		translate.x,
		translate.y,
		translate.z,
		1.0f };

	return result;
}

// é€†è¡Œåˆ—
Matrix4x4 Inverse(const Matrix4x4& m) {
	Matrix4x4 result;
	float a;
	Matrix4x4 b;

	a = 1 /
		(m.m[0][0] * m.m[1][1] * m.m[2][2] * m.m[3][3] + m.m[0][0] * m.m[1][2] * m.m[2][3] * m.m[3][1] + m.m[0][0] * m.m[1][3] * m.m[2][1] * m.m[3][2] - m.m[0][0] * m.m[1][3] * m.m[2][2] * m.m[3][1] -
			m.m[0][0] * m.m[1][2] * m.m[2][1] * m.m[3][3] - m.m[0][0] * m.m[1][1] * m.m[2][3] * m.m[3][2] - m.m[0][1] * m.m[1][0] * m.m[2][2] * m.m[3][3] - m.m[0][2] * m.m[1][0] * m.m[2][3] * m.m[3][1] -
			m.m[0][3] * m.m[1][0] * m.m[2][1] * m.m[3][2] + m.m[0][3] * m.m[1][0] * m.m[2][2] * m.m[3][1] + m.m[0][2] * m.m[1][0] * m.m[2][1] * m.m[3][3] + m.m[0][1] * m.m[1][0] * m.m[2][3] * m.m[3][2] +
			m.m[0][1] * m.m[1][2] * m.m[2][0] * m.m[3][3] + m.m[0][2] * m.m[1][3] * m.m[2][0] * m.m[3][1] + m.m[0][3] * m.m[1][1] * m.m[2][0] * m.m[3][2] - m.m[0][3] * m.m[1][2] * m.m[2][0] * m.m[3][1] -
			m.m[0][2] * m.m[1][1] * m.m[2][0] * m.m[3][3] - m.m[0][1] * m.m[1][3] * m.m[2][0] * m.m[3][2] - m.m[0][1] * m.m[1][2] * m.m[2][3] * m.m[3][0] - m.m[0][2] * m.m[1][3] * m.m[2][1] * m.m[3][0] -
			m.m[0][3] * m.m[1][1] * m.m[2][2] * m.m[3][0] + m.m[0][3] * m.m[1][2] * m.m[2][1] * m.m[3][0] + m.m[0][2] * m.m[1][1] * m.m[2][3] * m.m[3][0] + m.m[0][1] * m.m[1][3] * m.m[2][2] * m.m[3][0]);

	b.m[0][0] = m.m[1][1] * m.m[2][2] * m.m[3][3] + m.m[1][2] * m.m[2][3] * m.m[3][1] + m.m[1][3] * m.m[2][1] * m.m[3][2] - m.m[1][3] * m.m[2][2] * m.m[3][1] - m.m[1][2] * m.m[2][1] * m.m[3][3] -
		m.m[1][1] * m.m[2][3] * m.m[3][2];
	b.m[0][1] = -m.m[0][1] * m.m[2][2] * m.m[3][3] - m.m[0][2] * m.m[2][3] * m.m[3][1] - m.m[0][3] * m.m[2][1] * m.m[3][2] + m.m[0][3] * m.m[2][2] * m.m[3][1] + m.m[0][2] * m.m[2][1] * m.m[3][3] +
		m.m[0][1] * m.m[2][3] * m.m[3][2];
	b.m[0][2] = m.m[0][1] * m.m[1][2] * m.m[3][3] + m.m[0][2] * m.m[1][3] * m.m[3][1] + m.m[0][3] * m.m[1][1] * m.m[3][2] - m.m[0][3] * m.m[1][2] * m.m[3][1] - m.m[0][2] * m.m[1][1] * m.m[3][3] -
		m.m[0][1] * m.m[1][3] * m.m[3][2];
	b.m[0][3] = -m.m[0][1] * m.m[1][2] * m.m[2][3] - m.m[0][2] * m.m[1][3] * m.m[2][1] - m.m[0][3] * m.m[1][1] * m.m[2][2] + m.m[0][3] * m.m[1][2] * m.m[2][1] + m.m[0][2] * m.m[1][1] * m.m[2][3] +
		m.m[0][1] * m.m[1][3] * m.m[2][2];

	b.m[1][0] = -m.m[1][0] * m.m[2][2] * m.m[3][3] - m.m[1][2] * m.m[2][3] * m.m[3][0] - m.m[1][3] * m.m[2][0] * m.m[3][2] + m.m[1][3] * m.m[2][2] * m.m[3][0] + m.m[1][2] * m.m[2][0] * m.m[3][3] +
		m.m[1][0] * m.m[2][3] * m.m[3][2];
	b.m[1][1] = m.m[0][0] * m.m[2][2] * m.m[3][3] + m.m[0][2] * m.m[2][3] * m.m[3][0] + m.m[0][3] * m.m[2][0] * m.m[3][2] - m.m[0][3] * m.m[2][2] * m.m[3][0] - m.m[0][2] * m.m[2][0] * m.m[3][3] -
		m.m[0][0] * m.m[2][3] * m.m[3][2];
	b.m[1][2] = -m.m[0][0] * m.m[1][2] * m.m[3][3] - m.m[0][2] * m.m[1][3] * m.m[3][0] - m.m[0][3] * m.m[1][0] * m.m[3][2] + m.m[0][3] * m.m[1][2] * m.m[3][0] + m.m[0][2] * m.m[1][0] * m.m[3][3] +
		m.m[0][0] * m.m[1][3] * m.m[3][2];
	b.m[1][3] = +m.m[0][0] * m.m[1][2] * m.m[2][3] + m.m[0][2] * m.m[1][3] * m.m[2][0] + m.m[0][3] * m.m[1][0] * m.m[2][2] - m.m[0][3] * m.m[1][2] * m.m[2][0] - m.m[0][2] * m.m[1][0] * m.m[2][3] -
		m.m[0][0] * m.m[1][3] * m.m[2][2];

	b.m[2][0] = m.m[1][0] * m.m[2][1] * m.m[3][3] + m.m[1][1] * m.m[2][3] * m.m[3][0] + m.m[1][3] * m.m[2][0] * m.m[3][1] - m.m[1][3] * m.m[2][1] * m.m[3][0] - m.m[1][1] * m.m[2][0] * m.m[3][3] -
		m.m[1][0] * m.m[2][3] * m.m[3][1];
	b.m[2][1] = -m.m[0][0] * m.m[2][1] * m.m[3][3] - m.m[0][1] * m.m[2][3] * m.m[3][0] - m.m[0][3] * m.m[2][0] * m.m[3][1] + m.m[0][3] * m.m[2][1] * m.m[3][0] + m.m[0][1] * m.m[2][0] * m.m[3][3] +
		m.m[0][0] * m.m[2][3] * m.m[3][1];
	b.m[2][2] = m.m[0][0] * m.m[1][1] * m.m[3][3] + m.m[0][1] * m.m[1][3] * m.m[3][0] + m.m[0][3] * m.m[1][0] * m.m[3][1] - m.m[0][3] * m.m[1][1] * m.m[3][0] - m.m[0][1] * m.m[1][0] * m.m[3][3] -
		m.m[0][0] * m.m[1][3] * m.m[3][1];
	b.m[2][3] = -m.m[0][0] * m.m[1][1] * m.m[2][3] - m.m[0][1] * m.m[1][3] * m.m[2][0] - m.m[0][3] * m.m[1][0] * m.m[2][1] + m.m[0][3] * m.m[1][1] * m.m[2][0] + m.m[0][1] * m.m[1][0] * m.m[2][3] +
		m.m[0][0] * m.m[1][3] * m.m[2][1];

	b.m[3][0] = -m.m[1][0] * m.m[2][1] * m.m[3][2] - m.m[1][1] * m.m[2][2] * m.m[3][0] - m.m[1][2] * m.m[2][0] * m.m[3][1] + m.m[1][2] * m.m[2][1] * m.m[3][0] + m.m[1][1] * m.m[2][0] * m.m[3][2] +
		m.m[1][0] * m.m[2][2] * m.m[3][1];
	b.m[3][1] = +m.m[0][0] * m.m[2][1] * m.m[3][2] + m.m[0][1] * m.m[2][2] * m.m[3][0] + m.m[0][2] * m.m[2][0] * m.m[3][1] - m.m[0][2] * m.m[2][1] * m.m[3][0] - m.m[0][1] * m.m[2][0] * m.m[3][2] -
		m.m[0][0] * m.m[2][2] * m.m[3][1];
	b.m[3][2] = -m.m[0][0] * m.m[1][1] * m.m[3][2] - m.m[0][1] * m.m[1][2] * m.m[3][0] - m.m[0][2] * m.m[1][0] * m.m[3][1] + m.m[0][2] * m.m[1][1] * m.m[3][0] + m.m[0][1] * m.m[1][0] * m.m[3][2] +
		m.m[0][0] * m.m[1][2] * m.m[3][1];
	b.m[3][3] = m.m[0][0] * m.m[1][1] * m.m[2][2] + m.m[0][1] * m.m[1][2] * m.m[2][0] + m.m[0][2] * m.m[1][0] * m.m[2][1] - m.m[0][2] * m.m[1][1] * m.m[2][0] - m.m[0][1] * m.m[1][0] * m.m[2][2] -
		m.m[0][0] * m.m[1][2] * m.m[2][1];

	result.m[0][0] = a * b.m[0][0];
	result.m[0][1] = a * b.m[0][1];
	result.m[0][2] = a * b.m[0][2];
	result.m[0][3] = a * b.m[0][3];
	result.m[1][0] = a * b.m[1][0];
	result.m[1][1] = a * b.m[1][1];
	result.m[1][2] = a * b.m[1][2];
	result.m[1][3] = a * b.m[1][3];
	result.m[2][0] = a * b.m[2][0];
	result.m[2][1] = a * b.m[2][1];
	result.m[2][2] = a * b.m[2][2];
	result.m[2][3] = a * b.m[2][3];
	result.m[3][0] = a * b.m[3][0];
	result.m[3][1] = a * b.m[3][1];
	result.m[3][2] = a * b.m[3][2];
	result.m[3][3] = a * b.m[3][3];

	return result;
}
// è»¢ç½®è¡Œåˆ—
Matrix4x4 Transpose(const Matrix4x4& m) {
	Matrix4x4 result;

	for (int row = 0; row < 4; row++) {
		for (int column = 0; column < 4; column++) {
			if (row == column) {
				result.m[row][column] = m.m[row][column];
			}
			else {
				result.m[row][column] = m.m[column][row];
			}
		}
	}
	return result;
}
// é€†è»¢ç½®è¡Œåˆ—
Matrix4x4 InverseTranspose(const Matrix4x4& m)
{
	Matrix4x4 result = Inverse(m);
	result = Transpose(result);
	return result;
}
// å˜ä½è¡Œåˆ—ã®ä½œæˆ
Matrix4x4 MakeIdentity4x4() {
	Matrix4x4 result;

	for (int row = 0; row < 4; row++) {
		for (int column = 0; column < 4; column++) {
			if (row == column) {
				result.m[row][column] = 1;
			}
			else {
				result.m[row][column] = 0;
			}
		}
	}
	return result;
}

Matrix4x4 MakeOrthographicMatrix(float left, float top, float right, float bottom, float nearClip, float farClip) {
	return {
		2.0f / (right - left),0, 0, 0,
		0, 2.0f / (top - bottom), 0, 0,
		0, 0, 1.0f / (farClip - nearClip), 0,
		(left + right) / (left - right), (top + bottom) / (bottom - top), nearClip / (nearClip - farClip), 1.0f
	};
};
// vec * mat
Vector3 Multiply(const Vector3& vec, const Matrix4x4& mat) {
	Vector3 result;
	result.x = mat.m[0][0] * vec.x + mat.m[0][1] * vec.y + mat.m[0][2] * vec.z + mat.m[0][3] * 1.0f;
	result.y = mat.m[1][0] * vec.x + mat.m[1][1] * vec.y + mat.m[1][2] * vec.z + mat.m[1][3] * 1.0f;
	result.z = mat.m[2][0] * vec.x + mat.m[2][1] * vec.y + mat.m[2][2] * vec.z + mat.m[2][3] * 1.0f;
	// å¿µã®ãŸã‚ã€wæˆåˆ†ã‚‚è¨ˆç®—ã—ã¦ç¢ºèª
	float w = mat.m[3][0] * vec.x + mat.m[3][1] * vec.y + mat.m[3][2] * vec.z + mat.m[3][3] * 1.0f;
	if (w != 1.0f) {
		result.x /= w;
		result.y /= w;
		result.z /= w;
	}
	return result;
}

// -----åº§æ¨™ç³»-----
// é€è¦–æŠ•å½±è¡Œåˆ—
Matrix4x4 MakePerspectiveFovMatrix(float fovY, float aspectRatio, float nearClip, float farClip) {
	Matrix4x4 result;
	result = {
		1 / aspectRatio * (1 / std::tan(fovY / 2)), 0.0f, 0.0f, 0.0f,
		0.0f, 1 / std::tan(fovY / 2), 0.0f, 0.0f,
		0.0f, 0.0f, farClip / (farClip - nearClip), 1.0f,
		0.0f, 0.0f,	-nearClip * farClip / (farClip - nearClip), 0.0f,
	};

	return result;
}
// ãƒ“ãƒ¥ãƒ¼ãƒãƒ¼ãƒˆå¤‰æ›è¡Œåˆ—
Matrix4x4 MakeViewportMatrix(float left, float top, float width, float height, float minDepth, float maxDepth) {
	Matrix4x4 result;
	result = { width / 2, 0.0f, 0.0f, 0.0f,
		0.0f, -height / 2, 0.0f, 0.0f,
		0.0f, 0.0f, maxDepth - minDepth, 0.0f,
		left + (width / 2), top + (height / 2), minDepth, 1.0f
	};

	return result;
}
// åº§æ¨™å¤‰æ›
Vector3 Transform(const Vector3& vector, const Matrix4x4& matrix) {
	Vector3 result;
	result.x = vector.x * matrix.m[0][0] + vector.y * matrix.m[1][0] + vector.z * matrix.m[2][0] + 1.0f * matrix.m[3][0];
	result.y = vector.x * matrix.m[0][1] + vector.y * matrix.m[1][1] + vector.z * matrix.m[2][1] + 1.0f * matrix.m[3][1];
	result.z = vector.x * matrix.m[0][2] + vector.y * matrix.m[1][2] + vector.z * matrix.m[2][2] + 1.0f * matrix.m[3][2];
	float w = vector.x * matrix.m[0][3] + vector.y * matrix.m[1][3] + vector.z * matrix.m[2][3] + 1.0f * matrix.m[3][3];

	result.x /= w;
	result.y /= w;
	result.z /= w;
	return result;
}

// ç·šå½¢è£œé–“
float Lerp(const float& v1, const float& v2, float t)
{
	float result;
	result = v1 + t * (v2 - v1);
	return result;
}

// ãƒ™ã‚¯ãƒˆãƒ«ã®ç·šå½¢è£œé–“
Vector3 Lerp(const Vector3& v1, const Vector3& v2, float t)
{
	Vector3 result;
	result = (v1 + (t * (v2 - v1)));
	return result;
}

// ãƒ™ã‚¯ãƒˆãƒ«ã®ã‚¹ãƒ•ã‚§ãƒªã‚«ãƒ«è£œé–“
Vector3 Slerp(const Vector3& v1, const Vector3& v2, float t)
{

	Vector3 Nv1 = Normalize(v1);
	Vector3 Nv2 = Normalize(v2);

	float dot = Dot(Nv1, Nv2);

	dot = (std::min)(dot, 1.0f);
	float theta = std::acos(dot);
	float sinTheta = std::sin(theta);
	float sinThetaFrom = std::sin((1 - t) * theta);
	float sinThetaTo = std::sin(t * theta);

	Vector3 man;

	if (sinTheta < 1.0e-5) {
		man = Nv1;
	} else {
		man = (1 / sinTheta) * ((sinThetaFrom * Nv1) + (sinThetaTo * Nv2));
	}

	float length1 = Length(v1);
	float length2 = Length(v2);

	float length = Lerp(length1, length2, t);

	man = length * man;

	return man;
}

// è§’åº¦ã®ç·šå½¢è£œé–“
float LerpAngle(float a, float b, float t)
{
	float diff = std::fmod(b - a + 3.14159265f, 2.0f * 3.14159265f) - 3.14159265f;
	return a + diff * t;
}

Vector3 Bezier3(const Vector3& p0, const Vector3& p1, const Vector3& p2, const Vector3& p3, float t)
{
	float u = 1.0f - t;
	float tt = t * t;
	float uu = u * u;
	float uuu = uu * u;
	float ttt = tt * t;
	Vector3 p = uuu * p0; // (1-t)^3 * P0
	p += 3 * uu * t * p1; // 3*(1-t)^2*t*P1
	p += 3 * u * tt * p2; // 3*(1-t)*t^2*P2
	p += ttt * p3;        // t^3*P3
	return p;
}


============================================================
File Path: project/gameEngine/math/MyMath.h
============================================================
#pragma once

#include <cstdint>
#include <string>
#include <vector>
#include <cmath>

#include "Matrix4x4.h"
#include "Vector3.h"

struct Vector4
{
	float x;
	float y;
	float z;
	float w;
};

struct Matrix3x3
{
	float m[3][3];
};



/// <summary>
/// å†…ç©
/// </summary>
/// <param name="v1">vector1</param>
/// <param name="v2">vector2</param>
/// <returns>å†…ç©</returns>
float Dot(const Vector3& v1, const Vector3& v2);
/// <summary>
/// é•·ã•
/// </summary>
/// <param name="v">vector</param>
/// <returns>é•·ã•</returns>
float Length(const Vector3& v);
/// <summary>
/// æ­£è¦åŒ–
/// </summary>
/// <param name="v">vector</param>
/// <returns>æ­£è¦åŒ–ãƒ™ã‚¯ãƒˆãƒ«</returns>
Vector3 Normalize(const Vector3& v);
/// <summary>
/// å¤–ç©
/// </summary>
/// <param name="v1">vector1</param>
/// <param name="v2">vector2</param>
/// <returns>å¤–ç©ãƒ™ã‚¯ãƒˆãƒ«</returns>
Vector3 Cross(const Vector3& v1, const Vector3& v2);
/// <summary>
/// ãƒ™ã‚¯ãƒˆãƒ«å¤‰æ›
/// </summary>
/// <param name="v">vector</param>
/// <param name="m">matrix</param>
/// <returns>å¤‰æ›å¾Œãƒ™ã‚¯ãƒˆãƒ«</returns>
Vector3 TransformNormal(const Vector3& v, const Matrix4x4& m);

// -----è¡Œåˆ—-----
/// <summary>
/// è¡Œåˆ—ã®ä¹—ç®—
/// </summary>
/// <param name="m1">matrix1</param>
/// <param name="m2">matrix2</param>
/// <returns>ä¹—ç®—çµæžœè¡Œåˆ—</returns>
Matrix4x4 Multiply(const Matrix4x4& m1, const Matrix4x4& m2);

/// <summary>
/// å¹³è¡Œç§»å‹•è¡Œåˆ—
/// </summary>
/// <param name="translate">ç§»å‹•é‡</param>
/// <returns>å¹³è¡Œç§»å‹•è¡Œåˆ—</returns>
Matrix4x4 MakeTranslateMatrix(const Vector3& translate);
/// <summary>
/// æ‹¡å¤§ç¸®å°è¡Œåˆ—
/// </summary>
/// <param name="scale">æ‹¡å¤§çŽ‡</param>
/// <returns>æ‹¡å¤§ç¸®å°è¡Œåˆ—</returns>
Matrix4x4 MakeScaleMatrix(const Vector3& scale);

/// <summary>
/// Xå›žè»¢è¡Œåˆ—
/// </summary>
/// <param name="radian">ãƒ©ã‚¸ã‚¢ãƒ³</param>
/// <returns>Xå›žè»¢è¡Œåˆ—</returns>
Matrix4x4 MakeRotateXMatrix(float radian);
/// <summary>
/// Yå›žè»¢è¡Œåˆ—
/// </summary>
/// /// <param name="radian">ãƒ©ã‚¸ã‚¢ãƒ³</param>
/// <returns>Yå›žè»¢è¡Œåˆ—</returns>
Matrix4x4 MakeRotateYMatrix(float radian);
/// <summary>
/// Zå›žè»¢è¡Œåˆ—
/// </summary>
/// <param name="radian">ãƒ©ã‚¸ã‚¢ãƒ³</param>
/// <returns>Zå›žè»¢è¡Œåˆ—</returns>
Matrix4x4 MakeRotateZMatrix(float radian);
/// <summary>
/// ä»»æ„è»¸å›žè»¢è¡Œåˆ—
/// </summary>
/// <param name="axis">è»¸</param>
/// <param name="angle">è§’åº¦</param>
/// <returns>ä»»æ„è»¸å›žè»¢è¡Œåˆ—</returns>
Matrix4x4 MakeRotateAxisAngle(const Vector3& axis, float angle);
/// <summary>
/// ãƒ™ã‚¯ãƒˆãƒ«ã‹ã‚‰ãƒ™ã‚¯ãƒˆãƒ«ã¸ã®å¤‰æ›è¡Œåˆ—
/// </summary>
/// <param name="from">å§‹ã¾ã‚Šã®ãƒ™ã‚¯ã‚¿ãƒ¼</param>
/// <param name="to">çµ‚ã‚ã‚Šã®ãƒ™ã‚¯ã‚¿ãƒ¼</param>
/// <returns>å¤‰æ›è¡Œåˆ—</returns>
Matrix4x4 DirectionToDirection(const Vector3& from, const Vector3& to);
/// <summary>
/// ã‚¢ãƒ•ã‚£ãƒ³å¤‰æ›è¡Œåˆ—
/// </summary>
/// <param name="scale">ã‚¹ã‚±ãƒ¼ãƒ«</param>
/// <param name="rotate">å›žè»¢</param>
/// <param name="translate">ç§»å‹•</param>
/// <returns>ã‚¢ãƒ•ã‚£ãƒ³å¤‰æ›è¡Œåˆ—</returns>
Matrix4x4 MakeAffineMatrix(const Vector3& scale, const Vector3& rotate, const Vector3& translate);

/// <summary>
/// é€†è¡Œåˆ—
/// </summary>
/// <param name="m">matrix</param>
/// <returns>é€†è¡Œåˆ—</returns>
Matrix4x4 Inverse(const Matrix4x4& m);
/// <summary>
/// è»¢ç½®è¡Œåˆ—
/// </summary>
/// <param name="m">matrix</param>
/// <returns>è»¢ç½®è¡Œåˆ—</returns>
Matrix4x4 Transpose(const Matrix4x4& m);
/// <summary>
/// é€†è»¢ç½®è¡Œåˆ—
/// </summary>
/// <param name="m">matrix</param>
/// <returns>é€†è»¢ç½®è¡Œåˆ—</returns>
Matrix4x4 InverseTranspose(const Matrix4x4& m);
/// <summary>
/// å˜ä½è¡Œåˆ—ã®ä½œæˆ
/// </summary>
/// <returns>å˜ä½è¡Œåˆ—</returns>
Matrix4x4 MakeIdentity4x4();

/// <summary>
/// ãƒ™ã‚¯ãƒˆãƒ«ã¨è¡Œåˆ—ã®ä¹—ç®—
/// </summary>
/// <param name="vec">vector</param>
/// <param name="mat">matrix</param>
/// <returns></returns>
Vector3 Multiply(const Vector3& vec, const Matrix4x4& mat);

// -----åº§æ¨™ç³»-----
/// <summary>
/// é€è¦–æŠ•å½±è¡Œåˆ—
/// </summary>
/// <param name="fovY">ãƒ•ã‚©ãƒ–è§’åº¦</param>
/// <param name="aspectRatio">ã‚¢ã‚¹ãƒšã‚¯ãƒˆæ¯”</param>
/// <param name="nearClip">ãƒ‹ã‚¢ã‚¯ãƒªãƒƒãƒ—</param>
/// <param name="farClip">ãƒ•ã‚¡ãƒ¼ã‚¯ãƒªãƒƒãƒ—</param>
/// <returns>é€è¦–æŠ•å½±è¡Œåˆ—</returns>
Matrix4x4 MakePerspectiveFovMatrix(float fovY, float aspectRatio, float nearClip, float farClip);
/// <summary>
/// æ­£å°„å½±è¡Œåˆ—
/// </summary>
/// <param name="left">å·¦</param>
/// <param name="top">ä¸Š</param>
/// <param name="right">å³</param>
/// <param name="bottom">ä¸‹</param>
/// <param name="nearClip">ãƒ‹ã‚¢ã‚¯ãƒªãƒƒãƒ—</param>
/// <param name="farClip">ãƒ•ã‚¡ãƒ¼ã‚¯ãƒªãƒƒãƒ—</param>
/// <returns>æ­£å°„å½±è¡Œåˆ—</returns>
Matrix4x4 MakeOrthographicMatrix(float left, float top, float right, float bottom, float nearClip, float farClip);
/// <summary>
/// ãƒ“ãƒ¥ãƒ¼ãƒãƒ¼ãƒˆå¤‰æ›è¡Œåˆ—
/// </summary>
/// <param name="left">å·¦</param>
/// <param name="top">ä¸Š</param>
/// <param name="width">å¹…</param>
/// <param name="height">é«˜ã•</param>
/// <param name="minDepth">æœ€å°æ·±åº¦</param>
/// <param name="maxDepth">æœ€å¤§æ·±åº¦</param>
/// <returns>ãƒ“ãƒ¥ãƒ¼ãƒãƒ¼ãƒˆå¤‰æ›è¡Œåˆ—</returns>
Matrix4x4 MakeViewportMatrix(float left, float top, float width, float height, float minDepth, float maxDepth);
/// <summary>
/// ãƒ™ã‚¯ãƒˆãƒ«ã®å¤‰æ›
/// </summary>
/// <param name="vector">ãƒ™ã‚¯ãƒˆãƒ«</param>
/// <param name="matrix">è¡Œåˆ—</param>
/// <returns>å¤‰æ›å¾Œãƒ™ã‚¯ãƒˆãƒ«</returns>
Vector3 Transform(const Vector3& vector, const Matrix4x4& matrix);

// -----è£œé–“-----
/// <summary>
/// ç·šå½¢è£œé–“
/// </summary>
/// <param name="v1">å§‹ã¾ã‚Šã®å€¤</param>
/// <param name="v2">çµ‚ã‚ã‚Šã®å€¤</param>
/// <param name="t">è£œé–“ä¿‚æ•°(0.0~1.0)</param>
/// <returns>è£œé–“å¾Œã®å€¤</returns>
float Lerp(const float& v1, const float& v2, float t);
/// <summary>
/// ãƒ™ã‚¯ãƒˆãƒ«ã®ç·šå½¢è£œé–“
/// </summary>
/// <param name="v1">å§‹ã¾ã‚Šã®ãƒ™ã‚¯ãƒˆãƒ«</param>
/// <param name="v2">çµ‚ã‚ã‚Šã®ãƒ™ã‚¯ãƒˆãƒ«</param>
/// <param name="t">è£œé–“ä¿‚æ•°(0.0~1.0)</param>
/// <returns>è£œé–“å¾Œã®ãƒ™ã‚¯ãƒˆãƒ«</returns>
Vector3 Lerp(const Vector3& v1, const Vector3& v2, float t);
/// <summary>
/// çƒé¢ç·šå½¢è£œé–“
/// </summary>
/// <param name="v1">å§‹ã¾ã‚Šã®ãƒ™ã‚¯ãƒˆãƒ«</param>
/// <param name="v2">çµ‚ã‚ã‚Šã®ãƒ™ã‚¯ãƒˆãƒ«</param>
/// <param name="t">è£œé–“ä¿‚æ•°(0.0~1.0)</param>
/// <returns>è£œé–“å¾Œã®ãƒ™ã‚¯ãƒˆãƒ«</returns>
Vector3 Slerp(const Vector3& v1, const Vector3& v2, float t);
/// <summary>
/// è§’åº¦ã®ç·šå½¢è£œé–“
/// </summary>
/// <param name="a">å§‹ã¾ã‚Šã®è§’åº¦</param>
/// <param name="b">çµ‚ã‚ã‚Šã®è§’åº¦</param>
/// <param name="t">è£œé–“ä¿‚æ•°(0.0~1.0)</param>
/// <returns>è£œé–“å¾Œã®è§’åº¦</returns>
float LerpAngle(float a, float b, float t);

/// <summary>
/// 3æ¬¡ãƒ™ã‚¸ã‚§æ›²ç·š
/// </summary>
/// <param name="p0">å§‹ç‚¹</param>
/// <param name="p1">åˆ¶å¾¡ç‚¹1</param>
/// <param name="p2">åˆ¶å¾¡ç‚¹2</param>
/// <param name="p3">çµ‚ç‚¹</param>
/// <param name="t">è£œé–“ä¿‚æ•°(0.0~1.0)</param>
/// <returns>è£œé–“å¾Œã®ãƒ™ã‚¯ãƒˆãƒ«</returns>
Vector3 Bezier3(const Vector3& p0, const Vector3& p1, const Vector3& p2, const Vector3& p3, float t);

namespace MyMath 
{
	inline float cot(float a) { return cos(a) / sin(a); }
}

============================================================
File Path: project/gameEngine/math/Quaternion.cpp
============================================================
#include "Quaternion.h"

Quaternion Multiply(const Quaternion& lhs, const Quaternion& rhs)
{
	Quaternion result;
	result.w = lhs.w * rhs.w - lhs.x * rhs.x - lhs.y * rhs.y - lhs.z * rhs.z;
	result.x = lhs.w * rhs.x + lhs.x * rhs.w + lhs.y * rhs.z - lhs.z * rhs.y;
	result.y = lhs.w * rhs.y - lhs.x * rhs.z + lhs.y * rhs.w + lhs.z * rhs.x;
	result.z = lhs.w * rhs.z + lhs.x * rhs.y - lhs.y * rhs.x + lhs.z * rhs.w;
	return result;
}

Quaternion IdentityQuaternion()
{
	return Quaternion{ 0.0f, 0.0f, 0.0f, 1.0f };
}

Quaternion Conjugate(const Quaternion& quaternion)
{
	return Quaternion{ -quaternion.x, -quaternion.y, -quaternion.z, quaternion.w };
}

float Norm(const Quaternion& quaternion)
{
	return std::sqrt(quaternion.x * quaternion.x + quaternion.y * quaternion.y + quaternion.z * quaternion.z + quaternion.w * quaternion.w);
}

Quaternion Normalize(const Quaternion& quaternion)
{
	float norm = Norm(quaternion);
	return Quaternion{ quaternion.x / norm, quaternion.y / norm, quaternion.z / norm, quaternion.w / norm };
}

Quaternion Inverse(const Quaternion& quaternion)
{
	float norm = Norm(quaternion);
	Quaternion conjugate = Conjugate(quaternion);
	return Quaternion{ conjugate.x / (norm * norm), conjugate.y / (norm * norm), conjugate.z / (norm * norm), conjugate.w / (norm * norm) };
}


============================================================
File Path: project/gameEngine/math/Quaternion.h
============================================================
#pragma once

#include "MyMath.h"

/// <summary>
/// å››å…ƒæ•°
/// </summary>
struct Quaternion
{
	float x;
	float y;
	float z;
	float w;
};

/// <summary>
/// Quaternionã®ç©
/// </summary>
/// <param name="lhs">å·¦è¾ºQuaternion</param>
/// <param name="rhs">å³è¾ºQuaternion</param>
/// <returns>ç©Quaternion</returns>
Quaternion Multiply(const Quaternion& lhs, const Quaternion& rhs);

/// <summary>
/// å˜ä½Quaternionã®ä½œæˆã‚’è¿”ã™
/// </summary>
/// <returns>å˜ä½Quaternion</returns>
Quaternion IdentityQuaternion();

/// <summary>
/// å…±å½¹Quaternionã‚’è¿”ã™
/// </summary>
/// <param name="quaternion">å¯¾è±¡Quaternion</param>
/// <returns>å…±å½¹Quaternion</returns>
Quaternion Conjugate(const Quaternion& quaternion);

/// <summary>
/// Quaternionã®normã‚’è¿”ã™
/// </summary>
/// <param name="quaternion">å¯¾è±¡Quaternion</param>
/// <returns>normå€¤</returns>
float Norm(const Quaternion& quaternion);

/// <summary>
/// æ­£è¦åŒ–ã—ãŸQuaternionã‚’è¿”ã™
/// </summary>
/// <param name="quaternion">å¯¾è±¡Quaternion</param>
/// <returns>æ­£è¦åŒ–Quaternion</returns>
Quaternion Normalize(const Quaternion& quaternion);

/// <summary>
///é€†Quaternionã‚’è¿”ã™
/// </summary>
/// <param name="quaternion">å¯¾è±¡Quaternion</param>
/// <returns>é€†Quaternion</returns>
Quaternion Inverse(const Quaternion& quaternion);

============================================================
File Path: project/gameEngine/math/Vector2.cpp
============================================================
#include "Vector2.h"
#include <cmath>

/// ===========
/// calcuration
/// ===========

float Vector2::Dot(const Vector2& _v) const
{
    return x * _v.x + y * _v.y;
}

float Vector2::Cross(const Vector2& _v) const
{
    return x * _v.y - y * _v.x;
}

float Vector2::Length() const
{
    return std::sqrtf(x * x + y * y);
}

float Vector2::LengthWithoutRoot() const
{
    return x * x + y * y;
}

Vector2 Vector2::Perpendicular() const
{
    return Vector2(-y, x);
}

Vector2 Vector2::Normalize() const
{
    float length = this->Length();
    if (length == 0) return {};
    return Vector2(
        x / length,
        y / length
    );
}

float Vector2::Projection(const Vector2& _a) const
{
    Vector2 axis = _a.Normalize();
    return (*this).Dot(axis);
}

void Vector2::Lerp(const Vector2& _begin, const Vector2& _end, float _t)
{
    x = (1.0f - _t) * _begin.x + _t * _end.x;
    y = (1.0f - _t) * _begin.y + _t * _end.y;
    return;
}

float Vector2::Distance(const Vector2& _destination) const
{
    return Vector2(_destination - *this).Length();
}

float Vector2::Theta(const Vector2& _origin) const
{
    Vector2 distance = *this - _origin;
    return std::atan2(distance.y, distance.x);
}

Vector2 Vector2::Rotated(float _theta) const
{
    Vector2 result = {};
    result.x = x * std::cosf(_theta) - y * std::sinf(_theta);
    result.y = x * std::sinf(_theta) + y * std::cosf(_theta);
    return result;
}

Vector2 Vector2::operator-() const
{
    return Vector2(-x, -y);
}

/// =====
/// float
/// =====

Vector2 Vector2::operator*(float _f) const
{
    Vector2 result{};
    result.x = x * _f;
    result.y = y * _f;
    return result;
}

Vector2 Vector2::operator/(float _f) const
{
    Vector2 result{};
    result.x = x / _f;
    result.y = y / _f;
    return result;
}

Vector2& Vector2::operator*=(float _f)
{
    x *= _f;
    y *= _f;
    return *this;
}

Vector2& Vector2::operator/=(float _f)
{
    x /= _f;
    y /= _f;
    return *this;
}

/// =======
/// Vector2
/// =======

Vector2 Vector2::operator+(const Vector2& _v) const
{
    Vector2 result{};
    result.x = x + _v.x;
    result.y = y + _v.y;
    return result;
}

Vector2 Vector2::operator-(const Vector2& _v) const
{
    Vector2 result{};
    result.x = x - _v.x;
    result.y = y - _v.y;
    return result;
}

Vector2 Vector2::operator*(const Vector2& _v) const
{
    Vector2 result{};
    result.x = x * _v.x;
    result.y = y * _v.y;
    return result;
}

Vector2& Vector2::operator+=(const Vector2& _v)
{
    x += _v.x;
    y += _v.y;
    return *this;
}

Vector2& Vector2::operator-=(const Vector2& _v)
{
    x -= _v.x;
    y -= _v.y;
    return *this;
}

Vector2& Vector2::operator*=(const Vector2& _v)
{
    x *= _v.x;
    y *= _v.y;
    return *this;
}

/// =========
/// overscope
/// =========

Vector2 operator*(const float _f, const Vector2& _v)
{
    return Vector2(_v.x * _f, _v.y * _f);
}

Vector2 operator/(const float _f, const Vector2& _v)
{
    return Vector2(_v.x / _f, _v.y / _f);
}


============================================================
File Path: project/gameEngine/math/Vector2.h
============================================================
#pragma once

/// <summary>
/// 2th Dimension Vector
/// </summary>
class Vector2 final {
public:
    float x;
    float y;

    inline Vector2() : x(), y() {};

    inline Vector2(const unsigned int _x, const unsigned int& _y)
    {
        x = static_cast<float>(_x);
        y = static_cast<float>(_y);
        return;
    }

    inline Vector2(const int& _x, const int& _y)
    {
        x = static_cast<float>(_x);
        y = static_cast<float>(_y);
        return;
    }

    inline Vector2(const float& _x, const float& _y)
    {
        x = _x;
        y = _y;
        return;
    }

    inline Vector2(const float& _x)
    {
        x = _x;
        y = 0.0f;
        return;
    }

    /// ===========
    /// calcuration
    /// ===========

    /// <summary>
    /// å†…ç©
    /// </summary>
    /// <param name="_v">ãƒ™ã‚¯ãƒˆãƒ«</param>
    /// <returns>å†…ç©</returns>
    float Dot(const Vector2& _v) const;

    /// <summary>
    /// å¤–ç©
    /// </summary>
    /// <param name="_v">ãƒ™ã‚¯ãƒˆãƒ«</param>
    /// <returns>å¤–ç©</returns>
    float Cross(const Vector2& _v) const;

    /// <summary>
    /// åŽŸç‚¹ã‹ã‚‰ã®è·é›¢ã‚’æ±‚ã‚ã‚‹
    /// </summary>
    /// <returns>è·é›¢</returns>
    float Length() const;

    /// <summary>
    /// Lengthé–¢æ•°ã®å¹³æ–¹æ ¹ãªã—
    /// </summary>
	/// <returns>è·é›¢ã®äºŒä¹—</returns>
    float LengthWithoutRoot() const;

    /// <summary>
    /// åž‚ç›´ãƒ™ã‚¯ãƒˆãƒ«ã‚’è¿”ã™
    /// </summary>
	/// <returns>åž‚ç›´ãƒ™ã‚¯ãƒˆãƒ«</returns>
    Vector2 Perpendicular() const;

    /// <summary>
    /// æ­£è¦åŒ–æ¸ˆã¿ã®å€¤ã‚’è¿”ã™
    /// </summary>
	/// <returns>æ­£è¦åŒ–ãƒ™ã‚¯ãƒˆãƒ«</returns>
    Vector2 Normalize() const;

    /// <summary>
    /// thisã‹ã‚‰å¼•æ•°ã®ãƒ™ã‚¯ãƒˆãƒ«ã¾ã§ã®è·é›¢
    /// </summary>
    /// <param name="_destination">è¡Œãå…ˆ</param>
    /// <returns>è·é›¢</returns>
    float Distance(const Vector2& _destination) const;
    
	/// <summary>
	/// åŽŸç‚¹ã‹ã‚‰ã®è§’åº¦ã‚’æ±‚ã‚ã‚‹
	/// </summary>
	/// <param name="_origin">åŽŸç‚¹</param>
	/// <returns>è§’åº¦(ãƒ©ã‚¸ã‚¢ãƒ³)</returns>
    float Theta(const Vector2& _origin = { 0.0f, 0.0f }) const;
    
	/// <summary>
	/// æŒ‡å®šã—ãŸè§’åº¦åˆ†å›žè»¢ã•ã›ãŸãƒ™ã‚¯ãƒˆãƒ«ã‚’è¿”ã™
	/// </summary>
	/// <param name="_theta">å›žè»¢è§’(ãƒ©ã‚¸ã‚¢ãƒ³)</param>
	/// <returns>å›žè»¢å¾Œã®ãƒ™ã‚¯ãƒˆãƒ«</returns>
    Vector2 Rotated(float _theta) const;

    /// <summary>
    /// è»¸aã«æŠ•å½±ã—ãŸå€¤ã‚’è¿”ã™
    /// </summary>
    /// <param name="_a">è»¸</param>
	/// <returns>æŠ•å½±å€¤</returns>
    float Projection(const Vector2& _a) const;

    /// <summary>
    /// ç·šå½¢è£œé–“
    /// </summary>
    /// <param name="_begin">åˆæœŸå€¤</param>
    /// <param name="_end">çµ‚äº†å€¤</param>
    /// <param name="_t">0.0~1.0</param>
    void Lerp(const Vector2& _begin, const Vector2& _end, float _t);

    /// ==========
    /// Minus sign
    /// ==========

    Vector2 operator-() const;

    /// =====
    /// float
    /// =====

    Vector2 operator+(float) = delete;
    Vector2 operator-(float) = delete;
    Vector2 operator*(float _f) const;
    Vector2 operator/(float _f) const;
    Vector2& operator+=(float _f) = delete;
    Vector2& operator-=(float _f) = delete;
    Vector2& operator*=(float _f);
    Vector2& operator/=(float _f);

    /// =======
    /// Vector2
    /// =======

    Vector2 operator+(const Vector2& _v) const;
    Vector2 operator-(const Vector2& _v) const;
    Vector2 operator*(const Vector2& _v) const;

    Vector2& operator+=(const Vector2& _v);
    Vector2& operator-=(const Vector2& _v);
    Vector2& operator*=(const Vector2& _v);
};

Vector2 operator*(const float _f, const Vector2& _v);
Vector2 operator/(const float _f, const Vector2& _v);

============================================================
File Path: project/gameEngine/math/Vector3.cpp
============================================================
#include "Vector3.h"
#include "Matrix4x4.h"

#include <cassert>
#include <cmath>

/// ===========
/// calcuration
/// ===========

float Vector3::Dot(const Vector3& _v) const
{
    return float(
        x * _v.x +
        y * _v.y +
        z * _v.z
        );
}

Vector3 Vector3::Cross(const Vector3& _v) const
{
    return Vector3(
        y * _v.z - z * _v.y,
        z * _v.x - x * _v.z,
        x * _v.y - y * _v.x
    );
}

float Vector3::Length() const
{
    return std::sqrtf(x * x + y * y + z * z);
}

float Vector3::LengthWithoutRoot() const
{
    return x * x + y * y + z * z;
}

Vector3 Vector3::Normalize() const
{
    float length = this->Length();
    return Vector3(
        x / length,
        y / length,
        z / length
    );
}

void Vector3::Lerp(const Vector3& _begin, const Vector3& _end, float _t)
{
    x = (1.0f - _t) * _begin.x + _t * _end.x;
    y = (1.0f - _t) * _begin.y + _t * _end.y;
    z = (1.0f - _t) * _begin.z + _t * _end.z;
    return;
}

void Vector3::Theta(float& _azimuth, float& _elevation, const Vector3& _origin) const
{
    Vector3 distance = *this - _origin;
    _azimuth = std::atan2(distance.y, distance.x);
    _elevation = std::atan2(distance.z, sqrtf(distance.x * distance.x + distance.y * distance.y));
    return;
}

float Vector3::Projection(const Vector3& _a) const
{
    Vector3 axis = _a.Normalize();
    return (*this).Dot(axis);
}

float Vector3::Distance(const Vector3& _destination) const
{
    Vector3 distance = _destination - *this;
    return distance.Length();
}

/// ==========
/// minus sign
/// ==========

Vector3 Vector3::operator-() const
{
    return Vector3(-x, -y, -z);
}

/// =======
/// Vector3
/// =======

Vector3& Vector3::operator+=(const Vector3& _rv)
{
    x += _rv.x;
    y += _rv.y;
    z += _rv.z;
    return *this;
}

Vector3& Vector3::operator-=(const Vector3& _rv)
{
    x -= _rv.x;
    y -= _rv.y;
    z -= _rv.z;
    return *this;
}

Vector3& Vector3::operator*=(const Vector3& _rv)
{
    x *= _rv.x;
    y *= _rv.y;
    z *= _rv.z;
    return *this;
}

Vector3 Vector3::operator-(const Vector3& _v) const
{
    Vector3 result{};
    result.x = x - _v.x;
    result.y = y - _v.y;
    result.z = z - _v.z;
    return result;
}

Vector3 Vector3::operator*(const Vector3& _v) const
{
    Vector3 result{};
    result.x = x * _v.x;
    result.y = y * _v.y;
    result.z = z * _v.z;
    return result;
}

Vector3 Vector3::operator+(const Vector3& _v) const
{
    Vector3 result{};
    result.x = x + _v.x;
    result.y = y + _v.y;
    result.z = z + _v.z;
    return result;
}

/// =====
/// float
/// =====

Vector3 Vector3::operator*(float _f) const
{
    Vector3 result{};
    result.x = x * _f;
    result.y = y * _f;
    result.z = z * _f;
    return result;
}

Vector3 Vector3::operator/(float _f) const
{
    Vector3 result{};
    result.x = x / _f;
    result.y = y / _f;
    result.z = z / _f;
    return result;
}

Vector3& Vector3::operator*=(float _f)
{
    x *= _f;
    y *= _f;
    z *= _f;
    return *this;
}

Vector3& Vector3::operator/=(float _f)
{
    x /= _f;
    y /= _f;
    z /= _f;
    return *this;
}

/// =======
/// Vector2
/// =======

Vector3& Vector3::operator+=(const Vector2& _rv)
{
    x += _rv.x;
    y += _rv.y;
    return *this;
}

Vector3& Vector3::operator-=(const Vector2& _rv)
{
    x -= _rv.x;
    y -= _rv.y;
    return *this;
}

Vector3& Vector3::operator*=(const Vector2& _rv)
{
    x *= _rv.x;
    y *= _rv.y;
    return *this;
}

Vector3 Vector3::operator+(const Vector2& _v) const
{
    Vector3 result{};
    result.x = x + _v.x;
    result.y = y + _v.y;
    result.z = z;
    return result;
}

Vector3 Vector3::operator-(const Vector2& _v) const
{
    Vector3 result{};
    result.x = x - _v.x;
    result.y = y - _v.y;
    result.z = z;
    return result;
}

Vector3 Vector3::operator*(const Vector2& _v) const
{
    Vector3 result{};
    result.x = x * _v.x;
    result.y = y * _v.y;
    result.z = z;
    return result;
}

Vector3 operator*(const float _f, const Vector3& _v)
{
    return Vector3(_v.x * _f, _v.y * _f, _v.z * _f);
}

Vector3 operator/(const float _f, const Vector3& _v)
{
    return Vector3(_v.x / _f, _v.y / _f, _v.z / _f);
}

============================================================
File Path: project/gameEngine/math/Vector3.h
============================================================
#pragma once

#include "Vector2.h"

class Matrix4x4;

/// <summary>
/// 3th Dimension Vector
/// 3æ¬¡å…ƒãƒ™ã‚¯ãƒˆãƒ«
/// </summary>
class Vector3 final {
public:
    float x;
    float y;
    float z;

    inline Vector3() : x(), y(), z() {};

    inline Vector3(const float& _x, const float& _y, const float& _z)
    {
        x = _x;
        y = _y;
        z = _z;
        return;
    }

    inline Vector3(const float& _x, const float& _y)
    {
        x = _x;
        y = _y;
        z = 0.0f;
        return;
    }

    inline Vector3(const float& _x)
    {
        x = _x;
        y = 0.0f;
        z = 0.0f;
        return;
    }

    inline Vector3(const Vector2& _vec2, float _f)
    {
        x = _vec2.x;
        y = _vec2.y;
        z = _f;
        return;
    }

    inline Vector3(const Vector2& _vec2)
    {
        x = _vec2.x;
        y = _vec2.y;
        z = 0.0f;
        return;
    }

    inline Vector2 xy() { return Vector2(x, y); }

    /// ===========
    /// calcuration
    /// ===========

	/// <summary>
	/// å†…ç©
	/// </summary>
	/// <param name="_v">ãƒ™ã‚¯ãƒˆãƒ«</param>
	/// <returns>å†…ç©</returns>
    float Dot(const Vector3& _v) const;
    
	/// <summary>
	/// å¤–ç©
	/// </summary>
	/// <param name="_v">ãƒ™ã‚¯ãƒˆãƒ«</param>
	/// <returns>å¤–ç©</returns>
    Vector3 Cross(const Vector3& _v) const;
    
	/// <summary>
	/// åŽŸç‚¹ã‹ã‚‰ã®è·é›¢ã‚’æ±‚ã‚ã‚‹
	/// </summary>
	/// <returns>è·é›¢</returns>
    float Length() const;
    
	/// <summary>
	/// Lengthé–¢æ•°ã®å¹³æ–¹æ ¹ãªã—
	/// </summary>
	/// <returns>è·é›¢ã®äºŒä¹—</returns>
    float LengthWithoutRoot() const;
    
	/// <summary>
	/// æ­£è¦åŒ–æ¸ˆã¿ã®å€¤ã‚’è¿”ã™
	/// </summary>
	/// <returns>æ­£è¦åŒ–ãƒ™ã‚¯ãƒˆãƒ«</returns>
    Vector3 Normalize() const;
    
	/// <summary>
	/// thisã‹ã‚‰å¼•æ•°ã®ãƒ™ã‚¯ãƒˆãƒ«ã¾ã§ã®è·é›¢
	/// </summary>
	/// <param name="_destination">è¡Œãå…ˆ</param>
	/// <returns>è·é›¢</returns>
    float Distance(const Vector3& _destination) const;
    
	/// <summary>
	/// è»¸aã«æŠ•å½±ã—ãŸå€¤ã‚’è¿”ã™
	/// </summary>
	/// <param name="_a">è»¸</param>
	/// <returns>æŠ•å½±å€¤</returns>
    float Projection(const Vector3& _a) const;
    
	/// <summary>
	/// ç·šå½¢è£œé–“
	/// </summary>
	/// <param name="_begin">åˆæœŸå€¤</param>
	/// <param name="_end">çµ‚äº†å€¤</param>
	/// <param name="_t">0.0~1.0</param>
    void Lerp(const Vector3& _begin, const Vector3& _end, float _t);
    
	/// <summary>
	/// åŽŸç‚¹ã‹ã‚‰ã®è§’åº¦ã‚’æ±‚ã‚ã‚‹
	/// </summary>
	/// <param name="_azimuth">æ–¹ä½è§’(ãƒ©ã‚¸ã‚¢ãƒ³)</param>
	/// <param name="_elevation">ä»°è§’(ãƒ©ã‚¸ã‚¢ãƒ³)</param>
	/// <param name="_origin">åŽŸç‚¹</param>
	/// <returns>è§’åº¦(ãƒ©ã‚¸ã‚¢ãƒ³)</returns>
    void Theta(float& _azimuth, float& _elevation, const Vector3& _origin = { 0.0f, 0.0f }) const;

    /// ==========
    /// minus sign
    /// ==========

    Vector3 operator-() const;

    /// =======
    /// Vector3
    /// =======

    Vector3& operator+=(const Vector3& _rv);
    Vector3& operator-=(const Vector3& _rv);
    Vector3& operator*=(const Vector3& _rv);

    Vector3 operator+(const Vector3& _v) const;
    Vector3 operator-(const Vector3& _v) const;
    Vector3 operator*(const Vector3& _v) const;

    /// =====
    /// float
    /// =====

    Vector3 operator+(float) = delete;
    Vector3 operator-(float) = delete;
    Vector3 operator*(float _f) const;
    Vector3 operator/(float _f) const;
    Vector3& operator+=(float) = delete;
    Vector3& operator-=(float) = delete;
    Vector3& operator*=(float _f);
    Vector3& operator/=(float _f);

    /// =======
    /// Vector2
    /// =======

    Vector3& operator+=(const Vector2& _rv);
    Vector3& operator-=(const Vector2& _rv);
    Vector3& operator*=(const Vector2& _rv);

    Vector3 operator+(const Vector2& _v) const;
    Vector3 operator-(const Vector2& _v) const;
    Vector3 operator*(const Vector2& _v) const;
};

Vector3 operator*(const float _f, const Vector3& _v);
Vector3 operator/(const float _f, const Vector3& _v);

namespace FMath
{
    /// <summary>
	/// ãƒ™ã‚¯ãƒˆãƒ«ã®åŠ ç®—
	/// </summary>
	/// <param name="_v1">ãƒ™ã‚¯ãƒˆãƒ«1</param>
	/// <param name="_v2">ãƒ™ã‚¯ãƒˆãƒ«2</param>
	/// <returns>åŠ ç®—çµæžœãƒ™ã‚¯ãƒˆãƒ«</returns>
    Vector3 Add(const Vector3& _v1, const Vector3& _v2);
	/// <summary>
	/// ãƒ™ã‚¯ãƒˆãƒ«ã®æ¸›ç®—
	/// </summary>
	/// <param name="_v1">ãƒ™ã‚¯ãƒˆãƒ«1</param>
	/// <param name="_v2">ãƒ™ã‚¯ãƒˆãƒ«2</param>
	/// <returns>æ¸›ç®—çµæžœãƒ™ã‚¯ãƒˆãƒ«</returns>
    Vector3 Subtract(const Vector3& _v1, const Vector3& _v2);
	/// <summary>
	/// ãƒ™ã‚¯ãƒˆãƒ«ã®ã‚¹ã‚«ãƒ©ãƒ¼å€
	/// </summary>
	/// <param name="_scalar">ã‚¹ã‚«ãƒ©ãƒ¼å€¤</param>
	/// <param name="_v">ãƒ™ã‚¯ãƒˆãƒ«</param>
	/// <returns>ã‚¹ã‚«ãƒ©ãƒ¼å€çµæžœãƒ™ã‚¯ãƒˆãƒ«</returns>
    Vector3 Multiply(float _scalar, const Vector3& _v);
	/// <summary>
	/// ãƒ™ã‚¯ãƒˆãƒ«ã®å†…ç©
	/// </summary>
	/// <param name="_v1">ãƒ™ã‚¯ãƒˆãƒ«1</param>
	/// <param name="_v2">ãƒ™ã‚¯ãƒˆãƒ«2</param>
	/// <returns>å†…ç©</returns>
    float Dot(const Vector3& _v1, const Vector3& _v2);
	/// <summary>
	/// ãƒ™ã‚¯ãƒˆãƒ«ã®å¤–ç©
	/// </summary>
	/// <param name="_v1">ãƒ™ã‚¯ãƒˆãƒ«1</param>
	/// <param name="_v2">ãƒ™ã‚¯ãƒˆãƒ«2</param>
	/// <returns>å¤–ç©ãƒ™ã‚¯ãƒˆãƒ«</returns>
    float Length(const Vector3& _v);
	/// <summary>
	/// ãƒ™ã‚¯ãƒˆãƒ«ã®æ­£è¦åŒ–
	/// </summary>
	/// <param name="_v">ãƒ™ã‚¯ãƒˆãƒ«</param>
	/// <returns>æ­£è¦åŒ–ãƒ™ã‚¯ãƒˆãƒ«</returns>
    Vector3 Normalize(const Vector3& _v);
	/// <summary>
	/// ãƒ™ã‚¯ãƒˆãƒ«ã®å¤‰æ›
	/// </summary>
	/// <param name="_vector">ãƒ™ã‚¯ãƒˆãƒ«</param>
	/// <param name="_matrix">å¤‰æ›è¡Œåˆ—</param>
	/// <returns>å¤‰æ›å¾Œãƒ™ã‚¯ãƒˆãƒ«</returns>
    Vector3 Transform(const Vector3& _vector, const Matrix4x4& _matrix);
}

============================================================
File Path: project/gameEngine/particle/MeshBuilder.cpp
============================================================
#include "MeshBuilder.h"

#include <numbers>

void MeshBuilder::BuildRing(Model* model)
{
    model->ClearVertexData();

    const uint32_t kRingDivide = 32;
    const float kOuterRadius = 1.0f;
    const float kInnerRadius = 0.2f;
    const float radianPerDivide = 2.0f * std::numbers::pi_v<float> / float(kRingDivide);

    for (uint32_t index = 0; index < kRingDivide; ++index)
    {
        float sin = std::sin(index * radianPerDivide);
        float cos = std::cos(index * radianPerDivide);
        float sinNext = std::sin((index + 1) * radianPerDivide);
        float cosNext = std::cos((index + 1) * radianPerDivide);
        float u = float(index) / float(kRingDivide);
        float uNext = float(index + 1) / float(kRingDivide);

        uint32_t baseIndex = model->GetVertexCount();

        model->AddVertex({ -sin * kOuterRadius, cos * kOuterRadius, 0.0f, 1.0f }, { u, 0.0f }, { 0.0f, 0.0f, 1.0f });
        model->AddVertex({ -sin * kInnerRadius, cos * kInnerRadius, 0.0f, 1.0f }, { u, 1.0f }, { 0.0f, 0.0f, 1.0f });
        model->AddVertex({ -sinNext * kOuterRadius, cosNext * kOuterRadius, 0.0f, 1.0f }, { uNext, 0.0f }, { 0.0f, 0.0f, 1.0f });

        model->AddIndex(baseIndex + 0);
        model->AddIndex(baseIndex + 1);
        model->AddIndex(baseIndex + 2);

        model->AddVertex({ -sinNext * kOuterRadius, cosNext * kOuterRadius, 0.0f, 1.0f }, { uNext, 0.0f }, { 0.0f, 0.0f, 1.0f });
        model->AddVertex({ -sin * kInnerRadius, cos * kInnerRadius, 0.0f, 1.0f }, { u, 1.0f }, { 0.0f, 0.0f, 1.0f });
        model->AddVertex({ -sinNext * kInnerRadius, cosNext * kInnerRadius, 0.0f, 1.0f }, { uNext, 1.0f }, { 0.0f, 0.0f, 1.0f });

        model->AddIndex(baseIndex + 3);
        model->AddIndex(baseIndex + 4);
        model->AddIndex(baseIndex + 5);
    }

    model->UpdateVertexBuffer();
    model->UpdateIndexBuffer();
}

void MeshBuilder::BuildCylinder(Model* model)
{
    model->ClearVertexData();

    const uint32_t kDivide = 32;
    const float kRadius = 1.0f;
    const float kHeight = 3.0f;
    const float radianPerDivide = 2.0f * std::numbers::pi_v<float> / float(kDivide);

    for (uint32_t i = 0; i < kDivide; ++i)
    {
        float sin = std::sin(i * radianPerDivide);
        float cos = std::cos(i * radianPerDivide);
        float sinNext = std::sin((i + 1) * radianPerDivide);
        float cosNext = std::cos((i + 1) * radianPerDivide);
        float u = float(i) / float(kDivide);
        float uNext = float(i + 1) / float(kDivide);

        Vector3 top1 = { -sin * kRadius, kHeight, cos * kRadius };
        Vector3 top2 = { -sinNext * kRadius, kHeight, cosNext * kRadius };
        Vector3 bottom1 = { -sin * kRadius, 0.0f, cos * kRadius };
        Vector3 bottom2 = { -sinNext * kRadius, 0.0f, cosNext * kRadius };

        uint32_t baseIndex = model->GetVertexCount();

        model->AddVertex({ top1.x, top1.y, top1.z, 1.0f }, { u, 0.0f }, { -sin, 0.0f, cos });
        model->AddVertex({ top2.x, top2.y, top2.z, 1.0f }, { uNext, 0.0f }, { -sinNext, 0.0f, cosNext });
        model->AddVertex({ bottom1.x, bottom1.y, bottom1.z, 1.0f }, { u, 1.0f }, { -sin, 0.0f, cos });

        model->AddVertex({ bottom1.x, bottom1.y, bottom1.z, 1.0f }, { u, 1.0f }, { -sin, 0.0f, cos });
        model->AddVertex({ top2.x, top2.y, top2.z, 1.0f }, { uNext, 0.0f }, { -sinNext, 0.0f, cosNext });
        model->AddVertex({ bottom2.x, bottom2.y, bottom2.z, 1.0f }, { uNext, 1.0f }, { -sinNext, 0.0f, cosNext });

        model->AddIndex(baseIndex + 0);
        model->AddIndex(baseIndex + 1);
        model->AddIndex(baseIndex + 2);
        model->AddIndex(baseIndex + 3);
        model->AddIndex(baseIndex + 4);
        model->AddIndex(baseIndex + 5);
    }

    model->UpdateVertexBuffer();
    model->UpdateIndexBuffer();
}

void MeshBuilder::BuildCone(Model* model)
{
    model->ClearVertexData();

    const uint32_t kDivide = 32;
    const float kRadius = 1.0f;
    const float kHeight = 3.0f;
    const float radianPerDivide = 2.0f * std::numbers::pi_v<float> / float(kDivide);

    Vector3 apex = { 0.0f, +kHeight * 0.5f, 0.0f };     // é ‚ç‚¹ï¼šä¸Šã«1.5
    uint32_t apexIndex = model->GetVertexCount();
    model->AddVertex({ apex.x, apex.y, apex.z, 1.0f }, { 0.5f, 0.0f }, { 0, 1, 0 });

    for (uint32_t i = 0; i < kDivide; ++i)
    {
        float sin = std::sin(i * radianPerDivide);
        float cos = std::cos(i * radianPerDivide);
        float sinNext = std::sin((i + 1) * radianPerDivide);
        float cosNext = std::cos((i + 1) * radianPerDivide);

        
        Vector3 base1 = { -sin * kRadius, -kHeight * 0.5f, cos * kRadius };
        Vector3 base2 = { -sinNext * kRadius, 0.0f, cosNext * kRadius };

        uint32_t base = model->GetVertexCount();
        model->AddVertex({ base1.x, base1.y, base1.z, 1.0f }, { 0.0f, 1.0f }, { -sin, 0, cos });
        model->AddVertex({ base2.x, base2.y, base2.z, 1.0f }, { 1.0f, 1.0f }, { -sinNext, 0, cosNext });

        model->AddIndex(apexIndex);
        model->AddIndex(base);
        model->AddIndex(base + 1);
    }

    model->UpdateVertexBuffer();
    model->UpdateIndexBuffer();
}

void MeshBuilder::BuildSpiral(Model* model)
{
    model->ClearVertexData();

    const uint32_t kDivisions = 50;       // åˆ†å‰²æ•°
    const float kWidth = 1.0f;            // é•·æ–¹å½¢ã®å¹…ï¼ˆXæ–¹å‘ï¼‰
    const float kHeight = 5.0f;           // é•·æ–¹å½¢ã®é«˜ã•ï¼ˆZæ–¹å‘ï¼‰
    const float kTwist = 3.0f * std::numbers::pi_v<float>; // ã­ã˜ã‚Œé‡ï¼ˆãƒ©ã‚¸ã‚¢ãƒ³ï¼‰

    for (uint32_t i = 0; i <= kDivisions; ++i) 
    {
        float t = float(i) / float(kDivisions);
        float z = t * kHeight;
        float angle = t * kTwist;

        // å›žè»¢ã«å¿œã˜ãŸX, Y ä½ç½®ï¼ˆå¹…ã®å·¦å³ï¼‰
        float xLeft = -std::cos(angle) * (kWidth * 0.5f);
        float yLeft = -std::sin(angle) * (kWidth * 0.5f);
        float xRight = std::cos(angle) * (kWidth * 0.5f);
        float yRight = std::sin(angle) * (kWidth * 0.5f);

        Vector3 normal = { 0.0f, 0.0f, 1.0f }; // å˜ç´”ã«Zæ–¹å‘

        // å·¦å³ã®2é ‚ç‚¹ã‚’è¿½åŠ 
        model->AddVertex({ xLeft,  yLeft,  z, 1.0f }, { 0.0f, t }, normal);
        model->AddVertex({ xRight, yRight, z, 1.0f }, { 1.0f, t }, normal);
    }

    // ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ï¼ˆä¸‰è§’å½¢åŒ–ï¼‰
    for (uint32_t i = 0; i < kDivisions; ++i) 
    {
        uint32_t base = i * 2;
        model->AddIndex(base + 0);
        model->AddIndex(base + 1);
        model->AddIndex(base + 2);

        model->AddIndex(base + 2);
        model->AddIndex(base + 1);
        model->AddIndex(base + 3);
    }

    model->UpdateVertexBuffer();
    model->UpdateIndexBuffer();
}

void MeshBuilder::BuildTorus(Model* model)
{
    model->ClearVertexData();

    const uint32_t kTubeDiv = 16;
    const uint32_t kCircleDiv = 32;
    const float kOuterR = 1.5f;
    const float kInnerR = 0.4f;

    for (uint32_t i = 0; i < kCircleDiv; ++i)
    {
        float theta = 2.0f * std::numbers::pi_v<float> *float(i) / float(kCircleDiv);
        float nextTheta = 2.0f * std::numbers::pi_v<float> *float(i + 1) / float(kCircleDiv);

        for (uint32_t j = 0; j < kTubeDiv; ++j) 
        {
            float phi = 2.0f * std::numbers::pi_v<float> *float(j) / float(kTubeDiv);
            float nextPhi = 2.0f * std::numbers::pi_v<float> *float(j + 1) / float(kTubeDiv);

            auto point = [&](float t, float p) -> Vector3 
                {
                float x = (kOuterR + kInnerR * std::cos(p)) * std::cos(t);
                float y = kInnerR * std::sin(p);
                float z = (kOuterR + kInnerR * std::cos(p)) * std::sin(t);
                return { x, y, z };
                };

            Vector3 v0 = point(theta, phi);
            Vector3 v1 = point(nextTheta, phi);
            Vector3 v2 = point(theta, nextPhi);
            Vector3 v3 = point(nextTheta, nextPhi);

            uint32_t base = model->GetVertexCount();
            model->AddVertex({ v0.x, v0.y, v0.z, 1.0f }, { 0,0 }, { 0,1,0 });
            model->AddVertex({ v1.x, v1.y, v1.z, 1.0f }, { 1,0 }, { 0,1,0 });
            model->AddVertex({ v2.x, v2.y, v2.z, 1.0f }, { 0,1 }, { 0,1,0 });
            model->AddVertex({ v3.x, v3.y, v3.z, 1.0f }, { 1,1 }, { 0,1,0 });

            model->AddIndex(base + 0);
            model->AddIndex(base + 1);
            model->AddIndex(base + 2);
            model->AddIndex(base + 2);
            model->AddIndex(base + 1);
            model->AddIndex(base + 3);
        }
    }

    model->UpdateVertexBuffer();
    model->UpdateIndexBuffer();
}

void MeshBuilder::BuildHelix(Model* model)
{
    model->ClearVertexData();

    const uint32_t kSegments = 100;
    const float kRadius = 1.0f;
    const float kHeight = 5.0f;
    const uint32_t kTurns = 5;
    const float kWidth = 0.05f;

    for (uint32_t i = 0; i < kSegments; ++i)
    {
        float t = float(i) / float(kSegments);
        float angle = t * kTurns * 2.0f * std::numbers::pi_v<float>;

        float x = std::cos(angle) * kRadius;
        float y = t * kHeight;
        float z = std::sin(angle) * kRadius;

        float nextT = float(i + 1) / float(kSegments);
        float nextAngle = nextT * kTurns * 2.0f * std::numbers::pi_v<float>;
        float nx = std::cos(nextAngle) * kRadius;
        float ny = nextT * kHeight;
        float nz = std::sin(nextAngle) * kRadius;

        Vector3 pos1 = { x, y, z };
        Vector3 pos2 = { nx, ny, nz };
        Vector3 dir = Normalize(pos2 - pos1);
        Vector3 right = Normalize(Cross({ 0, 1, 0 }, dir)) * kWidth;

        Vector3 v0 = pos1 + right;
        Vector3 v1 = pos1 - right;
        Vector3 v2 = pos2 + right;
        Vector3 v3 = pos2 - right;

        uint32_t base = model->GetVertexCount();
        model->AddVertex({ v0.x, v0.y, v0.z, 1.0f }, { 0,0 }, { 0,1,0 });
        model->AddVertex({ v1.x, v1.y, v1.z, 1.0f }, { 1,0 }, { 0,1,0 });
        model->AddVertex({ v2.x, v2.y, v2.z, 1.0f }, { 0,1 }, { 0,1,0 });
        model->AddVertex({ v3.x, v3.y, v3.z, 1.0f }, { 1,1 }, { 0,1,0 });

        model->AddIndex(base + 0);
        model->AddIndex(base + 1);
        model->AddIndex(base + 2);

        model->AddIndex(base + 2);
        model->AddIndex(base + 1);
        model->AddIndex(base + 3);
    }

    model->UpdateVertexBuffer();
    model->UpdateIndexBuffer();
}

void MeshBuilder::BuildSphere(Model* model)
{
    model->ClearVertexData();

    const uint32_t kLatitude = 16;   // ç·¯åº¦åˆ†å‰²æ•°
    const uint32_t kLongitude = 32;  // çµŒåº¦åˆ†å‰²æ•°
    const float kRadius = 0.1f;

    for (uint32_t lat = 0; lat <= kLatitude; ++lat)
    {
        float theta = float(lat) * std::numbers::pi_v<float> / float(kLatitude);
        float y = std::cos(theta) * kRadius;
        float r = std::sin(theta) * kRadius;
        float v = float(lat) / float(kLatitude);

        for (uint32_t lon = 0; lon <= kLongitude; ++lon)
        {
            float phi = float(lon) * 2.0f * std::numbers::pi_v<float> / float(kLongitude);
            float x = std::cos(phi) * r;
            float z = std::sin(phi) * r;
            float u = float(lon) / float(kLongitude);

            Vector3 normal = { x / kRadius, y / kRadius, z / kRadius };
            model->AddVertex({ x, y, z, 1.0f }, { u, v }, normal);
        }
    }

    for (uint32_t lat = 0; lat < kLatitude; ++lat)
    {
        for (uint32_t lon = 0; lon < kLongitude; ++lon) 
        {
            uint32_t curr = lat * (kLongitude + 1) + lon;
            uint32_t next = (lat + 1) * (kLongitude + 1) + lon;

            model->AddIndex(curr);
            model->AddIndex(next);
            model->AddIndex(curr + 1);

            model->AddIndex(curr + 1);
            model->AddIndex(next);
            model->AddIndex(next + 1);
        }
    }

    model->UpdateVertexBuffer();
    model->UpdateIndexBuffer();
}

void MeshBuilder::BuildPetal(Model* model)
{
    model->ClearVertexData();

    // ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿
    const uint32_t kDiv = 32; // åˆ†å‰²æ•°
    const float baseRadius = 0.18f; // æ ¹å…ƒã®åŠå¾„
    const float tipHeight = 0.7f;   // èŠ±ã³ã‚‰ã®é«˜ã•
    const float angleSpan = std::numbers::pi_v<float> *0.85f; // èŠ±ã³ã‚‰ã®é–‹ãè§’åº¦
    const float bulge = 0.18f;      // å´é¢ã®ãµãã‚‰ã¿
    const float tipSplit = 0.08f;   // å…ˆç«¯ã®å‰²ã‚Œ
    const float tipBulge = 0.10f;   // å…ˆç«¯ã®ãµãã‚‰ã¿

    // é ‚ç‚¹ãƒªã‚¹ãƒˆ
    std::vector<uint32_t> edgeIndices;

    // æ ¹å…ƒã®ä¸­å¿ƒ
    uint32_t centerIdx = model->GetVertexCount();
    model->AddVertex({ 0.0f, 0.0f, 0.0f, 1.0f }, { 0.5f, 1.0f }, { 0,0,1 });

    // èŠ±ã³ã‚‰ã®è¼ªéƒ­
    for (uint32_t i = 0; i <= kDiv; ++i) 
    {
        float t = float(i) / float(kDiv);
        float angle = (t - 0.5f) * angleSpan;

        // æ ¹å…ƒã‹ã‚‰å…ˆç«¯ã¾ã§ã®è£œé–“
        float y = std::sin(angle) * baseRadius;
        float x = std::cos(angle) * baseRadius * 0.7f;
        y;
        x;

        // èŠ±ã³ã‚‰ã®å…ˆç«¯ã«å‘ã‹ã†è£œé–“
        float v = t;
        float bulgeFactor = static_cast<float>(std::pow(std::sin(std::numbers::pi_v<float> *t), 2));
        float px = std::sin(angle) * (baseRadius + bulge * bulgeFactor);
        float pz = std::cos(angle) * (baseRadius * 0.7f + bulge * bulgeFactor);
        float py = v * tipHeight;

        // å…ˆç«¯ã®å‰²ã‚Œ
        if (t > 0.45f && t < 0.55f) 
        {
            float split = tipSplit * std::sin((t - 0.5f) * std::numbers::pi_v<float> *2.0f);
            py += tipBulge * std::sin(std::numbers::pi_v<float> *t);
            px += split;
        }

        // å…ˆç«¯ã«è¿‘ã„ã»ã©é«˜ã•ã‚’ä¸Šã’ã‚‹
        float tipRate = std::pow(v, 1.5f);
        float finalY = py;
        float finalX = px * (1.0f - tipRate) + 0.0f * tipRate;
        float finalZ = pz * (1.0f - tipRate) + 0.0f * tipRate;

        float u = t;
        edgeIndices.push_back(model->GetVertexCount());
        model->AddVertex({ finalX, finalY, finalZ, 1.0f }, { u, 1.0f - v }, { 0,0,1 });
    }

    // æ ¹å…ƒã®æ‰‡å½¢
    for (uint32_t i = 0; i < kDiv; ++i) 
    {
        model->AddIndex(centerIdx);
        model->AddIndex(edgeIndices[i]);
        model->AddIndex(edgeIndices[i + 1]);
    }

    // å…ˆç«¯ã®å‰²ã‚Œã‚’å¼·èª¿ã™ã‚‹ãŸã‚ã€å…ˆç«¯ã«è¿½åŠ ã®ä¸‰è§’å½¢ã‚’ä½œã‚‹ã“ã¨ã‚‚ã§ãã¾ã™ï¼ˆçœç•¥å¯ï¼‰

    model->UpdateVertexBuffer();
    model->UpdateIndexBuffer();
}

void MeshBuilder::BuildTriangle(Model* model)
{
    model->ClearVertexData();

    // XYå¹³é¢ä¸Šã®æ­£ä¸‰è§’å½¢
    float scale = 1.0f; // æ‹¡å¤§çŽ‡
    Vector3 v0 = { 0.0f, 0.5f * scale, 0.0f };
    Vector3 v1 = { -0.433f * scale, -0.25f * scale, 0.0f };
    Vector3 v2 = { 0.433f * scale, -0.25f * scale, 0.0f };


    uint32_t base = model->GetVertexCount();
    model->AddVertex({ v0.x, v0.y, v0.z, 1.0f }, { 0.5f, 0.0f }, { 0,0,1 });
    model->AddVertex({ v1.x, v1.y, v1.z, 1.0f }, { 0.0f, 1.0f }, { 0,0,1 });
    model->AddVertex({ v2.x, v2.y, v2.z, 1.0f }, { 1.0f, 1.0f }, { 0,0,1 });

    model->AddIndex(base + 0);
    model->AddIndex(base + 1);
    model->AddIndex(base + 2);

    model->UpdateVertexBuffer();
    model->UpdateIndexBuffer();
}

void MeshBuilder::BuildCube(Model* model)
{
    model->ClearVertexData();

    // 1è¾º0.2fã®ç«‹æ–¹ä½“ï¼ˆä¸­å¿ƒåŽŸç‚¹ï¼‰
    const float h = 1.0f;

    // é ‚ç‚¹åº§æ¨™ï¼ˆx, y, z, wï¼‰
    const Vector4 positions[8] =
    {
        { -h, -h, -h, 1.0f }, // 0: å·¦ä¸‹æ‰‹å‰
        {  h, -h, -h, 1.0f }, // 1: å³ä¸‹æ‰‹å‰
        {  h,  h, -h, 1.0f }, // 2: å³ä¸Šæ‰‹å‰
        { -h,  h, -h, 1.0f }, // 3: å·¦ä¸Šæ‰‹å‰
        { -h, -h,  h, 1.0f }, // 4: å·¦ä¸‹å¥¥
        {  h, -h,  h, 1.0f }, // 5: å³ä¸‹å¥¥
        {  h,  h,  h, 1.0f }, // 6: å³ä¸Šå¥¥
        { -h,  h,  h, 1.0f }, // 7: å·¦ä¸Šå¥¥
    };

    // UVåº§æ¨™ï¼ˆå„é¢å…±é€šï¼‰
    const Vector2 uvs[4] =
    {
        {0.0f, 1.0f}, // å·¦ä¸‹
        {1.0f, 1.0f}, // å³ä¸‹
        {1.0f, 0.0f}, // å³ä¸Š
        {0.0f, 0.0f}, // å·¦ä¸Š
    };

    // å„é¢ã®é ‚ç‚¹ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã¨æ³•ç·š
    struct Face
    {
        int idx[4];
        Vector3 normal;
    };
    const Face faces[6] =
    {
        // å‰é¢
        { {0, 1, 2, 3}, { 0,  0, -1} },
        // èƒŒé¢
        { {5, 4, 7, 6}, { 0,  0,  1} },
        // å·¦é¢
        { {4, 0, 3, 7}, {-1,  0,  0} },
        // å³é¢
        { {1, 5, 6, 2}, { 1,  0,  0} },
        // ä¸Šé¢
        { {3, 2, 6, 7}, { 0,  1,  0} },
        // ä¸‹é¢
        { {4, 5, 1, 0}, { 0, -1,  0} },
    };

    // é ‚ç‚¹è¿½åŠ 
    for (int f = 0; f < 6; ++f)
    {
        uint32_t base = model->GetVertexCount();
        for (int v = 0; v < 4; ++v) 
        {
            model->AddVertex(positions[faces[f].idx[v]], uvs[v], faces[f].normal);
        }
        // ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ï¼ˆ2ä¸‰è§’å½¢ï¼‰
        model->AddIndex(base + 0);
        model->AddIndex(base + 1);
        model->AddIndex(base + 2);
        model->AddIndex(base + 2);
        model->AddIndex(base + 3);
        model->AddIndex(base + 0);
    }

    model->UpdateVertexBuffer();
    model->UpdateIndexBuffer();

}

void MeshBuilder::BuildLine(Model* model)
{
	model->ClearVertexData();

	// åŽŸç‚¹ã‹ã‚‰Yè»¸æ–¹å‘ã«1.0fã®ç·šåˆ†
	Vector3 start = { 0.0f, 0.0f, 0.0f };
	Vector3 end = { 0.2f, 1.2f, 0.2f };
	uint32_t base = model->GetVertexCount();
	
    model->AddVertex({ start.x, start.y, start.z, 1.0f }, { 0.0f, 0.0f }, { 0,0,1 });
	model->AddVertex({ end.x,   end.y,   end.z,   1.0f }, { 1.0f, 1.0f }, { 0,0,1 });
	model->AddIndex(base + 0);
	model->AddIndex(base + 1);
	model->UpdateVertexBuffer();
	model->UpdateIndexBuffer();
}


============================================================
File Path: project/gameEngine/particle/MeshBuilder.h
============================================================
#pragma once

#include <Model.h>

/// <summary>
/// ãƒ¡ãƒƒã‚·ãƒ¥ä½œæˆã‚¯ãƒ©ã‚¹
/// ãƒ¡ãƒƒã‚·ãƒ¥ã‚’é ‚ç‚¹ã¨ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã§ä½œæˆã™ã‚‹
/// </summary>
class MeshBuilder
{
public:

	/// <summary>
	/// Ringä½œæˆ(å††çŠ¶)
	/// </summary>
	/// <param name="model">ãƒ¢ãƒ‡ãƒ«ãƒã‚¤ãƒ³ã‚¿</param>
	static void BuildRing(Model* model);

	/// <summary>
	/// Cylinderä½œæˆ(å††æŸ±çŠ¶ä¸Šä¸‹ãµãŸç„¡)
	/// </summary>
	/// <param name="model">ãƒ¢ãƒ‡ãƒ«ãƒã‚¤ãƒ³ã‚¿</param>
	static void BuildCylinder(Model* model);

	/// <summary>
	/// Coneä½œæˆ(å††éŒ)
	/// </summary>
	/// <param name="model">ãƒ¢ãƒ‡ãƒ«ãƒã‚¤ãƒ³ã‚¿</param>
	static void BuildCone(Model* model);

	/// <summary>
	/// Spiralä½œæˆ(ã­ã˜ã‚Œç·š)
	/// </summary>
	/// <param name="model">ãƒ¢ãƒ‡ãƒ«ãƒã‚¤ãƒ³ã‚¿</param>
	static void BuildSpiral(Model* model);

	/// <summary>
	/// Torusä½œæˆ(ãƒ‰ãƒ¼ãƒŠãƒ„)
	/// </summary>
	/// <param name="model">ãƒ¢ãƒ‡ãƒ«ãƒã‚¤ãƒ³ã‚¿</param>
	static void BuildTorus(Model* model);

	/// <summary>
	/// Helixä½œæˆ(ã°ã­çŠ¶)
	/// </summary>
	/// <param name="model">ãƒ¢ãƒ‡ãƒ«ãƒã‚¤ãƒ³ã‚¿</param>
	static void BuildHelix(Model* model);

	/// <summary>
	/// å°ã•ã„çƒ
	/// </summary>
	/// <param name="model">ãƒ¢ãƒ‡ãƒ«ãƒã‚¤ãƒ³ã‚¿</param>
	static void BuildSphere(Model* model);

	/// <summary>
	/// èŠ±ã³ã‚‰
	/// </summary>
	/// <param name="model">ãƒ¢ãƒ‡ãƒ«ãƒã‚¤ãƒ³ã‚¿</param>
	static void BuildPetal(Model* model);

	/// <summary>
	/// ãƒšãƒ©ãƒšãƒ©ãªä¸‰è§’å½¢
	/// </summary>
	/// <param name="model">ãƒ¢ãƒ‡ãƒ«ãƒã‚¤ãƒ³ã‚¿</param>
	static void BuildTriangle(Model* model);

	/// <summary>
	/// å°ã•ã„ç«‹æ–¹ä½“
	/// </summary>
	/// <param name="model">ãƒ¢ãƒ‡ãƒ«ãƒã‚¤ãƒ³ã‚¿</param>
	static void BuildCube(Model* model);

	/// <summary>
	/// ç·šå½¢çŠ¶
	/// </summary>
	/// <param name="model">ãƒ¢ãƒ‡ãƒ«ãƒã‚¤ãƒ³ã‚¿</param>
	static void BuildLine(Model* model);

};



============================================================
File Path: project/gameEngine/particle/Particle.cpp
============================================================
#include "Particle.h"


============================================================
File Path: project/gameEngine/particle/Particle.h
============================================================
#pragma once

#include <string>

#include "MyMath.h"

/// <summary>
/// ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«1ã¤åˆ†ã®æƒ…å ±
/// ç²’å­ã®ä½ç½®ã€é€Ÿåº¦ã€å¯¿å‘½ãªã©
/// </summary>
class Particle
{
public:
    struct Transform
    {
        Vector3 scale;
        Vector3 rotate;
        Vector3 translate;
    };

    // ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã®çŠ¶æ…‹
    Transform transform;
    Vector3 velocity;
    Vector3 angularVelocity{0,0,0};
    Vector3 scaleVelocity{ 0,0,0 };
    Vector4 color;
    float lifeTime;
    float currentTime;

    std::string motionName;

	// ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿
    Particle()
		: velocity(0.0f, 0.0f, 0.0f), color(1.0f, 1.0f, 1.0f, 1.0f), lifeTime(1.0f), currentTime(0.0f)
    {
        transform.scale = Vector3(1.0f, 1.0f, 1.0f);
        transform.rotate = Vector3(0.0f, 0.0f, 0.0f);
        transform.translate = Vector3(0.0f, 0.0f, 0.0f);
    }
};


============================================================
File Path: project/gameEngine/particle/ParticleEmitter.cpp
============================================================
#include "ParticleEmitter.h"

void ParticleEmitter::Emit(const std::string& groupName, const Vector3& position, uint32_t count)
{
	if (auto manager = ParticleManager::GetInstance())
	{
		manager->Emit(groupName, position, count);
	}
}

void ParticleEmitter::StartLoop(const std::string& groupName, const std::string& motionName, const Vector3& position, uint32_t count)
{
	if (auto manager = ParticleManager::GetInstance())
	{
		EmitSetting setting;
		setting.groupName = groupName;
		setting.motionName = motionName;
		setting.emitPosition = position;
		setting.emitCount = count;
		setting.isLooping = true;
		manager->AddEmitterSetting(setting);
	}
}

void ParticleEmitter::EmitOnce(const Vector3& position, uint32_t count)
{
	if (manager_) 
	{
		manager_->Emit(groupName_, position, count);
	}
}

void ParticleEmitter::StartLoopEmit(const Vector3& position, uint32_t count)
{
	if (!manager_)
	{
		return;
	}

	EmitSetting setting;
	setting.groupName = groupName_;
	setting.motionName = motionName_;
	setting.emitPosition = position;
	setting.emitCount = count;
	setting.isLooping = true;

	manager_->AddEmitterSetting(setting);
}


============================================================
File Path: project/gameEngine/particle/ParticleEmitter.h
============================================================
#pragma once

#include <unordered_map>
#include <random> 

#include "ParticleManager.h"

/// <summary>
/// ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã‚¨ãƒŸãƒƒã‚¿ãƒ¼
/// ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã‚’ç™ºç”Ÿã•ã›ã‚‹
/// </summary>
class ParticleEmitter
{
public:

	/// <summary>
	/// é™çš„å˜ç™ºã‚¨ãƒŸãƒƒãƒˆ
	/// </summary>
	/// <param name="groupName">ã‚°ãƒ«ãƒ¼ãƒ—å</param>
	/// <param name="position">ç™ºç”Ÿä½ç½®</param>
	/// <param name="count">ç™ºç”Ÿæ•°</param>
	static void Emit(const std::string& groupName, const Vector3& position, uint32_t count = 10);

	/// <summary>
	/// é™çš„ãƒ«ãƒ¼ãƒ—ã‚¨ãƒŸãƒƒãƒˆ
	/// </summary>
	/// <param name="groupName">ã‚°ãƒ«ãƒ¼ãƒ—å</param>
	/// <param name="motionName">ãƒ¢ãƒ¼ã‚·ãƒ§ãƒ³å</param>
	/// <param name="position">ç™ºç”Ÿä½ç½®</param>
	/// <param name="count">ç™ºç”Ÿæ•°</param>
	static void StartLoop(const std::string& groupName, const std::string& motionName, const Vector3& position, uint32_t count = 10);
	
	// --- ä»¥ä¸‹ã¯ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ç”¨ï¼šå¿…è¦ãªã‚‰ä½¿ã† ---
	// ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿
	ParticleEmitter(ParticleManager* manager, const std::string& groupName, const std::string& motionName = "Homing")
		: manager_(manager), groupName_(groupName), motionName_(motionName)
	{
	}

	/// <summary>
	/// å˜ç™ºã‚¨ãƒŸãƒƒãƒˆ
	/// </summary>
	/// <param name="position">ç™ºç”Ÿä½ç½®</param>
	/// <param name="count">ç™ºç”Ÿæ•°</param>
	void EmitOnce(const Vector3& position, uint32_t count = 10);

	/// <summary>
	/// ãƒ«ãƒ¼ãƒ—ã‚¨ãƒŸãƒƒãƒˆé–‹å§‹
	/// </summary>
	/// <param name="position">ç™ºç”Ÿä½ç½®</param>
	/// <param name="count">ç™ºç”Ÿæ•°</param>
	void StartLoopEmit(const Vector3& position, uint32_t count);


private:

	// Managerã‚¯ãƒ©ã‚¹
	ParticleManager* manager_ = nullptr;
	
	// ã‚°ãƒ«ãƒ¼ãƒ—å
	std::string groupName_;
	
	// ãƒ¢ãƒ¼ã‚·ãƒ§ãƒ³å
	std::string motionName_;

};



============================================================
File Path: project/gameEngine/particle/ParticleManager.cpp
============================================================
#include "ParticleManager.h"

#include <wrl.h>
#include <stdexcept>
#include <vector>
#include <random>
#include <numbers>
#include <MyMath.h>

#include "Object3dCommon.h"
#include "ModelManager.h"
#include "TimeManager.h"

ParticleManager* ParticleManager::GetInstance()
{
    static ParticleManager instance;
    return &instance;
}

void ParticleManager::Initialize(DirectXCommon* dxCommon, SrvManager* srvManager, ModelCommon* modelCommon)
{
    dxCommon_ = dxCommon;
    srvManager_ = srvManager;
    modelCommon_ = modelCommon;
    object3dCommon_ = Object3dCommon::GetInstance();
    // ãƒ©ãƒ³ãƒ€ãƒ ã‚¨ãƒ³ã‚¸ãƒ³ã®åˆæœŸåŒ–
    randomEngine_ = std::mt19937{ std::random_device{}() };

    // ãƒ¢ãƒ¼ã‚·ãƒ§ãƒ³ç™»éŒ²
	ParticleMotion::Initialize();

    // ï¼ˆCylinderæ–¹å‘ãªã©å¿…è¦ã‚ã‚Œã°æŒ‡å®šï¼‰
    ParticleMotion::SetDirection("UP");

    // ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³ç”Ÿæˆ
    CreatePipeline();

    transform_ = { {1.0f,1.0f,1.0f},{0.0f,0.0f,0.0f},{0.0f,0.0f,0.0f} };

    // ãƒ“ãƒ«ãƒœãƒ¼ãƒ‰è¡Œåˆ—ã®ä½œæˆ
    backToFrontMatrix_ = MakeRotateYMatrix(std::numbers::pi_v<float>);

    //ãƒžãƒ†ãƒªã‚¢ãƒ«
    //modelãƒžãƒ†ãƒªã‚¢ã‚‹ç”¨ã®ãƒªã‚½ãƒ¼ã‚¹ã‚’ä½œã‚‹ã€‚ä»Šå›žcolor1ã¤åˆ†ã®ã‚µã‚¤ã‚ºã‚’ç”¨æ„ã™ã‚‹
    materialResource_ = dxCommon_->CreateBufferResource(sizeof(Material));
    //ãƒžãƒ†ãƒªã‚¢ãƒ«ã«ãƒ‡ãƒ¼ã‚¿ã‚’æ›¸ãè¾¼ã‚€
    materialData_ = nullptr;
    materialResource_->Map(0, nullptr, reinterpret_cast<void**>(&materialData_));
    //è‰²
    materialData_->color = { Vector4(1.0f, 1.0f, 1.0f, 1.0f) };
    materialData_->enableLighting = false;//æœ‰åŠ¹ã«ã™ã‚‹ã‹å¦ã‹
    materialData_->uvTransform = MakeIdentity4x4();

    camera_ = object3dCommon_->GetDefaultCamera();
}

void ParticleManager::Finalize(){}

void ParticleManager::CreatePipeline()
{
    HRESULT result = S_FALSE;

    CreateRootSignature();

    //PSOã‚’ç”Ÿæˆã™ã‚‹
    D3D12_GRAPHICS_PIPELINE_STATE_DESC graphicsPipelineStateDesc{};
    graphicsPipelineStateDesc.pRootSignature = rootSignature_.Get();
    graphicsPipelineStateDesc.InputLayout = inputLayoutDesc_;
    graphicsPipelineStateDesc.VS = { vertexShaderBlob_->GetBufferPointer(),vertexShaderBlob_->GetBufferSize() };
    graphicsPipelineStateDesc.PS = { pixelShaderBlob_->GetBufferPointer(),pixelShaderBlob_->GetBufferSize() };
    graphicsPipelineStateDesc.BlendState = blendDesc_;
    graphicsPipelineStateDesc.RasterizerState = rasterizerDesc_;
    //DepthStencilã®è¨­å®š
    graphicsPipelineStateDesc.DepthStencilState = depthStencilDesc_;
    graphicsPipelineStateDesc.DSVFormat = DXGI_FORMAT_D24_UNORM_S8_UINT;

    //æ›¸ãè¾¼ã‚€RTVã®æƒ…å ±
    graphicsPipelineStateDesc.NumRenderTargets = 1;
    graphicsPipelineStateDesc.RTVFormats[0] = DXGI_FORMAT_R8G8B8A8_UNORM_SRGB;
    //åˆ©ç”¨ã™ã‚‹ãƒˆãƒãƒ­ã‚¸ï¼ˆå½¢çŠ¶ï¼‰ã®ã‚¿ã‚¤ãƒ—ã€‚ä¸‰è§’å½¢
    graphicsPipelineStateDesc.PrimitiveTopologyType = D3D12_PRIMITIVE_TOPOLOGY_TYPE_TRIANGLE;
    //ã©ã®ã‚ˆã†ã«ç”»é¢ã«è‰²ã‚’æ‰“ã¡è¾¼ã‚€ã‹ã®è¨­å®šï¼ˆæ°—ã«ã—ãªãã¦ã„ã„ï¼‰
    graphicsPipelineStateDesc.SampleDesc.Count = 1;
    graphicsPipelineStateDesc.SampleMask = D3D12_DEFAULT_SAMPLE_MASK;
    //å®Ÿéš›ã«ç”Ÿæˆ
    result = dxCommon_->GetDevice()->CreateGraphicsPipelineState(&graphicsPipelineStateDesc, IID_PPV_ARGS(&pipelineState_));
    assert(SUCCEEDED(result));

    // ã‚«ãƒªãƒ³ã‚°ã—ãªã„ï¼ˆè£é¢ã‚‚è¡¨ç¤ºã•ã›ã‚‹ï¼‰
    rasterizerDesc_.CullMode = D3D12_CULL_MODE_NONE;
}

void ParticleManager::CreateRootSignature()
{
    HRESULT result = S_FALSE;

    //ãƒ‡ã‚£ã‚¹ã‚¯ãƒªãƒ—ã‚¿ãƒ¬ãƒ³ã‚¸ã®ç”Ÿæˆ
    descriptorRange_[0].BaseShaderRegister = 0;
    descriptorRange_[0].NumDescriptors = 1;
    descriptorRange_[0].RangeType = D3D12_DESCRIPTOR_RANGE_TYPE_SRV;
    descriptorRange_[0].OffsetInDescriptorsFromTableStart = D3D12_DESCRIPTOR_RANGE_OFFSET_APPEND;

    descriptionRootSignature_.Flags = D3D12_ROOT_SIGNATURE_FLAG_ALLOW_INPUT_ASSEMBLER_INPUT_LAYOUT;

    //RootParameterä½œæˆã€‚è¤‡æ•°è¨­å®šã§ãã‚‹ã®ã§é…åˆ—ã€‚ä»Šå›žã¯çµæžœï¼‘ã¤ã ã‘ãªã®ã§é•·ã•ï¼‘ã®é…åˆ—
    D3D12_ROOT_PARAMETER rootParameter[3] = {};
    rootParameter[0].ParameterType = D3D12_ROOT_PARAMETER_TYPE_CBV;
    rootParameter[0].ShaderVisibility = D3D12_SHADER_VISIBILITY_PIXEL;
    rootParameter[0].Descriptor.ShaderRegister = 0;

    rootParameter[1].ParameterType = D3D12_ROOT_PARAMETER_TYPE_DESCRIPTOR_TABLE;
    rootParameter[1].ShaderVisibility = D3D12_SHADER_VISIBILITY_VERTEX;
    rootParameter[1].DescriptorTable.pDescriptorRanges = descriptorRange_;
    rootParameter[1].DescriptorTable.NumDescriptorRanges = _countof(descriptorRange_);

    rootParameter[2].ParameterType = D3D12_ROOT_PARAMETER_TYPE_DESCRIPTOR_TABLE;
    rootParameter[2].ShaderVisibility = D3D12_SHADER_VISIBILITY_PIXEL;
    rootParameter[2].DescriptorTable.pDescriptorRanges = descriptorRange_;
    rootParameter[2].DescriptorTable.NumDescriptorRanges = _countof(descriptorRange_);

    descriptionRootSignature_.pParameters = rootParameter;
    descriptionRootSignature_.NumParameters = _countof(rootParameter);

    //Smaplerã®è¨­å®š
    staticSamplers_[0].Filter = D3D12_FILTER_MIN_MAG_POINT_MIP_LINEAR;
    staticSamplers_[0].AddressU = D3D12_TEXTURE_ADDRESS_MODE_WRAP;
    staticSamplers_[0].AddressV = D3D12_TEXTURE_ADDRESS_MODE_CLAMP;
    staticSamplers_[0].AddressW = D3D12_TEXTURE_ADDRESS_MODE_WRAP;
    staticSamplers_[0].ComparisonFunc = D3D12_COMPARISON_FUNC_NEVER;
    staticSamplers_[0].MaxLOD = D3D12_FLOAT32_MAX;
    staticSamplers_[0].ShaderRegister = 0;
    staticSamplers_[0].ShaderVisibility = D3D12_SHADER_VISIBILITY_PIXEL;
    descriptionRootSignature_.pStaticSamplers = staticSamplers_;
    descriptionRootSignature_.NumStaticSamplers = _countof(staticSamplers_);



    // ã‚·ãƒªã‚¢ãƒ©ã‚¤ã‚ºã—ã¦ãƒã‚¤ãƒŠãƒªã«ã™ã‚‹
    Microsoft::WRL::ComPtr<ID3DBlob> signatureBlob = nullptr;
    Microsoft::WRL::ComPtr<ID3DBlob> errorBlob = nullptr;
    result = D3D12SerializeRootSignature(&descriptionRootSignature_,
        D3D_ROOT_SIGNATURE_VERSION_1, &signatureBlob, &errorBlob);
    if (FAILED(result)) {
        Logger::Log(reinterpret_cast<char*>(errorBlob->GetBufferPointer()));
        assert(false);
    }
    // ãƒã‚¤ãƒŠãƒªã‚’å…ƒã«ç”Ÿæˆ
    result = dxCommon_->GetDevice()->CreateRootSignature(0,
        signatureBlob->GetBufferPointer(), signatureBlob->GetBufferSize(),
        IID_PPV_ARGS(&rootSignature_));
    assert(SUCCEEDED(result));


    // InputLayoutã®è¨­å®š
    inputElementDescs_[0].SemanticName = "POSITION";
    inputElementDescs_[0].SemanticIndex = 0;
    inputElementDescs_[0].Format = DXGI_FORMAT_R32G32B32A32_FLOAT;
    inputElementDescs_[0].AlignedByteOffset = D3D12_APPEND_ALIGNED_ELEMENT;

    inputElementDescs_[1].SemanticName = "TEXCOORD";
    inputElementDescs_[1].SemanticIndex = 0;
    inputElementDescs_[1].Format = DXGI_FORMAT_R32G32_FLOAT;
    inputElementDescs_[1].AlignedByteOffset = D3D12_APPEND_ALIGNED_ELEMENT;

    inputElementDescs_[2].SemanticName = "NORMAL";
    inputElementDescs_[2].SemanticIndex = 0;
    inputElementDescs_[2].Format = DXGI_FORMAT_R32G32B32_FLOAT;
    inputElementDescs_[2].AlignedByteOffset = D3D12_APPEND_ALIGNED_ELEMENT;

    inputLayoutDesc_.pInputElementDescs = inputElementDescs_;
    inputLayoutDesc_.NumElements = _countof(inputElementDescs_);

    // BlendStateã®è¨­å®š
    // å…¨ã¦ã®è‰²è¦ç´ ã‚’æ›¸ãè¾¼ã‚€
    blendDesc_.RenderTarget[0].RenderTargetWriteMask = D3D12_COLOR_WRITE_ENABLE_ALL;
    blendDesc_.RenderTarget[0].BlendEnable = TRUE;
    blendDesc_.RenderTarget[0].SrcBlendAlpha = D3D12_BLEND_ONE;//zero
    blendDesc_.RenderTarget[0].BlendOpAlpha = D3D12_BLEND_OP_ADD;
    blendDesc_.RenderTarget[0].DestBlendAlpha = D3D12_BLEND_ZERO;
    blendDesc_.RenderTarget[0].SrcBlend = D3D12_BLEND_SRC_ALPHA;
    blendDesc_.RenderTarget[0].BlendOp = D3D12_BLEND_OP_ADD;
    blendDesc_.RenderTarget[0].DestBlend = D3D12_BLEND_ONE;

    // RasterizerStateã®è¨­å®š
    // è£é¢(æ™‚è¨ˆå›žã‚Š)ã®è¡¨ç¤ºã®æœ‰ç„¡ (NONE / BACK)
    rasterizerDesc_.CullMode = D3D12_CULL_MODE_NONE;
    // å¡—ã‚Šã¤ã¶ã™ã‹ã©ã†ã‹
    rasterizerDesc_.FillMode = D3D12_FILL_MODE_SOLID;

    // Shaderã‚’ã‚³ãƒ³ãƒ‘ã‚¤ãƒ« 
    vertexShaderBlob_ = dxCommon_->CompileShader(L"resources/shaders/Particle.VS.hlsl", L"vs_6_0");
    assert(vertexShaderBlob_ != nullptr);
    pixelShaderBlob_ = dxCommon_->CompileShader(L"resources/shaders/Particle.PS.hlsl", L"ps_6_0");
    assert(pixelShaderBlob_ != nullptr);

    // DepthStencilStateã®è¨­å®š
    // Depthã®æ©Ÿèƒ½ã‚’æœ‰åŠ¹åŒ–
    depthStencilDesc_.DepthEnable = true;
    depthStencilDesc_.DepthWriteMask = D3D12_DEPTH_WRITE_MASK_ZERO;//D3D12_DEPTH_WRITE_MASK_ALL;
    depthStencilDesc_.DepthFunc = D3D12_COMPARISON_FUNC_LESS_EQUAL;
}

void ParticleManager::CreateParticleGroup(const std::string& name, const std::string& textureFilePath, const std::string& modelFilePath, const std::string& type, const std::string& motionName)
{
    ModelManager::GetInstance()->LoadModel(modelFilePath);

    std::unique_ptr<Model> model = std::make_unique<Model>();
    model->Initialize(modelCommon_, "resources/models", modelFilePath);
    models_[name] = std::move(model);

    if (particleGroups.contains(name))
    {
        return;
    }

    // ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã‚°ãƒ«ãƒ¼ãƒ—ã‚’ä½œæˆã€ã‚³ãƒ³ãƒ†ãƒŠã«ç™»éŒ²
    ParticleGroup newGroup = {};
    newGroup.motionName = motionName;
    particleGroups.insert(std::make_pair(name, std::move(newGroup)));

    // ãƒ†ã‚¯ã‚¹ãƒãƒ£ãƒ•ã‚¡ã‚¤ãƒ«ãƒ‘ã‚¹ã‚’ç™»éŒ²
    particleGroups.at(name).materialData.textureFilePath = textureFilePath;
    // ãƒ†ã‚¯ã‚¹ãƒãƒ£ã‚’èª­ã¿è¾¼ã‚“ã§SRVã‚’ç”Ÿæˆ
    TextureManager::GetInstance()->LoadTexture(textureFilePath);
    // SRVã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã‚’ç™»éŒ²
    particleGroups.at(name).materialData.textureIndex = TextureManager::GetInstance()->GetTextureIndexByFilePath(textureFilePath);
    // æœ€å¤§æ•°ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹
    uint32_t MaxInstanceCount = 1024;
    // ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹æ•°ã‚’åˆæœŸåŒ–
    particleGroups.at(name).instanceCount = 0;
    // ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ç”¨ãƒªã‚½ãƒ¼ã‚¹ã‚’ç”Ÿæˆ
    particleGroups.at(name).instancingResource = dxCommon_->CreateBufferResource(sizeof(ParticleForGPU) * MaxInstanceCount);
    // ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ç”¨ãƒªã‚½ãƒ¼ã‚¹ã‚’ãƒžãƒƒãƒ—
    particleGroups.at(name).instancingResource->Map(0, nullptr, reinterpret_cast<void**>(&particleGroups.at(name).instancingData));
    // ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã®ãƒ‡ãƒ¼ã‚¿ã‚’åˆæœŸåŒ–
    ParticleForGPU particleForGPU = {};
    particleForGPU.WVP = MakeIdentity4x4();
    particleForGPU.world = MakeIdentity4x4();
    particleForGPU.color = Vector4(1.0f, 1.0f, 1.0f, 1.0f);
    // ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã®ãƒ‡ãƒ¼ã‚¿ã‚’ç™»éŒ²
    for (uint32_t i = 0; i < MaxInstanceCount; ++i)
    {
        particleGroups.at(name).instancingData[i] = particleForGPU;

        particleGroups.at(name).instancingData[i].WVP = MakeIdentity4x4();
        particleGroups.at(name).instancingData[i].world = MakeIdentity4x4();
        particleGroups.at(name).instancingData[i].color = Vector4(0, 0, 0, 0); // å®Œå…¨ã«é€æ˜Ž
    }

    // ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ç”¨ã®SRVã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹
    particleGroups.at(name).srvIndex = srvManager_->Allocate();
    // srvã‚’ç”Ÿæˆ
    srvManager_->CreateSRVforStructuredBuffer(particleGroups.at(name).srvIndex, particleGroups.at(name).instancingResource.Get(), MaxInstanceCount, sizeof(ParticleForGPU));

    // ãƒ¢ãƒ‡ãƒ«ã®é ‚ç‚¹ã‚’æ§‹ç¯‰
    using BuildFunc = std::function<void(Model*)>;

    static const std::unordered_map<std::string, BuildFunc> shapeBuilders = {
        { "Ring",     MeshBuilder::BuildRing },
        { "Cylinder", MeshBuilder::BuildCylinder },
        { "Cone",     MeshBuilder::BuildCone },
        { "Spiral",   MeshBuilder::BuildSpiral },
        { "Torus",    MeshBuilder::BuildTorus },
        { "Helix",    MeshBuilder::BuildHelix },
        { "Sphere",   MeshBuilder::BuildSphere },
        { "Triangle", MeshBuilder::BuildTriangle },
        { "Petal",    MeshBuilder::BuildPetal},
		{ "Cube",     MeshBuilder::BuildCube },
		{ "Line",     MeshBuilder::BuildLine },
    };

    // ãƒ¢ãƒ‡ãƒ«æ§‹ç¯‰å¾Œã«å‘¼ã¶
    auto it = shapeBuilders.find(type);
    if (it != shapeBuilders.end())
    {
        it->second(models_[name].get());
    }
}

void ParticleManager::Update()
{
	// TimeManagerã‹ã‚‰ãƒ‡ãƒ«ã‚¿ã‚¿ã‚¤ãƒ ã‚’å–å¾—
	const float dt = TimeManager::Instance().GetDeltaTime();
	
    camera_ = object3dCommon_->GetDefaultCamera();

    Matrix4x4 viewMatrix = camera_->GetViewMatrix();
    Matrix4x4 projectionMatrix = camera_->GetProjectionMatrix();
    Matrix4x4 billboardMatrix = backToFrontMatrix_ * viewMatrix;
    billboardMatrix.m[3][0] = 0.0f;
    billboardMatrix.m[3][1] = 0.0f;
    billboardMatrix.m[3][2] = 0.0f;

    if (std::isnan(billboardMatrix.m[0][0]) || std::isinf(billboardMatrix.m[0][0])) {
        Logger::Log("billboardMatrix ã«ç•°å¸¸ãªå€¤ãŒå«ã¾ã‚Œã¦ã„ã¾ã™ï¼");
    }

    for (auto& [name, Particlegroup] : particleGroups)
    {
        uint32_t count = 0;
        // å„ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã®å‡¦ç†
        for (auto it = Particlegroup.particleList.begin(); it != Particlegroup.particleList.end();)
        {
            // å¯¿å‘½ãŒçµ‚ã‚ã£ãŸãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã‚’å‰Šé™¤
            if ((*it).currentTime >= (*it).lifeTime)
            {
                it = Particlegroup.particleList.erase(it);
                continue;
            }

            // ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã®ä½ç½®ã‚’æ›´æ–°
            (*it).transform.translate += (*it).velocity * dt;
            // ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã®å›žè»¢ã‚’æ›´æ–°
            (*it).transform.rotate += (*it).angularVelocity * dt;
            // ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã®ã‚¹ã‚±ãƒ¼ãƒ«ã‚’æ›´æ–°
            (*it).transform.scale += (*it).scaleVelocity * dt;
            // ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã®å¯¿å‘½
            (*it).currentTime += dt;
            float alpha = 1.0f - ((*it).currentTime / (*it).lifeTime);

            // ã‚¢ãƒ«ãƒ•ã‚¡å€¤ã‚’ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã®è‰²ã«é©ç”¨
            (*it).color.w = alpha;


            // SRTã‹ã‚‰Translateã‚’åˆ†é›¢
            Matrix4x4 SR =
                MakeScaleMatrix((*it).transform.scale) *
                MakeRotateXMatrix((*it).transform.rotate.x) *
                MakeRotateYMatrix((*it).transform.rotate.y) *
                MakeRotateZMatrix((*it).transform.rotate.z);

            // ãƒ“ãƒ«ãƒœãƒ¼ãƒ‰è¡Œåˆ—ã‚’SRã«æŽ›ã‘ã‚‹
            Matrix4x4 billboardSR = SR * billboardMatrix;

            // æœ€å¾Œã«Translateã‚’æŽ›ã‘ã‚‹
            Matrix4x4 worldMatrix = billboardSR * MakeTranslateMatrix((*it).transform.translate);

            Matrix4x4 wVPMatrix = worldMatrix * viewMatrix * projectionMatrix;

            // SRVãƒãƒƒãƒ•ã‚¡ã®æœ€å¤§æ•°ã«å®‰å…¨ãƒã‚§ãƒƒã‚¯
            if (count < 1024)
            { 
                Particlegroup.instancingData[count].WVP = wVPMatrix;
                Particlegroup.instancingData[count].world = worldMatrix;
                Particlegroup.instancingData[count].color = it->color;
                ++count;
            }


            // æ¬¡ã®ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã¸
            ++it;
        }

        Particlegroup.instanceCount = count;

    }

    for (auto& setting : emitSettings_)
    {
        if (setting.isLooping && particleGroups.contains(setting.groupName))
        {
            // ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã‚’ç™ºç”Ÿ
            Emit(setting.groupName, setting.emitPosition, setting.emitCount);

        }
    }
}

void ParticleManager::Draw()
{
    if (particleGroups.empty())
    {
        return;
    }

    // å…±é€šè¨­å®š
    dxCommon_->GetCommandList()->SetGraphicsRootSignature(rootSignature_.Get());
    dxCommon_->GetCommandList()->SetPipelineState(pipelineState_.Get());
    dxCommon_->GetCommandList()->IASetPrimitiveTopology(D3D_PRIMITIVE_TOPOLOGY_TRIANGLELIST);

    for (const auto& [name, ParticleGroup] : particleGroups)
    {
        if (ParticleGroup.instanceCount == 0) continue;

        // ---- ã‚°ãƒ«ãƒ¼ãƒ—ã”ã¨ã®ãƒ¢ãƒ‡ãƒ«ã‚’å–å¾— ----
        Model* model = models_[name].get();
        assert(model != nullptr);
        UINT indexCount = static_cast<UINT>(model->GetModelData().indices.size());
        assert(indexCount < 10000);
        indexCount;

        // ---- ãƒ¢ãƒ‡ãƒ«ã«åˆã‚ã›ã¦ Vertex/Index Buffer ã‚’è¨­å®š ----
        D3D12_VERTEX_BUFFER_VIEW vbv = model->GetVertexBufferView();
        D3D12_INDEX_BUFFER_VIEW ibv = model->GetIndexBufferView();

        dxCommon_->GetCommandList()->IASetVertexBuffers(0, 1, &vbv);
        dxCommon_->GetCommandList()->IASetIndexBuffer(&ibv);

        // ---- ãƒžãƒ†ãƒªã‚¢ãƒ«ã¯å…±é€šã§ã‚‚è‰¯ã„ï¼ˆå¿…è¦ãªã‚‰å€‹åˆ¥å¯¾å¿œå¯èƒ½ï¼‰ ----
        dxCommon_->GetCommandList()->SetGraphicsRootConstantBufferView(0, materialResource_->GetGPUVirtualAddress());

        // ---- ãƒ†ã‚¯ã‚¹ãƒãƒ£ã¨ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹SRVï¼ˆé€†ã«ã—ã¦ã„ã‚‹ã‹ã‚‚ï¼‰----
        srvManager_->SetGraphicsRootDescriptorTable(1, ParticleGroup.srvIndex); // StructuredBuffer (instancing)
        srvManager_->SetGraphicsRootDescriptorTable(2, ParticleGroup.materialData.textureIndex); // Texture SRV

        // ---- æç”» ----
        dxCommon_->GetCommandList()->DrawIndexedInstanced(
            static_cast<UINT>(model->GetModelData().indices.size()),
            ParticleGroup.instanceCount,
            0, 0, 0);
    }

}

void ParticleManager::Emit(const std::string groupName, const Vector3& position, uint32_t count)
{
    // ã‚°ãƒ«ãƒ¼ãƒ—ã”ã¨ã®motionNameã‚’ä½¿ã†Emit
    auto it = particleGroups.find(groupName);
    if (it == particleGroups.end())
    {
        return;
    }

    EmitSetting newSetting;
    newSetting.groupName = groupName;
    newSetting.motionName = it->second.motionName;
    newSetting.emitCount = count;
    newSetting.emitPosition = position;
    newSetting.isLooping = false; // åˆæœŸçŠ¶æ…‹ã¯ãƒ«ãƒ¼ãƒ—ç„¡ã—
    emitSettings_.push_back(newSetting);


    // ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ç”Ÿæˆ
    ParticleGroup& group = it->second;
    for (uint32_t i = 0; i < count; ++i)
    {
        Particle p = ParticleMotion::Create(group.motionName, randomEngine_, position);
        p.motionName = group.motionName;
        group.particleList.push_back(p);
    }

    group.instanceCount = static_cast<uint32_t>(group.particleList.size());

}

void ParticleManager::AddEmitterSetting(const EmitSetting& setting)
{
    EmitSetting native;
    native.groupName = setting.groupName;
    native.motionName = setting.motionName;
    native.emitPosition = setting.emitPosition;
    native.emitCount = setting.emitCount;
    native.timer = setting.timer;
    native.isLooping = setting.isLooping;
    emitSettings_.push_back(native);
}

void ParticleManager::DebugUI()
{
    static std::string newGroupName = "MyGroup";
    static std::string selectedShape = "Ring";
    static const char* shapeOptions[] = { "Ring", "Cylinder", "Cone", "Spiral", "Torus", "Helix", "Sphere", "Petal","Triangle","Petal","Cube"};
    static int currentShape = 0;

    static int selectedGroupIndex = 0;
    static int currentMotion = 0;
    static std::string selectedMotion = "Homing";

    static int emitCount = 10;
    static Vector3 emitPosition = { 0.0f, 1.0f, 0.0f };

    // Motion ä¸€è¦§å–å¾—
    const auto& motionMap = ParticleMotion::GetAll();
    static std::vector<std::string> motionNames;
    if (motionNames.empty())
    {
        for (const auto& [name, _] : motionMap)
        {
            motionNames.push_back(name);
        }
    }

    // ã‚°ãƒ«ãƒ¼ãƒ—ä¸€è¦§å–å¾—
    std::vector<std::string> groupNames;
    for (const auto& [name, _] : particleGroups) {
        groupNames.push_back(name);
    }

#ifdef USE_IMGUI

    if (ImGui::Begin("Particle Control")) {

        // --- æ–°è¦ä½œæˆç”¨ã‚°ãƒ«ãƒ¼ãƒ—åå…¥åŠ› ---
        char groupNameBuffer[128] = {};
        strcpy_s(groupNameBuffer, newGroupName.c_str());

        if (ImGui::InputText("New GroupName", groupNameBuffer, sizeof(groupNameBuffer))) {
            newGroupName = groupNameBuffer;
        }

        // --- å½¢çŠ¶é¸æŠž ---
        if (ImGui::Combo("Shape", &currentShape, shapeOptions, IM_ARRAYSIZE(shapeOptions))) {
            selectedShape = shapeOptions[currentShape];
        }

        if (ImGui::Button("Create Group")) {
            CreateParticleGroup(newGroupName, "resources/images/monsterBall.png", "plane.obj", selectedShape, selectedMotion);

        }

        // --- ãƒ¢ãƒ¼ã‚·ãƒ§ãƒ³é¸æŠž ---
        if (ImGui::Combo("Motion", &currentMotion, [](void* data, int idx, const char** out_text) {
            const auto& names = *static_cast<std::vector<std::string>*>(data);
            if (idx < 0 || idx >= names.size()) return false;
            *out_text = names[idx].c_str();
            return true;
            }, (void*)&motionNames, (int)motionNames.size())) {
            selectedMotion = motionNames[currentMotion];
        }

        ImGui::Separator();

        ImGui::SliderInt("Emit Count", &emitCount, 1, 100);
        ImGui::InputFloat3("Emit Position", reinterpret_cast<float*>(&emitPosition));

        // --- æ—¢å­˜ã‚°ãƒ«ãƒ¼ãƒ—é¸æŠž ---
        if (!groupNames.empty()) {
            ImGui::Text("Emit to Group:");
            ImGui::Combo("##GroupList", &selectedGroupIndex, [](void* data, int idx, const char** out_text) {
                const auto& names = *static_cast<std::vector<std::string>*>(data);
                if (idx < 0 || idx >= names.size()) return false;
                *out_text = names[idx].c_str();
                return true;
                }, (void*)&groupNames, (int)groupNames.size());
        }

        // --- Emit ä¸€å›žã ã‘ ---
        if (ImGui::Button("Emit Particle") && selectedGroupIndex < groupNames.size()) 
        {
            const std::string& groupToEmit = groupNames[selectedGroupIndex];
            Emit(groupToEmit, emitPosition, emitCount);
        }

        // --- ãƒ«ãƒ¼ãƒ— Emit ã®é–‹å§‹ãƒ»åœæ­¢ ---
        if (ImGui::Button("Emit Loop") && selectedGroupIndex < groupNames.size()) 
        {
            const std::string& selectedGroup = groupNames[selectedGroupIndex];

            // åŒã˜ã‚°ãƒ«ãƒ¼ãƒ—ãŒæ—¢ã«è¨­å®šã•ã‚Œã¦ã„ã‚Œã°æ›´æ–°ã€ãªã‘ã‚Œã°è¿½åŠ 
            auto it = std::find_if(emitSettings_.begin(), emitSettings_.end(),
                [&](const EmitSetting& s) { return s.groupName == selectedGroup; });

            if (it != emitSettings_.end())
            {
                // æ—¢ã«ã‚ã‚‹ â†’ ä¸Šæ›¸ã
                it->motionName = selectedMotion;
                it->emitPosition = emitPosition;
                it->emitCount = emitCount;
                it->isLooping = true;
            } 
            else
            {
                // æ–°è¦è¿½åŠ 
                EmitSetting newSetting;
                newSetting.groupName = selectedGroup;
                newSetting.motionName = selectedMotion;
                newSetting.emitPosition = emitPosition;
                newSetting.emitCount = emitCount;
                newSetting.isLooping = true;
                emitSettings_.push_back(newSetting);
            }
        }
        else 
        {
            if (ImGui::Button("Stop Emit") && selectedGroupIndex < groupNames.size()) 
            {
                const std::string& selectedGroup = groupNames[selectedGroupIndex];

                // è©²å½“ã‚°ãƒ«ãƒ¼ãƒ—ã ã‘åœæ­¢
                for (auto& setting : emitSettings_)
                {
                    if (setting.groupName == selectedGroup)
                    {
                        setting.isLooping = false;
                    }
                }
            }
        }

        
    }

    ImGui::End();

#endif // USE_IMGUI

}


============================================================
File Path: project/gameEngine/particle/ParticleManager.h
============================================================
#pragma once

#include <unordered_map>
#include <random> 
#include <TextureManager.h>
#include <Object3d.h>
#include <numbers>
#include <MyMath.h>
#include <DirectXCommon.h>
#include <SrvManager.h>
#include <Camera.h>

#include "Particle.h"
#include "ParticleMotion.h"
#include "MeshBuilder.h"
#include "ModelCommon.h"

class Object3dCommon;

// æ§‹é€ ä½“(Emitterã§ã‚‚ä½¿ã„ãŸã„)
// ãƒžãƒ†ãƒªã‚¢ãƒ«ãƒ‡ãƒ¼ã‚¿
struct MaterialData
{
	std::string textureFilePath;
	uint32_t textureIndex = 0;
};
// GPUç”¨ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«æ§‹é€ ä½“
struct ParticleForGPU
{
	Matrix4x4 WVP;
	Matrix4x4 world;
	Vector4 color;
};

// ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã‚°ãƒ«ãƒ¼ãƒ—æ§‹é€ ä½“
struct ParticleGroup
{
	MaterialData materialData;
	std::list<Particle> particleList;
	uint32_t srvIndex;
	Microsoft::WRL::ComPtr<ID3D12Resource> instancingResource;
	uint32_t instanceCount = 0;
	ParticleForGPU* instancingData;
	std::string motionName = "Homing";
};
// ã‚¨ãƒŸãƒƒãƒˆè¨­å®šæ§‹é€ ä½“
struct EmitSetting {
	std::string groupName;
	std::string motionName;
	Vector3 emitPosition;
	uint32_t emitCount = 1;
	float timer = 0.0f;
	bool isLooping = false;
};

/// <summary>
/// ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ç®¡ç†ã‚¯ãƒ©ã‚¹
/// </summary>
class ParticleManager
{
public:

	// ã‚·ãƒ³ã‚°ãƒ«ãƒˆãƒ³ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã®å–å¾—
	static ParticleManager* GetInstance();

	/// <summary>
	/// åˆæœŸåŒ–
	/// </summary>
	/// <param name="dxCommon">DirectXå…±é€šæ©Ÿèƒ½</param>
	/// <param name="srvManager">SrvManagerã®ãƒã‚¤ãƒ³ã‚¿</param>
	/// <param name="modelCommon">ModelCommonã®ãƒã‚¤ãƒ³ã‚¿</param>
	void Initialize(DirectXCommon* dxCommon, SrvManager* srvManager, ModelCommon* modelCommon);

	/// <summary>
	/// çµ‚äº†
	/// </summary>
	void Finalize();

	/// <summary>
	/// ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³ç”Ÿæˆ
	/// </summary>
	void CreatePipeline();

	/// <summary>
	/// ãƒ«ãƒ¼ãƒˆã‚·ã‚°ãƒãƒãƒ£ç”Ÿæˆ
	/// </summary>
	void CreateRootSignature();

	/// <summary>
	/// ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã‚°ãƒ«ãƒ¼ãƒ—ã®ç”Ÿæˆ
	/// </summary>
	/// <param name="name">ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã‚°ãƒ«ãƒ¼ãƒ—ã®åå‰</param>
	/// <param name="textureFilePath">ãƒ†ã‚¯ã‚¹ãƒãƒ£ãƒ•ã‚¡ã‚¤ãƒ«ã®ãƒ‘ã‚¹</param>
	/// <param name="modelFilePath">ãƒ¢ãƒ‡ãƒ«ãƒ•ã‚¡ã‚¤ãƒ«ã®ãƒ‘ã‚¹</param>
	/// <param name="type">ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã®ã‚¿ã‚¤ãƒ—("Default", "Ring", "Cylinder", "Slash"ãªã©)</param>
	/// <param name="motionName">å‹•ãã®åå‰</param>
	void CreateParticleGroup(const std::string& name, const std::string& textureFilePath, const std::string& modelFilePath, const std::string& type = "Default", const std::string& motionName = "Homing");

	/// <summary>
	/// æ›´æ–°
	/// </summary>
	void Update();

	/// <summary>
	/// æç”»
	/// </summary>
	void Draw();

	/// <summary>
	/// ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã®ç™ºç”Ÿ
	/// </summary>
	/// <param name="groupName">ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã‚°ãƒ«ãƒ¼ãƒ—ã®åå‰</param>
	/// <param name="position">ç™ºç”Ÿä½ç½®</param>
	/// <param name="count">ç™ºç”Ÿæ•°</param>
	void Emit(const std::string groupName, const Vector3& position, uint32_t count);

	/// <summary>
	/// ã‚¨ãƒŸãƒƒã‚¿ãƒ¼è¨­å®šã®è¿½åŠ 
	/// </summary>
	/// <param name="setting">ã‚¨ãƒŸãƒƒã‚¿ãƒ¼è¨­å®š</param>
	void AddEmitterSetting(const EmitSetting& setting);

	/// <summary>
	/// ãƒ‡ãƒãƒƒã‚°UI
	/// </summary>
	void DebugUI();

public: // ã‚»ãƒƒã‚¿ãƒ¼

	/// <summary>
	/// ã‚«ãƒ¡ãƒ©ã®ã‚»ãƒƒãƒˆ
	/// </summary>
	/// <param name="camera">ã‚«ãƒ¡ãƒ©</param>
	void SetCamera(std::shared_ptr<Camera> camera) { camera_ = camera; }

private: // æ§‹é€ ä½“

	struct TransformData
	{
		Vector3 scale;
		Vector3 rotate;
		Vector3 translate;
	};

	struct VertexData
	{
		Vector4 position;
		Vector2 texcoord;
		Vector3 normal;
	};

	struct ModelData
	{
		std::vector<VertexData> vertices;
		MaterialData material;
	};

	struct Material
	{
		Vector4 color;
		int32_t enableLighting;
		float padding[3];
		Matrix4x4 uvTransform;
	};

	struct AABB
	{
		Vector3 min;//!<æœ€å°ç‚¹
		Vector3 max;//!< æœ€å¤§ç‚¹
	};

	struct AccelerationField
	{
		Vector3 acceleration; //!< åŠ é€Ÿåº¦
		AABB area;            //!< ç¯„å›²
	};

	// é ‚ç‚¹ãƒ‡ãƒ¼ã‚¿ã®åˆæœŸåŒ–ï¼ˆåº§æ¨™ãªã©ï¼‰
	struct Vertex 
	{
		float position[3];
		float color[4];
	};

private:

	ParticleManager() = default;  // ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ã¯ãƒ—ãƒ©ã‚¤ãƒ™ãƒ¼ãƒˆ

	DirectXCommon* dxCommon_ = nullptr;

	SrvManager* srvManager_ = nullptr;

	Object3dCommon* object3dCommon_ = nullptr;

	std::shared_ptr<Camera> camera_ = nullptr;

	// é ‚ç‚¹ãƒãƒƒãƒ•ã‚¡é–¢é€£
	Microsoft::WRL::ComPtr<ID3D12Resource> vertexBuffer_;
	D3D12_VERTEX_BUFFER_VIEW vertexBufferView_;

	// ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³é–¢é€£
	Microsoft::WRL::ComPtr<ID3D12RootSignature> rootSignature_;
	Microsoft::WRL::ComPtr<ID3D12PipelineState> pipelineState_;

	// ä¹±æ•°ç”Ÿæˆ
	std::mt19937 randomEngine_;

	//ãƒ‡ã‚£ã‚¹ã‚¯ãƒªãƒ—ã‚¿ãƒ¬ãƒ³ã‚¸ã®ç”Ÿæˆ
	D3D12_DESCRIPTOR_RANGE descriptorRange_[1]{};
	//DepthStencilStateã®è¨­å®š
	D3D12_DEPTH_STENCIL_DESC depthStencilDesc_{};
	//InputLayout
	D3D12_INPUT_LAYOUT_DESC inputLayoutDesc_{};
	//BlendStateã®è¨­å®š
	D3D12_BLEND_DESC blendDesc_{};
	//RasterizerStateã®è¨­å®š 
	D3D12_RASTERIZER_DESC rasterizerDesc_{};

	//shaderã‚’ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ã™ã‚‹
	Microsoft::WRL::ComPtr<IDxcBlob> vertexShaderBlob_ = nullptr;
	Microsoft::WRL::ComPtr<IDxcBlob> pixelShaderBlob_ = nullptr;

	D3D12_ROOT_SIGNATURE_DESC descriptionRootSignature_{};
	D3D12_ROOT_PARAMETER rootParameters_[4] = {};
	D3D12_STATIC_SAMPLER_DESC staticSamplers_[1] = {};
	D3D12_INPUT_ELEMENT_DESC inputElementDescs_[3] = {};

	std::unordered_map<std::string, ParticleGroup> particleGroups;


	AccelerationField accelerationField_;

	TransformData transform_;
	Matrix4x4 backToFrontMatrix_;
	//modelãƒžãƒ†ãƒªã‚¢ã‚‹ç”¨ã®ãƒªã‚½ãƒ¼ã‚¹ã‚’ä½œã‚‹ã€‚ä»Šå›žcolor1ã¤åˆ†ã®ã‚µã‚¤ã‚ºã‚’ç”¨æ„ã™ã‚‹
	Microsoft::WRL::ComPtr<ID3D12Resource> materialResource_;
	//ãƒžãƒ†ãƒªã‚¢ãƒ«ã«ãƒ‡ãƒ¼ã‚¿ã‚’æ›¸ãè¾¼ã‚€	
	Material* materialData_ = nullptr; 
	std::unordered_map<std::string, std::unique_ptr<Model>> models_;
	ModelCommon* modelCommon_ = nullptr;


	// ãƒ¢ãƒ‡ãƒ«ã®ãƒ“ãƒ¥ãƒ¼ã‚’ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã™ã‚‹ç”¨
	D3D12_INDEX_BUFFER_VIEW indexBufferView_;

	// Cylinderã®å‘ã
	std::string direction_ = "UP";

	std::vector<EmitSetting> emitSettings_;

};

============================================================
File Path: project/gameEngine/particle/ParticleMotion.cpp
============================================================
#include "ParticleMotion.h"

#include <numbers>
#include <cmath>

// ç™»éŒ²ç”¨ã®ãƒžãƒƒãƒ—
std::unordered_map<std::string, ParticleMotion::MotionFunc> ParticleMotion::motions_;
std::string ParticleMotion::direction_;

void ParticleMotion::Register(const std::string& name, MotionFunc func)
{
	motions_[name] = func;
}

Particle ParticleMotion::Create(const std::string& name, std::mt19937& rand, const Vector3& pos)
{
    auto it = motions_.find(name);
    if (it != motions_.end()) 
    {
        return it->second(rand, pos);
    }

    // ç„¡åŠ¹ãªåå‰ â†’ ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆç²’å­
    Particle p;
    p.transform.translate = pos;
    p.transform.scale = { 1, 1, 1 };
    p.color = { 1, 0, 0, 1 }; // èµ¤ã„è­¦å‘Šç²’å­
    p.lifeTime = 1.0f;
    return p;
}

void ParticleMotion::Initialize()
{
	// ãƒ¢ãƒ¼ã‚·ãƒ§ãƒ³ã®ç™»éŒ²
	Register("Homing", MakeHoming);
	Register("Orbit", MakeOrbit);
	Register("Explosion", MakeExplosion);
	Register("Rupture", MakeRupture);
	Register("Fountain", MakeFountain);
	Register("Wiggle", MakeWiggle);
    Register("Cylinder", MakeCylinder);
    Register("Slash", MakeSlash);
	Register("Flame", MakeFlame);
	Register("Magic1", MakeMagic1);
	Register("Magic2", MakeMagic2);
	Register("Laser", MakeLaser);
	Register("Petal", MakePetal);
	Register("Water", MakeWater);
	Register("Bubble", MakeBubble);
	Register("Dust", MakeDust);
	Register("EnemyDust", MakeEnemyDust);
	Register("Debuff", MakeDebuff);
	Register("Spark", MakeSpark);
    Register("SparkBurst", MakeSparkBurst);
	Register("HitReaction", MakeHitReaction);
	Register("BltReaction", MakeBulletHitReaction);
}

const std::unordered_map<std::string, ParticleMotion::MotionFunc>& ParticleMotion::GetAll()
{
    return motions_;
}

Particle ParticleMotion::MakeHoming(std::mt19937& rand, const Vector3& target)
{
    std::uniform_real_distribution<float> dist(-1.0f, 1.0f);
    Particle particle;
    particle.transform.translate = target + Vector3(dist(rand), dist(rand), dist(rand));
    particle.transform.scale = { 0.5f, 0.5f, 0.5f };
    particle.velocity = Normalize(target - particle.transform.translate) * 0.5f;
    particle.lifeTime = 2.0f;
    particle.currentTime = 0.0f;
    particle.color = { 0.4f, 0.8f, 1.0f, 1.0f }; // é’ç™½ã„
    return particle;

}

Particle ParticleMotion::MakeOrbit(std::mt19937& rand, const Vector3& target)
{
    std::uniform_real_distribution<float> distAngle(0.0f, 2.0f * std::numbers::pi_v<float>);
    float angle = distAngle(rand);
    float radius = 2.0f; // åŠå¾„ã‚’æ‹¡å¤§ã—ã¦è»Œé“ã‚’æ˜Žç¢ºã«

    // åˆæœŸä½ç½®ã¯å††å‘¨ä¸Š
    Vector3 offset = Vector3(std::cos(angle) * radius, 0.0f, std::sin(angle) * radius);
    Vector3 tangent = Vector3(-std::sin(angle), 0.0f, std::cos(angle)); // æŽ¥ç·šæ–¹å‘

    Particle particle;
    particle.transform.translate = target + offset;
    particle.transform.scale = { 1.0f, 1.0f, 1.0f }; // ã‚¹ã‚±ãƒ¼ãƒ«ã‚’è¨­å®š
    particle.velocity = tangent * 0.1f; // å††é‹å‹•ã™ã‚‹ã‚ˆã†ã«åˆæœŸé€Ÿåº¦ã‚’è¨­å®š
    particle.lifeTime = 3.0f;
    particle.currentTime = 0.0f;
    return particle;
}

Particle ParticleMotion::MakeExplosion(std::mt19937& rand, const Vector3& center)
{
    std::uniform_real_distribution<float> dist(-1.0f, 1.0f);
    Particle particle;
    particle.transform.translate = { center.x,center.y + 1.0f,center.z };
    particle.transform.scale = { 1.0f, 1.0f, 1.0f };
    particle.velocity = Normalize(Vector3(dist(rand), dist(rand), dist(rand)));
    particle.lifeTime = 1.0f;
    particle.currentTime = 0.0f;
    particle.color = { 1.0f, 0.5f, 0.0f, 1.0f }; // ã‚ªãƒ¬ãƒ³ã‚¸è‰²ï¼ˆç‚Žï¼‰
    return particle;
}

Particle ParticleMotion::MakeRupture(std::mt19937& rand, const Vector3& center)
{
    std::uniform_real_distribution<float> dist(-15.0f, 15.0f);
	std::uniform_real_distribution<float> distRot(-3.0f, 3.0f);

    Particle particle;
    particle.transform.translate = { center.x,center.y + 1.0f,center.z };
    particle.transform.scale = { 1.0f, 1.0f, 1.0f };
    particle.velocity = Vector3(dist(rand), dist(rand), dist(rand));
	particle.angularVelocity = Vector3(distRot(rand), distRot(rand), distRot(rand));
    particle.lifeTime = 1.0f;
    particle.currentTime = 0.0f;
    particle.color = { 1.0f, 0.0f, 0.0f, 1.0f };
    return particle;
}

Particle ParticleMotion::MakeFountain(std::mt19937& rand, const Vector3& base)
{
    std::uniform_real_distribution<float> distXZ(-40.0f, 40.0f);
	std::uniform_real_distribution<float> distRot(-1.0f, 1.0f);
	std::uniform_real_distribution<float> distColor(0.1f, 0.7f);
    Particle particle;
    particle.transform.translate = base + Vector3(distXZ(rand), 0.0f, distXZ(rand));
    particle.transform.translate.y += base.y - 0.5f;
	particle.transform.rotate = Vector3(distRot(rand), distRot(rand), distRot(rand));
    particle.transform.scale = { 0.5f, 0.5f, 0.5f }; // ã‚¹ã‚±ãƒ¼ãƒ«ã‚’è¨­å®š
    particle.velocity = Vector3(0.0f, 1.5f, 0.0f);
	particle.scaleVelocity = Vector3(-0.15f, -0.15f, -0.15f);
	particle.angularVelocity = Vector3(distRot(rand), distRot(rand), distRot(rand));
    particle.lifeTime = 1.5f;
    particle.currentTime = 0.0f;
	particle.color = { distColor(rand), distColor(rand), 1.0f, 0.7f }; // é’è‰²ç³»
    return particle;
}

Particle ParticleMotion::MakeWiggle(std::mt19937& rand, const Vector3& origin)
{
    std::uniform_real_distribution<float> dist(-0.4f, 0.4f);
    Particle particle;
    particle.transform.translate = origin + Vector3(dist(rand), 0.0f, dist(rand));
    particle.transform.scale = { 1.0f, 1.0f, 1.0f }; // ã‚¹ã‚±ãƒ¼ãƒ«ã‚’è¨­å®š
    particle.velocity = Vector3(dist(rand), dist(rand), dist(rand));
    particle.lifeTime = 2.0f;
    particle.currentTime = 0.0f;
	particle.color = { 0.0f, 0.0f, 0.3f, 1.0f };
    return particle;
}

Particle ParticleMotion::MakeCylinder(std::mt19937& rand, const Vector3& position)
{
    rand;

    Particle p;
    p.transform.scale = { 1.0f, 1.0f, 1.0f };
    p.transform.translate = position;
    p.transform.scale = { 1.0f, 1.0f, 1.0f }; // ã‚¹ã‚±ãƒ¼ãƒ«ã‚’è¨­å®š
    p.velocity = { 0, 0, 0 };
    p.color = { 0.0f, 0.0f, 0.5f, 1.0f };
    p.lifeTime = 3.0f;
    p.currentTime = 0.0f;

    if (direction_ == "UP")
    {
        p.transform.rotate = { 0.0f, 0.0f, 3.14f };
        p.transform.translate.y += p.transform.scale.y * 2.0f;
    }
    else if (direction_ == "DOWN") 
    {
        p.transform.rotate = { 0.0f, 0.0f, 0.0f };
    }
    else if (direction_ == "LEFT") 
    {
        p.transform.rotate = { 0.0f, 0.0f, 1.57f };
    }
    else if (direction_ == "RIGHT") 
    {
        p.transform.rotate = { 0.0f, 0.0f, -1.57f };
    }

    return p;
}

Particle ParticleMotion::MakeSlash(std::mt19937& rand, const Vector3& translate)
{
    rand;
    std::uniform_real_distribution<float> scaleDist(0.5f, 1.5f);
    std::uniform_real_distribution<float> rotateDist(-std::numbers::pi_v<float>, std::numbers::pi_v<float>);

    Particle p;
    p.transform.scale = {/* 0.1f, scaleDist(rand)*/1.0f,1.0f, 1.0f };
    p.transform.rotate = { 0.0f, 0.0f, 0.0f/*rotateDist(rand)*/ };
    p.transform.translate = translate;
    p.velocity = { 0, 0, 0 };
    p.color = { 1.0f, 1.0f, 1.0f, 1.0f };
    p.lifeTime = 1.0f;
    p.currentTime = 0.0f;

    return p;
}

Particle ParticleMotion::MakeFlame(std::mt19937& rand, const Vector3& base)
{
    std::uniform_real_distribution<float> distXY(-0.2f, 0.2f);
    std::uniform_real_distribution<float> distScale(0.5f, 1.5f);
    std::uniform_real_distribution<float> distVelY(0.05f, 0.15f);
    std::uniform_real_distribution<float> distLife(0.8f, 1.5f);
    std::uniform_real_distribution<float> distColor(0.8f, 1.0f);

    Particle p;
    p.transform.translate = base + Vector3(distXY(rand), 0.0f, distXY(rand));
    p.transform.scale = Vector3(0.3f, distScale(rand), 0.3f);
    p.velocity = Vector3(distXY(rand), distVelY(rand), distXY(rand));
    p.color = Vector4(distColor(rand), distColor(rand) * 0.5f, 0.0f, 1.0f); // èµ¤ã€œã‚ªãƒ¬ãƒ³ã‚¸
    p.lifeTime = distLife(rand);
    p.currentTime = 0.0f;
    return p;
}

Particle ParticleMotion::MakeMagic1(std::mt19937& rand, const Vector3& translate)
{
    rand;
    Particle p;
    p.transform.translate = translate;
    p.transform.rotate = { 0.0f, 0.0f, 3.14f };
    p.transform.translate.y += p.transform.scale.y * 2.0f;
    p.transform.scale = { 1.0f, 1.0f, 1.0f };
    p.velocity = { 0.0f, 0.0f, 0.0f };
	p.angularVelocity = { 0.0f, 1.0f, 0.0f };
    p.color = { 0.6f, 0.3f, 1.0f, 1.0f };
    p.lifeTime = 100000.0f;
    p.currentTime = 0.0f;
    return p;
}

Particle ParticleMotion::MakeMagic2(std::mt19937& rand, const Vector3& translate)
{
    std::uniform_real_distribution<float> distXZ(-0.9f, 0.9f);
    std::uniform_real_distribution<float> distRot(-std::numbers::pi_v<float>, std::numbers::pi_v<float>);
    std::uniform_real_distribution<float> distScale(0.1f, 0.3f);

    Particle p;

    p.transform.translate = { distXZ(rand), translate.y, distXZ(rand) };

    p.transform.scale = { distScale(rand), distScale(rand), distScale(rand) };
    p.transform.rotate = { distRot(rand), distRot(rand), distRot(rand) }; // ãƒ‘ãƒ©ãƒ‘ãƒ©æ„Ÿ
    p.velocity = { 0.0f, 0.3f, 0.0f }; // å°‘ã—ãšã¤ä¸Šæ˜‡
    p.angularVelocity = { 0.0f, 3.0f, 0.0f }; // Yè»¸å›žè»¢
    p.scaleVelocity = { -0.01f, -0.01f, -0.01f };
    p.color = { 0.6f, 0.3f, 1.0f, 1.0f };
    p.lifeTime = 2.5f;
    p.currentTime = 0.0f;

    return p;
}

Particle ParticleMotion::MakeLaser(std::mt19937& rand, const Vector3& translate)
{
    std::uniform_real_distribution<float> distWiggle(-0.05f, 0.05f);
    std::uniform_real_distribution<float> distLen(2.0f, 4.0f);

    Particle p;
    p.transform.translate = translate;
    p.transform.scale = { 0.8f, 0.0f, 0.8f };
    p.transform.rotate = { -1.5f, 0.0f, 0.0f };
    p.velocity = { distWiggle(rand), 0.0f, distWiggle(rand) };
	p.scaleVelocity = { -0.5f, 10.0f, -0.5f };
    p.color = { 1.0f, 0.1f, 0.1f, 1.0f };
    p.lifeTime = 0.8f;
    p.currentTime = 0.0f;
    return p;
}

Particle ParticleMotion::MakePetal(std::mt19937& rand, const Vector3& translate)
{
    // XZ: -5ï½ž5, Y: 5
    std::uniform_real_distribution<float> distXZ(-5.0f, 5.0f);
    std::uniform_real_distribution<float> distRot(-std::numbers::pi_v<float>, std::numbers::pi_v<float>);
    std::uniform_real_distribution<float> distScale(0.2f, 0.5f);
    std::uniform_real_distribution<float> distColorR(0.8f, 1.0f); // ãƒ”ãƒ³ã‚¯ç³»
    std::uniform_real_distribution<float> distColorG(0.4f, 0.7f);
    std::uniform_real_distribution<float> distColorB(0.7f, 0.9f);
    std::uniform_real_distribution<float> distAngVel(-1.0f, 1.0f);
    std::uniform_real_distribution<float> distWiggle(-0.05f, 0.05f);

    Particle p;
    p.transform.translate = Vector3(translate.x + distXZ(rand), translate.y, translate.z + distXZ(rand));
    p.transform.scale = { distScale(rand), distScale(rand), distScale(rand) };
    p.transform.rotate = { distRot(rand), distRot(rand), distRot(rand) };
    // ã²ã‚‰ã²ã‚‰æ„Ÿ: XZã«å¾®å°ãªæºã‚Œã€Yã¯ã‚†ã£ãã‚Šè½ä¸‹
    p.velocity = { distWiggle(rand), -0.35f, distWiggle(rand) };
    // å›žè»¢ã—ãªãŒã‚‰è½ã¡ã‚‹
    p.angularVelocity = { distAngVel(rand), distAngVel(rand), distAngVel(rand) };
    // èŠ±ã³ã‚‰ã‚‰ã—ã„è‰²
    p.color = { distColorR(rand), distColorG(rand), distColorB(rand), 1.0f };
    p.lifeTime = 8.0f;
    p.currentTime = 0.0f;
    return p;
}

Particle ParticleMotion::MakeWater(std::mt19937& rand, const Vector3& translate)
{
    // XZæ–¹å‘ãƒ©ãƒ³ãƒ€ãƒ ã€Yã¯ä¸Šå‘ã
    std::uniform_real_distribution<float> distXZ(-0.5f, 0.5f);
    std::uniform_real_distribution<float> distVelY(0.7f, 1.2f);
    std::uniform_real_distribution<float> distScale(0.15f, 0.25f);

    Particle p;
    p.transform.translate = translate;
    p.transform.scale = { distScale(rand), distScale(rand), distScale(rand) };
    p.transform.rotate = { 0.0f, 0.0f, 0.0f };
    // åˆé€Ÿï¼šXZãƒ©ãƒ³ãƒ€ãƒ ã€Yä¸Šå‘ã
    p.velocity = { distXZ(rand), distVelY(rand), distXZ(rand) };
    p.angularVelocity = { 0.0f, 0.0f, 0.0f };
    p.color = { 0.3f, 0.5f, 1.0f, 1.0f }; // æ°´è‰²
    p.lifeTime = 1.2f;
    p.currentTime = 0.0f;
    return p;
}

Particle ParticleMotion::MakeBubble(std::mt19937& rand, const Vector3& translate)
{
    // XZ: -1.0ï½ž1.0ã®ç¯„å›²ã§ãƒ©ãƒ³ãƒ€ãƒ ã«å‡ºç¾
    std::uniform_real_distribution<float> distXZ(-1.0f, 1.0f);
    std::uniform_real_distribution<float> distScale(0.08f, 0.15f);
    std::uniform_real_distribution<float> distVelY(0.15f, 0.25f);
    std::uniform_real_distribution<float> distColor(0.7f, 1.0f);

    Particle p;
    p.transform.translate = translate + Vector3(distXZ(rand), 0.0f, distXZ(rand));
    p.transform.scale = { distScale(rand), distScale(rand), distScale(rand) };
    p.transform.rotate = { 0.0f, 0.0f, 0.0f };
    // æ³¡ã‚‰ã—ãä¸Šæ˜‡
    p.velocity = { 0.0f, distVelY(rand), 0.0f };
    p.angularVelocity = { 0.0f, 0.0f, 0.0f };
    p.color = { distColor(rand), distColor(rand), 1.0f, 0.7f }; // é€æ˜Žæ„Ÿã®ã‚ã‚‹é’
    p.lifeTime = 2.0f;
    p.currentTime = 0.0f;
    return p;
}

Particle ParticleMotion::MakeDust(std::mt19937& rand, const Vector3& translate)
{
    // XZæ–¹å‘ã«åºƒãŒã‚‹ãƒ»Yã¯å°‘ã—ä¸Šå‘ã
    std::uniform_real_distribution<float> distXZ(-0.6f, 0.6f);
    std::uniform_real_distribution<float> distVelY(0.08f, 0.15f);
    std::uniform_real_distribution<float> distScale(0.08f, 0.15f);


    Particle p;
    // è¶³å…ƒã‹ã‚‰å°‘ã—ä¸‹ã’ã¦ç™ºç”Ÿ
    p.transform.translate = translate + Vector3(distXZ(rand), 0.0f, distXZ(rand));
    p.transform.scale = { distScale(rand), distScale(rand), distScale(rand) };
    p.transform.rotate = { 0.0f, 0.0f, 0.0f };
    // XZæ–¹å‘ã«åºƒãŒã‚Šã€Yã¯å°‘ã—ä¸Šå‘ã
    p.velocity = { distXZ(rand), distVelY(rand), distXZ(rand) };
    // å¾ã€…ã«å¤§ãããªã‚‹
    p.scaleVelocity = { 0.01f, 0.01f, 0.01f };
    // ç°è‰²ãƒ»ã‚„ã‚„é€æ˜Ž
    p.color = { 0.6f, 0.6f, 0.6f, 0.7f };
    p.lifeTime = 0.8f;
    p.currentTime = 0.0f;
    return p;
}

Particle ParticleMotion::MakeEnemyDust(std::mt19937& rand, const Vector3& translate)
{
    // XZæ–¹å‘ã«åºƒãŒã‚‹ãƒ»Yã¯å°‘ã—ä¸Šå‘ã
    std::uniform_real_distribution<float> distXZ(-0.6f, 0.6f);
    std::uniform_real_distribution<float> distVelY(0.08f, 0.15f);
    std::uniform_real_distribution<float> distScale(0.08f, 0.15f);

    Particle p;
    // è¶³å…ƒã‹ã‚‰å°‘ã—ä¸‹ã’ã¦ç™ºç”Ÿ
    p.transform.translate = translate + Vector3(distXZ(rand), 0.0f, distXZ(rand));
    p.transform.scale = { distScale(rand), distScale(rand), distScale(rand) };
    p.transform.rotate = { 0.0f, 0.0f, 0.0f };
    // XZæ–¹å‘ã«åºƒãŒã‚Šã€Yã¯å°‘ã—ä¸Šå‘ã
    p.velocity = { distXZ(rand), distVelY(rand), distXZ(rand) };
    // å¾ã€…ã«å¤§ãããªã‚‹
    p.scaleVelocity = { 0.01f, 0.01f, 0.01f };
    // é’è‰²ãƒ»ã‚„ã‚„é€æ˜Ž
    p.color = { 0.0f, 0.0f, 1.0f, 0.9f };
    p.lifeTime = 0.8f;
    p.currentTime = 0.0f;
    return p;
}

Particle ParticleMotion::MakeDebuff(std::mt19937& rand, const Vector3& translate)
{
    std::uniform_real_distribution<float> distAngle(0.0f, 2.0f * std::numbers::pi_v<float>);
    std::uniform_real_distribution<float> distRadius(0.0f, 1.3f);
    float angle = distAngle(rand);
    float radius = distRadius(rand);
    float offsetX = std::cos(angle) * radius;
    float offsetZ = std::sin(angle) * radius;

    // Yåº§æ¨™ã¯translate.yãã®ã¾ã¾
    Vector3 pos = translate + Vector3(offsetX, 1.0f, offsetZ);

    Particle p;
    p.transform.translate = pos;
    p.transform.scale = { 1.0f, 1.0f, 1.0f };
    p.transform.rotate = { 0.0f, 0.0f, 0.0f };
    // å¾ã€…ã«ä¸‹ãŒã‚‹ï¼ˆYæ–¹å‘ã«è² ã®é€Ÿåº¦ï¼‰
    std::uniform_real_distribution<float> distVelY(-0.03f, -0.01f);
    p.velocity = { 0.0f, distVelY(rand), 0.0f };
    // å¾ã€…ã«å¤§ãããªã‚‹
    p.scaleVelocity = { 0.01f, 0.01f, 0.01f };
    // è‰²ã¯ç°è‰²ãƒ»ã‚„ã‚„é€æ˜Ž
    p.color = { 0.6f, 0.6f, 0.6f, 0.7f };
    p.lifeTime = 1.0f;
    p.currentTime = 0.0f;
    return p;
}

Particle ParticleMotion::MakeSpark(std::mt19937& rand, const Vector3& translate)
{
    // çƒé¢ä¸Šã®ãƒ©ãƒ³ãƒ€ãƒ ãªæ–¹å‘
    std::uniform_real_distribution<float> distTheta(0.0f, 2.0f * std::numbers::pi_v<float>);
    std::uniform_real_distribution<float> distPhi(0.0f, std::numbers::pi_v<float>);
    float theta = distTheta(rand);
    float phi = distPhi(rand);

    // ãƒãƒªã‚¢åŠå¾„ï¼ˆ1.5fï¼‰
    float radius = 1.5f;
    float x = std::sin(phi) * std::cos(theta);
    float y = std::cos(phi);
    float z = std::sin(phi) * std::sin(theta);
    Vector3 normal = { x, y, z };

    // ç™ºç”Ÿä½ç½®ï¼šãƒãƒªã‚¢è¡¨é¢
    Vector3 pos = translate + normal * radius;

    // è‰²ï¼šç™½ãƒ»é»„è‰²ãƒ»é’é›»è‰²ã‹ã‚‰ãƒ©ãƒ³ãƒ€ãƒ 
    std::uniform_int_distribution<int> distColor(0, 1);
    int colorType = distColor(rand);
    Vector4 color;
    if (colorType == 0)
    {
        color = { 1.0f, 1.0f, 0.2f, 1.0f };   // é»„è‰²
    }
    else
    {
        color = { 0.6f, 1.0f, 0.2f, 1.0f };   // é»„ç·‘
    }

    // å›žè»¢ã‚‚ãƒ©ãƒ³ãƒ€ãƒ 
    std::uniform_real_distribution<float> distRot(0.0f, 2.0f * std::numbers::pi_v<float>);
    float rotX = distRot(rand);
    float rotY = distRot(rand);
    float rotZ = distRot(rand);

    Particle p;
    p.transform.translate = pos;
    p.transform.scale = { 0.8f, 0.8f, 0.8f };
    p.transform.rotate = { rotX, rotY, rotZ };
    // å¤–å‘ãã«é€Ÿãé£›ã°ã™
    std::uniform_real_distribution<float> distSpeed(0.15f, 0.35f);
    p.velocity = normal * distSpeed(rand);
    // å°‘ã—ã ã‘æ‹¡å¤§
    p.scaleVelocity = { 0.02f, 0.02f, 0.02f };
    // è‰²
    p.color = color;
    // çŸ­å‘½ï¼ˆ0.15ï½ž0.25ç§’ï¼‰
    std::uniform_real_distribution<float> distLife(0.15f, 0.25f);
    p.lifeTime = distLife(rand);
    p.currentTime = 0.0f;
    return p;
}

Particle ParticleMotion::MakeSparkBurst(std::mt19937& rand, const Vector3& translate)
{
    // çƒé¢ä¸Šã®ãƒ©ãƒ³ãƒ€ãƒ ãªæ–¹å‘
    std::uniform_real_distribution<float> distTheta(0.0f, 2.0f * std::numbers::pi_v<float>);
    std::uniform_real_distribution<float> distPhi(0.0f, std::numbers::pi_v<float>);
    float theta = distTheta(rand);
    float phi = distPhi(rand);

    // ãƒãƒªã‚¢åŠå¾„ï¼ˆ1.5fï¼‰
    float radius = 1.5f;
    float x = std::sin(phi) * std::cos(theta);
    float y = std::cos(phi);
    float z = std::sin(phi) * std::sin(theta);
    Vector3 normal = { x, y, z };

    // ç™ºç”Ÿä½ç½®ï¼šãƒãƒªã‚¢è¡¨é¢
    Vector3 pos = translate + normal * radius;

    // ã‚¹ã‚±ãƒ¼ãƒ«
    std::uniform_real_distribution<float> distScale(0.35f, 0.85f);
    float scale = distScale(rand);

    // è‰²ï¼šé»„è‰²ãƒ»é»„ç·‘ãƒ»ç™½ã‹ã‚‰ãƒ©ãƒ³ãƒ€ãƒ 
    std::uniform_int_distribution<int> distColor(0, 2);
    int colorType = distColor(rand);
    Vector4 color;
    if (colorType == 0)
        color = { 1.0f, 1.0f, 0.2f, 1.0f };   // é»„è‰²
    else if (colorType == 1)
        color = { 0.6f, 1.0f, 0.2f, 1.0f };   // é»„ç·‘
    else
        color = { 1.0f, 1.0f, 1.0f, 1.0f };   // ç™½

    // å›žè»¢ã‚‚ãƒ©ãƒ³ãƒ€ãƒ 
    std::uniform_real_distribution<float> distRot(0.0f, 2.0f * std::numbers::pi_v<float>);
    float rotX = distRot(rand);
    float rotY = distRot(rand);
    float rotZ = distRot(rand);

    Particle p;
    p.transform.translate = pos;
    p.transform.scale = { scale, scale, scale };
    p.transform.rotate = { rotX, rotY, rotZ };
    // é€Ÿãé£›ã³æ•£ã‚‹
    std::uniform_real_distribution<float> distSpeed(0.5f, 0.8f);
    p.velocity = normal * distSpeed(rand);
    // å¾ã€…ã«æ¶ˆãˆã‚‹
    p.scaleVelocity = { -0.01f, -0.01f, -0.01f };
    p.color = color;
    std::uniform_real_distribution<float> distLife(0.5f, 0.8f);
    p.lifeTime = distLife(rand);
    p.currentTime = 0.0f;
    return p;
}

Particle ParticleMotion::MakeHitReaction(std::mt19937& rand, const Vector3& translate)
{
    std::uniform_real_distribution<float> distAngle(0.0f, 2.0f * std::numbers::pi_v<float>);
    std::uniform_real_distribution<float> distSpeed(3.0f, 5.0f);      // åˆé€Ÿã‚’å¤§å¹…ã«å¢—åŠ 
    std::uniform_real_distribution<float> distY(-0.1f, 0.25f);       // ä¸Šä¸‹æˆåˆ†ã®ãƒ–ãƒ¬
    std::uniform_real_distribution<float> distUp(0.15f, 0.45f);      // ç™ºç”Ÿä½ç½®ã‚’å°‘ã—ä¸Šã’ã‚‹é‡
    std::uniform_real_distribution<float> distScale(0.3f, 0.5f);     // åˆæœŸã‚¹ã‚±ãƒ¼ãƒ«
    std::uniform_real_distribution<float> distScaleVel(-0.25f, -0.08f); // å¾ã€…ã«å°ã•ãã™ã‚‹é€Ÿåº¦
    std::uniform_real_distribution<float> distRot(-3.14f, 3.14f);    // åˆæœŸå›žè»¢
    std::uniform_real_distribution<float> distAngVel(-10.0f, 10.0f); // å›žè»¢é€Ÿåº¦ã‚’å¼·ã‚ã«
    std::uniform_real_distribution<float> distLife(0.5f, 0.8f);      // å¯¿å‘½ã‚’ã‚„ã‚„å»¶é•·
    std::uniform_real_distribution<float> distRed(0.30f, 0.60f);
    std::uniform_real_distribution<float> distTint(0.02f, 0.08f);

    float angle = distAngle(rand);
    float speed = distSpeed(rand);
    float yComp = distY(rand);
    float raise = distUp(rand);

    // XZå¹³é¢ã®ãƒ©ãƒ³ãƒ€ãƒ æ–¹å‘ã«å¼·ãå¼¾ãï¼ˆå°‘ã—ä¸Šå‘ããƒã‚¤ã‚¢ã‚¹ï¼‰
    Vector3 dir = { std::cos(angle), yComp + 0.15f, std::sin(angle) };
    dir = dir.Normalize();

    Particle p;
    p.transform.translate = translate;
    // ç™ºç”Ÿä½ç½®ã‚’å°‘ã—ä¸Šã’ã¦ãƒ¢ãƒ‡ãƒ«ã«åŸ‹ã‚‚ã‚Œã«ããã™ã‚‹
    p.transform.translate.y += raise;

    // åˆæœŸã‚¹ã‚±ãƒ¼ãƒ«ãƒ»å›žè»¢
    float s = distScale(rand);
    p.transform.scale = { s, s, s };
    p.transform.rotate = { distRot(rand), distRot(rand), distRot(rand) };

    // é«˜é€Ÿã«é£›ã°ã™ï¼ˆXZæ–¹å‘ãŒä¸»ï¼‰
    p.velocity = dir * speed;

    // å¾ã€…ã«å°ã•ãã™ã‚‹
    float sv = distScaleVel(rand);
    p.scaleVelocity = { sv, sv, sv };

    // å›žè»¢ã‚’å¼·ã‚ã«ä»˜ä¸Ž
    p.angularVelocity = { distAngVel(rand), distAngVel(rand), distAngVel(rand) };

    // æš—ã‚ã®èµ¤ï¼ˆå¾®å¦™ã«ã°ã‚‰ã¤ãï¼‰
    float r = distRed(rand);
    float g = distTint(rand);
    float b = distTint(rand) * 0.4f;
    p.color = { r, g, b, 1.0f };

    p.lifeTime = distLife(rand);
    p.currentTime = 0.0f;

    return p;
}

Particle ParticleMotion::MakeBulletHitReaction(std::mt19937& rand, const Vector3& translate)
{
    std::uniform_real_distribution<float> distRadius(0.5f, 1.0f);

    // ç¸¦æ¨ªã¯åŒã˜å¤§ãã•ã«ã™ã‚‹
	float dist = distRadius(rand);

    Particle p;
    p.transform.scale = { dist, dist, dist };
    p.transform.translate = translate;
    p.velocity = { 0, 1.0f, 0 };
	p.scaleVelocity = { 1.0f, 1.0f, 1.0f };
    p.color = { 1.0f, 1.0f, 1.0f, 1.0f };
    p.lifeTime = 0.5f;
    p.currentTime = 0.0f;

    return p;
}


void ParticleMotion::SetDirection(const std::string& direction)
{
	direction_ = direction;
}


============================================================
File Path: project/gameEngine/particle/ParticleMotion.h
============================================================
#pragma once

#include <unordered_map>
#include <functional>
#include <string>
#include <random>
#include <MyMath.h>

#include "Particle.h"

/// <summary>
/// ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã®ãƒ¢ãƒ¼ã‚·ãƒ§ãƒ³ç®¡ç†
/// ç™»éŒ²ã€ç”Ÿæˆã€ä¸€è¦§å–å¾—ãªã©
/// </summary>
class ParticleMotion
{
public:

    using MotionFunc = std::function<Particle(std::mt19937&, const Vector3&)>;

    /// <summary>
	/// ãƒ¢ãƒ¼ã‚·ãƒ§ãƒ³ã®ç™»éŒ²
    /// </summary>
	/// <param name="name">ãƒ¢ãƒ¼ã‚·ãƒ§ãƒ³å</param>
	/// <param name="func">ãƒ¢ãƒ¼ã‚·ãƒ§ãƒ³ç”Ÿæˆé–¢æ•°</param>
    static void Register(const std::string& name, MotionFunc func);

	/// <summary>
	/// ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã®ç”Ÿæˆ
	/// </summary>
	/// <param name="name">ãƒ¢ãƒ¼ã‚·ãƒ§ãƒ³å</param>
	/// <param name="rand">ä¹±æ•°ç”Ÿæˆå™¨</param>
	/// <param name="pos">ç”Ÿæˆä½ç½®</param>
	/// <returns>ç”Ÿæˆã—ãŸãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«</returns>
    static Particle Create(const std::string& name, std::mt19937& rand, const Vector3& pos);

    /// <summary>
	/// åˆæœŸåŒ–(ãƒ¢ãƒ¼ã‚·ãƒ§ãƒ³ç™»éŒ²)
    /// </summary>
    static void Initialize();

    /// <summary>
    /// ç™»éŒ²æ¸ˆã¿ä¸€è¦§å–å¾—(ImGui ãªã©UIè¡¨ç¤ºç”¨)
    /// </summary>
	/// <returns>ãƒ¢ãƒ¼ã‚·ãƒ§ãƒ³é–¢æ•°ã®ãƒžãƒƒãƒ—</returns>
    static const std::unordered_map<std::string, MotionFunc>& GetAll();

    // å„ãƒ¢ãƒ¼ã‚·ãƒ§ãƒ³é–¢æ•°ã®å®šç¾©
 
    /// <summary>
	/// ã‚¿ãƒ¼ã‚²ãƒƒãƒˆã«å‘ã‹ã£ã¦é£›ã¶
    /// </summary>
	/// <param name="rand">ãƒ©ãƒ³ãƒ€ãƒ ç”Ÿæˆå™¨</param>
	/// <param name="target">ç›®æ¨™ä½ç½®</param>
	/// <returns>ç”Ÿæˆã—ãŸãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«</returns>
    static Particle MakeHoming(std::mt19937& rand, const Vector3& target);
    /// <summary>
	/// ã‚¿ãƒ¼ã‚²ãƒƒãƒˆã®å‘¨ã‚Šã‚’å›žã‚‹
    /// </summary>
	/// <param name="rand">ãƒ©ãƒ³ãƒ€ãƒ ç”Ÿæˆå™¨</param>
    /// <param name="target">ç›®æ¨™ä½ç½®</param>
    /// <returns>ç”Ÿæˆã—ãŸãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«</returns>
    static Particle MakeOrbit(std::mt19937& rand, const Vector3& target);
	/// <summary>
	/// ä¸­å¿ƒã‹ã‚‰ãƒ©ãƒ³ãƒ€ãƒ ã«æ”¾å°„çŠ¶ã«é£›ã¶
	/// </summary>
	/// <param name="rand">ãƒ©ãƒ³ãƒ€ãƒ ç”Ÿæˆå™¨</param>
	/// <param name="center">ä¸­å¿ƒ</param>
	/// <returns>ç”Ÿæˆã—ãŸãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«</returns>
    static Particle MakeExplosion(std::mt19937& rand, const Vector3& center);
	/// <summary>
	/// ä¸­å¿ƒã‹ã‚‰ç ´è£‚ã™ã‚‹ã‚ˆã†ã«é£›ã¶
	/// </summary>
	/// <param name="rand">ãƒ©ãƒ³ãƒ€ãƒ ç”Ÿæˆå™¨</param>
	/// <param name="center">ä¸­å¿ƒ</param>
	/// <returns>ç”Ÿæˆã—ãŸãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«</returns>
	static Particle MakeRupture(std::mt19937& rand, const Vector3& center);
	/// <summary>
	/// baseã‹ã‚‰ä¸Šã«å‘ã‹ã£ã¦å™´å‡º
	/// </summary>
	/// <param name="rand">ãƒ©ãƒ³ãƒ€ãƒ ç”Ÿæˆå™¨</param>
	/// <param name="base">ç™ºç¾åœ°ç‚¹</param>
	/// <returns>ç”Ÿæˆã—ãŸãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«</returns>
    static Particle MakeFountain(std::mt19937& rand, const Vector3& base);
	/// <summary>
	/// originã‚’ä¸­å¿ƒã«ãƒ©ãƒ³ãƒ€ãƒ ã«æºã‚Œã‚‹
	/// </summary>
	/// <param name="rand">ãƒ©ãƒ³ãƒ€ãƒ ç”Ÿæˆå™¨</param>
	/// <param name="origin">ä¸­å¿ƒ</param>
	/// <returns>ç”Ÿæˆã—ãŸãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«</returns>
    static Particle MakeWiggle(std::mt19937& rand, const Vector3& origin);
	/// <summary>
	/// å††æŸ±çŠ¶ã«æ”¾å°„
	/// </summary>
	/// <param name="rand">ãƒ©ãƒ³ãƒ€ãƒ ç”Ÿæˆå™¨</param>
	/// <param name="position">ç™ºç¾ä½ç½®</param>
	/// <returns>ç”Ÿæˆã—ãŸãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«</returns>
    static Particle MakeCylinder(std::mt19937& rand, const Vector3& position);
	/// <summary>
	/// æ–œã‚ã«ã‚¹ãƒ©ãƒƒã‚·ãƒ¥
	/// </summary>
	/// <param name="rand">ãƒ©ãƒ³ãƒ€ãƒ ç”Ÿæˆå™¨</param>
	/// <param name="translate">ç™ºç¾åœ°ç‚¹</param>
	/// <returns>ç”Ÿæˆã—ãŸãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«</returns>
    static Particle MakeSlash(std::mt19937& rand, const Vector3& translate);
	/// <summary>
	/// ç‚Žã®ã‚ˆã†ã«ä¸Šæ˜‡
	/// </summary>
	/// <param name="rand">ãƒ©ãƒ³ãƒ€ãƒ ç”Ÿæˆå™¨</param>
	/// <param name="base">ç™ºç¾ä½ç½®</param>
	/// <returns>ç”Ÿæˆã—ãŸãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«</returns>
    static Particle MakeFlame(std::mt19937& rand, const Vector3& base);

    // é­”æ³•é™£
	/// <summary>
	/// é­”æ³•é™£
	/// </summary>
	/// <param name="rand">ãƒ©ãƒ³ãƒ€ãƒ ç”Ÿæˆå™¨</param>
	/// <param name="translate">ç™ºç¾åœ°ç‚¹</param>
	/// <returns>ç”Ÿæˆã—ãŸãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«</returns>
    static Particle MakeMagic1(std::mt19937& rand, const Vector3& translate);
	/// <summary>
	/// é­”æ³•é™£ãƒ‘ãƒ©ãƒ‘ãƒ©
	/// </summary>
	/// <param name="rand">ãƒ©ãƒ³ãƒ€ãƒ ç”Ÿæˆå™¨</param>
	/// <param name="translate">ä¸­å¿ƒ</param>
	/// <returns>ç”Ÿæˆã—ãŸãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«</returns>
	static Particle MakeMagic2(std::mt19937& rand, const Vector3& translate);
	/// <summary>
	/// ãƒ¬ãƒ¼ã‚¶ãƒ¼
	/// </summary>
	/// <param name="rand">ãƒ©ãƒ³ãƒ€ãƒ ç”ŸæˆæœŸ</param>
	/// <param name="translate">ç™ºç¾åœ°ç‚¹</param>
	/// <returns>ç”Ÿæˆã—ãŸãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«</returns>
	static Particle MakeLaser(std::mt19937& rand, const Vector3& translate);

	/// <summary>
	/// èŠ±ã³ã‚‰
	/// </summary>
	/// <param name="rand">ãƒ©ãƒ³ãƒ€ãƒ ç”Ÿæˆå™¨</param>
	/// <param name="base">ç™ºç¾ä½ç½®</param>
	/// <returns>ç”Ÿæˆã—ãŸãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«</returns>
	static Particle MakePetal(std::mt19937& rand, const Vector3& translate);

	/// <summary>
	/// æ°´
	/// </summary>
	/// <param name="rand">ãƒ©ãƒ³ãƒ€ãƒ ç”Ÿæˆå™¨</param>
	/// <param name="base">ç™ºç¾ä½ç½®</param>
	/// <returns>ç”Ÿæˆã—ãŸãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«</returns>
	static Particle MakeWater(std::mt19937& rand, const Vector3& translate);

	/// <summary>
	/// æ³¡
	/// </summary>
	/// <param name="rand">ãƒ©ãƒ³ãƒ€ãƒ ç”Ÿæˆå™¨</param>
	/// <param name="base">ç™ºç¾ä½ç½®</param>
	/// <returns>ç”Ÿæˆã—ãŸãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«</returns>
	static Particle MakeBubble(std::mt19937& rand, const Vector3& translate);

	/// <summary>
	/// åœŸåŸƒ
	/// </summary>
	/// <param name="rand">ãƒ©ãƒ³ãƒ€ãƒ ç”Ÿæˆå™¨</param>
	/// <param name="base">ç™ºç¾ä½ç½®</param>
	/// <returns>ç”Ÿæˆã—ãŸãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«</returns>
	static Particle MakeDust(std::mt19937& rand, const Vector3& translate);

	/// <summary>
	/// æ•µåœŸåŸƒ
	/// </summary>
	/// <param name="rand">ãƒ©ãƒ³ãƒ€ãƒ ç”Ÿæˆå™¨</param>
	/// <param name="base">ç™ºç¾ä½ç½®</param>
	/// <returns>ç”Ÿæˆã—ãŸãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«</returns>
	static Particle MakeEnemyDust(std::mt19937& rand, const Vector3& translate);
    
	/// <summary>
	/// ãƒ‡ãƒãƒ•
	/// </summary>
	/// <param name="rand">ãƒ©ãƒ³ãƒ€ãƒ ç”Ÿæˆå™¨</param>
	/// <param name="base">ç™ºç¾ä½ç½®</param>
	/// <returns>ç”Ÿæˆã—ãŸãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«</returns>
	static Particle MakeDebuff(std::mt19937& rand, const Vector3& translate);

	/// <summary>
	/// ã‚¹ãƒ‘ãƒ¼ã‚¯
	/// </summary>
	/// <param name="rand">ãƒ©ãƒ³ãƒ€ãƒ ç”Ÿæˆå™¨</param>
	/// <param name="base">ç™ºç¾ä½ç½®</param>
	/// <returns>ç”Ÿæˆã—ãŸãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«</returns>
	static Particle MakeSpark(std::mt19937& rand, const Vector3& translate);

	/// <summary>
	/// å¼¾ã‘ã‚‹ã‚¹ãƒ‘ãƒ¼ã‚¯
	/// </summary>
	/// <param name="rand">ãƒ©ãƒ³ãƒ€ãƒ ç”Ÿæˆå™¨</param>
	/// <param name="base">ç™ºç¾ä½ç½®</param>
	/// <returns>ç”Ÿæˆã—ãŸãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«</returns>
	static Particle MakeSparkBurst(std::mt19937& rand, const Vector3& translate);
 
	/// <summary>
	/// ãƒ’ãƒƒãƒˆãƒªã‚¢ã‚¯ã‚·ãƒ§ãƒ³ä¸­å¿ƒã‹ã‚‰ã‚µã‚¤ãƒ‰ã«å¼¾ã‘ã‚‹ã‚ˆã†ã«é£›ã¶
	/// </summary>
	/// <param name="rand">ãƒ©ãƒ³ãƒ€ãƒ ç”Ÿæˆå™¨</param>
	/// <param name="translate">ç™ºç¾ä½ç½®</param>
	/// <returns>ç”Ÿæˆã—ãŸãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«</returns>
	static Particle MakeHitReaction(std::mt19937& rand, const Vector3& translate);

	/// <summary>
	/// å¼¾ä¸¸ãƒ’ãƒƒãƒˆãƒªã‚¢ã‚¯ã‚·ãƒ§ãƒ³
	/// </summary>
	/// <param name="rand">ãƒ©ãƒ³ãƒ€ãƒ ç”Ÿæˆå™¨</param>
	/// <param name="translate">ç™ºç¾ä½ç½®</param>
	/// <returns>ç”Ÿæˆã—ãŸãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«</returns>
	static Particle MakeBulletHitReaction(std::mt19937& rand, const Vector3& translate);

public: // ã‚»ãƒƒã‚¿ãƒ¼

	/// <summary>
	/// Ringæ–¹å‘è¨­å®š
	/// "UP"ä¸‹ã‹ã‚‰ä¸Š
	/// "DOWN"ä¸Šã‹ã‚‰ä¸‹
	/// "LEFT"å³ã‹ã‚‰å·¦
	/// "RIGHT"å·¦ã‹ã‚‰å³
	/// </summary>
	/// <param name="direction">æ–¹å‘æ–‡å­—åˆ—</param>
    static void SetDirection(const std::string& direction);

private:

    static std::unordered_map<std::string, MotionFunc> motions_;

    static std::string direction_;

};



============================================================
File Path: project/gameEngine/skybox/Skybox.cpp
============================================================
#include "Skybox.h"

#include <DirectXCommon.h>
#include <SrvManager.h>

#include "../3d/CameraManager.h"

void Skybox::Initialize(DirectXCommon* dxCommon, SrvManager* srvManager)
{
	dxCommon_ = dxCommon;
	srvManager_ = srvManager;

	// é ‚ç‚¹ãƒ»ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ãƒãƒƒãƒ•ã‚¡ã®ç”Ÿæˆ
	CreateBuffers();
	// å®šæ•°ãƒãƒƒãƒ•ã‚¡ã®ç”Ÿæˆ
	CreateConstantBuffer();
	// ãƒ«ãƒ¼ãƒˆã‚·ã‚°ãƒãƒãƒ£ã®ç”Ÿæˆ
	CreateRootSignature();
	// ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³ã‚¹ãƒ†ãƒ¼ãƒˆã®ç”Ÿæˆ
	CreatePipelineState();
}

void Skybox::Finalize()
{
	vertexBuffer_.Reset();
	indexBuffer_.Reset();
	constantBuffer_.Reset();
	rootSignature_.Reset();
	pipelineState_.Reset();
	dxCommon_ = nullptr;
	cubeMapSrvIndex_ = 0;
}

void Skybox::Update()
{
	// ã‚«ãƒ¡ãƒ©ã‹ã‚‰ãƒ“ãƒ¥ãƒ¼è¡Œåˆ—ãƒ»å°„å½±è¡Œåˆ—ã‚’å–å¾—
	Matrix4x4 view = CameraManager::GetInstance().GetActiveCamera()->GetViewMatrix();//dxCommon_->GetCamera()->GetViewMatrix();
	Matrix4x4 proj = CameraManager::GetInstance().GetActiveCamera()->GetProjectionMatrix();

	// ã‚«ãƒ¡ãƒ©ã®ä½ç½®æˆåˆ†ã‚’ã‚¼ãƒ­ã«ï¼ˆSkyboxã¯ã‚«ãƒ¡ãƒ©ã«è¿½å¾“ã•ã›ã‚‹ï¼‰
	view.m[0][3] = 0.0f;
	view.m[1][3] = 0.0f;
	view.m[2][3] = 0.0f;

	// Zåè»¢è¡Œåˆ—ï¼ˆå·¦æ‰‹åº§æ¨™ç³»ã§å¥¥ã‚’å‘ãCubeMapç”¨ï¼‰
	Matrix4x4 flipZ = {
		1, 0,  0, 0,
		0, 1,  0, 0,
		0, 0, -1, 0,
		0, 0,  0, 1
	};

	// ã‚¹ã‚±ãƒ¼ãƒªãƒ³ã‚°ï¼ˆSkyboxã‚’ååˆ†å¤§ããã™ã‚‹ï¼‰
	Matrix4x4 scale = MakeScaleMatrix({ 1000.0f, 1000.0f, 1000.0f });

	Matrix4x4 wvp = scale * view * proj * flipZ;
	memcpy(&mappedConstBuffer_->viewProj, &wvp, sizeof(Matrix4x4));
}

void Skybox::Draw()
{
	ID3D12GraphicsCommandList* cmdList = dxCommon_->GetCommandList().Get();

	// ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³ã¨ãƒ«ãƒ¼ãƒˆã‚·ã‚°ãƒãƒãƒ£è¨­å®š
	cmdList->SetGraphicsRootSignature(rootSignature_.Get());
	cmdList->SetPipelineState(pipelineState_.Get());

	// ãƒ«ãƒ¼ãƒˆãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿  å®šæ•°ãƒãƒƒãƒ•ã‚¡ b0ï¼ˆVSç”¨ï¼‰
	cmdList->SetGraphicsRootConstantBufferView(0, constantBuffer_->GetGPUVirtualAddress());
	cmdList->SetGraphicsRootConstantBufferView(1, materialBuffer_->GetGPUVirtualAddress());

	// ãƒ«ãƒ¼ãƒˆãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿  SRV (CubeMap) ã‚’ãƒ”ã‚¯ã‚»ãƒ«ã‚·ã‚§ãƒ¼ãƒ€ãƒ¼ã«æ¸¡ã™ï¼ˆDescriptor Tableï¼‰
	D3D12_GPU_DESCRIPTOR_HANDLE gpuHandle = srvManager_->GetGPUDescriptorHandle(cubeMapSrvIndex_);
	cmdList->SetGraphicsRootDescriptorTable(2, gpuHandle);

	// é ‚ç‚¹ãƒ»ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ãƒãƒƒãƒ•ã‚¡è¨­å®š
	cmdList->IASetVertexBuffers(0, 1, &vbView_);
	cmdList->IASetIndexBuffer(&ibView_);
	cmdList->IASetPrimitiveTopology(D3D_PRIMITIVE_TOPOLOGY_TRIANGLELIST);

	// æç”»å‘¼ã³å‡ºã—
	cmdList->DrawIndexedInstanced(static_cast<UINT>(indexData_.size()), 1, 0, 0, 0);
}

void Skybox::CreateBuffers()
{
	// å³é¢
	vertexData_[0].position = { 1.0f,1.0f,1.0f };
	vertexData_[1].position = { 1.0f,1.0f,-1.0f };
	vertexData_[2].position = { 1.0f,-1.0f,1.0f };
	vertexData_[3].position = { 1.0f,-1.0f,-1.0f };
	// å·¦é¢
	vertexData_[4].position = { -1.0f,1.0f,-1.0f };
	vertexData_[5].position = { -1.0f,1.0f,1.0f };
	vertexData_[6].position = { -1.0f,-1.0f,-1.0f };
	vertexData_[7].position = { -1.0f,-1.0f,1.0f };
	// å‰é¢
	vertexData_[8].position = { -1.0f,1.0f,1.0f };
	vertexData_[9].position = { 1.0f,1.0f,1.0f };
	vertexData_[10].position = { -1.0f,-1.0f,1.0f };
	vertexData_[11].position = { 1.0f,-1.0f,1.0f };
	// å¾Œé¢
	vertexData_[12].position = { 1.0f,1.0f,-1.0f };
	vertexData_[13].position = { -1.0f,1.0f,-1.0f };
	vertexData_[14].position = { 1.0f,-1.0f,-1.0f };
	vertexData_[15].position = { -1.0f,-1.0f,-1.0f };
	// ä¸Šé¢
	vertexData_[16].position = { -1.0f,1.0f,1.0f };
	vertexData_[17].position = { 1.0f,1.0f,1.0f };
	vertexData_[18].position = { -1.0f,1.0f,-1.0f };
	vertexData_[19].position = { 1.0f,1.0f,-1.0f };
	// ä¸‹é¢
	vertexData_[20].position = { -1.0f,-1.0f,-1.0f };
	vertexData_[21].position = { 1.0f,-1.0f,-1.0f };
	vertexData_[22].position = { -1.0f,-1.0f,1.0f };
	vertexData_[23].position = { 1.0f,-1.0f,1.0f };

	for (int i = 0; i < vertexData_.size(); ++i)
	{
		vertexData_[i].texcoord = vertexData_[i].position;
	}

	// é ‚ç‚¹ãƒãƒƒãƒ•ã‚¡ä½œæˆ
	size_t vertexBufferSize = sizeof(vertexData_);
	vertexBuffer_ = dxCommon_->CreateBufferResource(vertexBufferSize);

	// GPUãƒ¡ãƒ¢ãƒªã«è»¢é€
	SkyboxVertex* mappedVertex = nullptr;
	vertexBuffer_->Map(0, nullptr, reinterpret_cast<void**>(&mappedVertex));
	memcpy(mappedVertex, vertexData_.data(), vertexBufferSize);
	vertexBuffer_->Unmap(0, nullptr);

	vbView_.BufferLocation = vertexBuffer_->GetGPUVirtualAddress();
	vbView_.SizeInBytes = static_cast<UINT>(vertexBufferSize);
	vbView_.StrideInBytes = sizeof(SkyboxVertex);

	// ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ãƒãƒƒãƒ•ã‚¡ä½œæˆ
	indexData_ =
	{
		// å³é¢
		0, 2, 1, 1, 2, 3,
		// å·¦é¢
		4, 6, 5, 5, 6, 7,
		// å‰é¢
		8, 10, 9, 9, 10, 11,
		// å¾Œé¢
		12, 14, 13, 13, 14, 15,
		// ä¸Šé¢
		16, 18, 17, 17, 18, 19,
		// ä¸‹é¢
		20, 22, 21, 21, 22, 23
	};
	size_t indexBufferSize = sizeof(indexData_);
	indexBuffer_ = dxCommon_->CreateBufferResource(indexBufferSize);

	uint16_t* mappedIndex = nullptr;
	indexBuffer_->Map(0, nullptr, reinterpret_cast<void**>(&mappedIndex));
	memcpy(mappedIndex, indexData_.data(), indexBufferSize);
	indexBuffer_->Unmap(0, nullptr);

	ibView_.BufferLocation = indexBuffer_->GetGPUVirtualAddress();
	ibView_.SizeInBytes = static_cast<UINT>(indexBufferSize);
	ibView_.Format = DXGI_FORMAT_R16_UINT;
}

void Skybox::CreateConstantBuffer()
{
	// å®šæ•°ãƒãƒƒãƒ•ã‚¡ã®ä½œæˆï¼ˆViewProjectionè¡Œåˆ—ï¼‰
	constantBuffer_ = dxCommon_->CreateBufferResource(sizeof(ConstBufferData));
	constantBuffer_->Map(0, nullptr, reinterpret_cast<void**>(&mappedConstBuffer_));

	materialBuffer_ = dxCommon_->CreateBufferResource(sizeof(Material));
	materialBuffer_->Map(0, nullptr, reinterpret_cast<void**>(&mappedMaterial_));
	mappedMaterial_->color = { 1.0f, 1.0f, 1.0f, 1.0f };
	XMStoreFloat4x4(&mappedMaterial_->uvTransform, DirectX::XMMatrixIdentity());
}

void Skybox::CreateRootSignature()
{
	D3D12_ROOT_PARAMETER rootParams[3]{};

	// b0: VSç”¨ å®šæ•°ãƒãƒƒãƒ•ã‚¡ï¼ˆviewProjï¼‰
	rootParams[0].ParameterType = D3D12_ROOT_PARAMETER_TYPE_CBV;
	rootParams[0].ShaderVisibility = D3D12_SHADER_VISIBILITY_VERTEX;
	rootParams[0].Descriptor.ShaderRegister = 0;
	rootParams[0].Descriptor.RegisterSpace = 0;

	// b1: PSç”¨ Materialå®šæ•°ãƒãƒƒãƒ•ã‚¡ï¼ˆcolor, uvTransformï¼‰
	rootParams[1].ParameterType = D3D12_ROOT_PARAMETER_TYPE_CBV;
	rootParams[1].ShaderVisibility = D3D12_SHADER_VISIBILITY_PIXEL;
	rootParams[1].Descriptor.ShaderRegister = 1;
	rootParams[1].Descriptor.RegisterSpace = 0;

	// t0 (TextureCube)
	D3D12_DESCRIPTOR_RANGE descRange{};
	descRange.RangeType = D3D12_DESCRIPTOR_RANGE_TYPE_SRV;
	descRange.NumDescriptors = 1;
	descRange.BaseShaderRegister = 0;
	descRange.RegisterSpace = 0;
	descRange.OffsetInDescriptorsFromTableStart = D3D12_DESCRIPTOR_RANGE_OFFSET_APPEND;

	rootParams[2].ParameterType = D3D12_ROOT_PARAMETER_TYPE_DESCRIPTOR_TABLE;
	rootParams[2].ShaderVisibility = D3D12_SHADER_VISIBILITY_PIXEL;
	rootParams[2].DescriptorTable.NumDescriptorRanges = 1;
	rootParams[2].DescriptorTable.pDescriptorRanges = &descRange;

	// Sampler
	D3D12_STATIC_SAMPLER_DESC samplerDesc{};
	samplerDesc.Filter = D3D12_FILTER_MIN_MAG_MIP_LINEAR;
	samplerDesc.AddressU = D3D12_TEXTURE_ADDRESS_MODE_WRAP;
	samplerDesc.AddressV = D3D12_TEXTURE_ADDRESS_MODE_WRAP;
	samplerDesc.AddressW = D3D12_TEXTURE_ADDRESS_MODE_WRAP;
	samplerDesc.ComparisonFunc = D3D12_COMPARISON_FUNC_ALWAYS;
	samplerDesc.ShaderRegister = 0;
	samplerDesc.RegisterSpace = 0;
	samplerDesc.ShaderVisibility = D3D12_SHADER_VISIBILITY_PIXEL;

	// ã‚·ãƒªã‚¢ãƒ©ã‚¤ã‚ºã¨ä½œæˆ
	D3D12_ROOT_SIGNATURE_DESC desc{};
	desc.NumParameters = _countof(rootParams);
	desc.pParameters = rootParams;
	desc.NumStaticSamplers = 1;
	desc.pStaticSamplers = &samplerDesc;
	desc.Flags = D3D12_ROOT_SIGNATURE_FLAG_ALLOW_INPUT_ASSEMBLER_INPUT_LAYOUT;

	Microsoft::WRL::ComPtr<ID3DBlob> signatureBlob;
	Microsoft::WRL::ComPtr<ID3DBlob> errorBlob;
	HRESULT hr = D3D12SerializeRootSignature(&desc, D3D_ROOT_SIGNATURE_VERSION_1,
		&signatureBlob, &errorBlob);
	if (FAILED(hr)) {
		OutputDebugStringA((char*)errorBlob->GetBufferPointer());
		assert(false);
	}

	dxCommon_->GetDevice()->CreateRootSignature(0, signatureBlob->GetBufferPointer(),
		signatureBlob->GetBufferSize(),
		IID_PPV_ARGS(&rootSignature_));
}

void Skybox::CreatePipelineState()
{
	// ã‚·ã‚§ãƒ¼ãƒ€èª­ã¿è¾¼ã¿
	auto vsBlob = dxCommon_->CompileShader(L"resources/shaders/Skybox.VS.hlsl", L"vs_6_0");
	auto psBlob = dxCommon_->CompileShader(L"resources/shaders/Skybox.PS.hlsl", L"ps_6_0");

	// å…¥åŠ›ãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆ
	D3D12_INPUT_ELEMENT_DESC inputLayout[] =
	{
		{ "POSITION", 0, DXGI_FORMAT_R32G32B32_FLOAT, 0, 0, D3D12_INPUT_CLASSIFICATION_PER_VERTEX_DATA, 0 },
		{ "TEXCOORD", 0, DXGI_FORMAT_R32G32B32_FLOAT, 0, 12,D3D12_INPUT_CLASSIFICATION_PER_VERTEX_DATA, 0}
	};

	D3D12_GRAPHICS_PIPELINE_STATE_DESC desc{};
	desc.InputLayout = { inputLayout, _countof(inputLayout) };
	desc.pRootSignature = rootSignature_.Get();
	desc.VS = { vsBlob->GetBufferPointer(), vsBlob->GetBufferSize() };
	desc.PS = { psBlob->GetBufferPointer(), psBlob->GetBufferSize() };

	D3D12_RASTERIZER_DESC rasterizerDesc = CD3DX12_RASTERIZER_DESC(D3D12_DEFAULT);
	rasterizerDesc.CullMode = D3D12_CULL_MODE_NONE;
	desc.RasterizerState  = rasterizerDesc;

	desc.BlendState = CD3DX12_BLEND_DESC(D3D12_DEFAULT);

	D3D12_DEPTH_STENCIL_DESC depthDesc = CD3DX12_DEPTH_STENCIL_DESC(D3D12_DEFAULT);
	depthDesc.DepthEnable = TRUE;
	depthDesc.DepthWriteMask = D3D12_DEPTH_WRITE_MASK_ZERO;
	depthDesc.DepthFunc = D3D12_COMPARISON_FUNC_LESS_EQUAL;
	depthDesc.StencilEnable = FALSE;
	desc.DepthStencilState = depthDesc;

	desc.SampleMask = UINT_MAX; // å…¨ã‚µãƒ³ãƒ—ãƒ«ã‚’æœ‰åŠ¹åŒ–
	desc.PrimitiveTopologyType = D3D12_PRIMITIVE_TOPOLOGY_TYPE_TRIANGLE;
	desc.NumRenderTargets = 1;
	desc.RTVFormats[0] = DXGI_FORMAT_R8G8B8A8_UNORM_SRGB; 
	desc.DSVFormat = DXGI_FORMAT_D24_UNORM_S8_UINT;
	desc.SampleDesc.Count = 1;

	HRESULT hr = dxCommon_->GetDevice()->CreateGraphicsPipelineState(&desc, IID_PPV_ARGS(&pipelineState_));
	assert(SUCCEEDED(hr));
	hr;
}

============================================================
File Path: project/gameEngine/skybox/Skybox.h
============================================================
#pragma once

#include <wrl.h>
#include <d3d12.h>
#include <string>
#include <array>
#include <DirectXMath.h>
#include <MyMath.h>

class DirectXCommon;
class SrvManager;

struct SkyboxVertex
{
    DirectX::XMFLOAT3 position;
    DirectX::XMFLOAT3 texcoord;
};

struct Material 
{
    DirectX::XMFLOAT4 color;
    DirectX::XMFLOAT4X4 uvTransform;
};

/// <summary>
/// ã‚¹ã‚«ã‚¤ãƒœãƒƒã‚¯ã‚¹
/// </summary>
class Skybox
{
public:

	/// <summary>
    /// åˆæœŸåŒ–
	/// </summary>
	/// <param name="dxCommon">DirectXå…±é€šç®¡ç†</param>
    void Initialize(DirectXCommon* dxCommon, SrvManager* srvManager);
    // çµ‚äº†
    void Finalize();
    // æ›´æ–°
    void Update();
    // æç”»
    void Draw();

public: // ã‚»ãƒƒã‚¿ãƒ¼

    /// <summary>
	/// ã‚­ãƒ¥ãƒ¼ãƒ–ãƒžãƒƒãƒ—ã®SRVã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã‚’è¨­å®š
    /// </summary>
	/// <param name="index">SRVã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹</param>
    void SetCubeMapSrvIndex(uint32_t index) { cubeMapSrvIndex_ = index; }

private:

    // é ‚ç‚¹ãƒ»ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ãƒãƒƒãƒ•ã‚¡ã®ç”Ÿæˆ
    void CreateBuffers();
    // å®šæ•°ãƒãƒƒãƒ•ã‚¡ã®ç”Ÿæˆ
    void CreateConstantBuffer();
    // ãƒ«ãƒ¼ãƒˆã‚·ã‚°ãƒãƒãƒ£ã®ç”Ÿæˆ
    void CreateRootSignature();
    // ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³ã‚¹ãƒ†ãƒ¼ãƒˆã®ç”Ÿæˆ
    void CreatePipelineState();

private:

    // 24é ‚ç‚¹ã¨36ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã‚’æŒã¤ç«‹æ–¹ä½“ã®é ‚ç‚¹ãƒ‡ãƒ¼ã‚¿
    std::array<SkyboxVertex, 24> vertexData_{};
    std::array<uint16_t, 36> indexData_{};

    // é ‚ç‚¹ãƒ»ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ãƒãƒƒãƒ•ã‚¡
    Microsoft::WRL::ComPtr<ID3D12Resource> vertexBuffer_;
    Microsoft::WRL::ComPtr<ID3D12Resource> indexBuffer_;
    D3D12_VERTEX_BUFFER_VIEW vbView_{};
    D3D12_INDEX_BUFFER_VIEW ibView_{};

    // å®šæ•°ãƒãƒƒãƒ•ã‚¡ï¼ˆãƒ“ãƒ¥ãƒ¼ãƒ»å°„å½±è¡Œåˆ—ãªã©ï¼‰
    Microsoft::WRL::ComPtr<ID3D12Resource> constantBuffer_;
    struct ConstBufferData {
        Matrix4x4 viewProj;
    };
    ConstBufferData* mappedConstBuffer_ = nullptr;

    Microsoft::WRL::ComPtr<ID3D12Resource> materialBuffer_;
    Material* mappedMaterial_ = nullptr;

    // ãƒ«ãƒ¼ãƒˆã‚·ã‚°ãƒãƒãƒ£
    Microsoft::WRL::ComPtr<ID3D12RootSignature> rootSignature_;
    // ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³ã‚¹ãƒ†ãƒ¼ãƒˆ
    Microsoft::WRL::ComPtr<ID3D12PipelineState> pipelineState_;

    // SRVã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ï¼ˆSrvManagerç­‰ã§å‰²ã‚Šå½“ã¦ãŸCubeMapã®SRVç•ªå·ï¼‰
    uint32_t cubeMapSrvIndex_ = 0;

    // DirectXå…±é€šç®¡ç†
    DirectXCommon* dxCommon_ = nullptr;
    // SRVãƒžãƒãƒ¼ã‚¸ãƒ£ãƒ¼
    SrvManager* srvManager_ = nullptr;
};

============================================================
File Path: project/gameEngine/time/TimeManager.cpp
============================================================
#include "TimeManager.h"
#include <algorithm>

TimeManager& TimeManager::Instance()
{
	// ã‚·ãƒ³ã‚°ãƒ«ãƒˆãƒ³ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã®å–å¾—
	static TimeManager instance;
	return instance;
}

TimeManager::TimeManager()
{
	// åˆæœŸåŒ–
    lastTime_ = std::chrono::steady_clock::now();
    initialized_ = true;
}

void TimeManager::UpdateTimers(float scaledDT, float unscaledDT)
{
	// æ—©æœŸãƒªã‚¿ãƒ¼ãƒ³
    if (timers_.empty())
    {
        return;
    }

	// ã‚³ãƒ¼ãƒ«ãƒãƒƒã‚¯å‘¼ã³å‡ºã—ç”¨ãƒªã‚¹ãƒˆ
    std::vector<std::function<void()>> calls;
	// ã‚¿ã‚¤ãƒžãƒ¼æ›´æ–°ãƒ«ãƒ¼ãƒ—
    for (auto it = timers_.begin(); it != timers_.end();)
    {
		// ã‚¿ã‚¤ãƒžãƒ¼å‚ç…§
        Timer& t = *it;
        if (t.cancelled) 
        {
            it = timers_.erase(it); continue; 
        }

		// ãƒ‡ãƒ«ã‚¿ã‚¿ã‚¤ãƒ é©ç”¨
        float dt = t.useUnscaled ? unscaledDT : scaledDT;
        t.remaining -= dt;
		// ã‚¿ã‚¤ãƒžãƒ¼å®Œäº†åˆ¤å®š
        if (t.remaining <= 0.0f) 
        {
			// ã‚³ãƒ¼ãƒ«ãƒãƒƒã‚¯ç™»éŒ²
            if (t.cb) calls.push_back(t.cb);
           
			// ã‚¤ãƒ³ã‚¿ãƒ¼ãƒãƒ«ã‹ã©ã†ã‹ã§å‡¦ç†åˆ†å²
            if (t.interval > 0.0f) 
            {
				// ã‚¤ãƒ³ã‚¿ãƒ¼ãƒãƒ«: æ®‹ã‚Šæ™‚é–“ã‚’ãƒªã‚»ãƒƒãƒˆã—ã¦ç¶™ç¶š
                t.remaining += t.interval;
                ++it;
            }
            else 
            {
				// ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆ: ã‚¿ã‚¤ãƒžãƒ¼å‰Šé™¤
                it = timers_.erase(it);
            }
        } 
        else
        {
			// ç¶™ç¶š
            ++it;
        }
    }

	// ã‚³ãƒ¼ãƒ«ãƒãƒƒã‚¯å‘¼ã³å‡ºã—ãƒ«ãƒ¼ãƒ—
    for (auto& cb : calls) 
    {
		// å®‰å…¨ã®ãŸã‚ä¾‹å¤–ã‚­ãƒ£ãƒƒãƒ
        try { cb(); } catch (...) {} 
    }
}

void TimeManager::Tick()
{
	// ãƒ‡ãƒ«ã‚¿ã‚¿ã‚¤ãƒ è¨ˆç®—
    using clock = std::chrono::steady_clock;
    auto now = clock::now();
    float unscaledDt = 1.0f / 60.0f;

	// åˆå›žæ›´æ–°æ™‚ã¯å‰å›žæ™‚é–“ãŒä¸å®šãªã®ã§ã‚¹ã‚­ãƒƒãƒ—
    if (initialized_) 
    {
        std::chrono::duration<float> elapsed = now - lastTime_;
        unscaledDt = elapsed.count();
        if (unscaledDt > 0.1f) unscaledDt = 0.1f; // clamp large dt (alt-tab)
    }
	// æ›´æ–°æ™‚é–“ä¿å­˜   
    lastTime_ = now;
    unscaledDeltaTime_ = unscaledDt;

	// åœæ­¢ä¸­ã®å‡¦ç†
    if (paused_) 
    {
        if (stepAccumulator_ > 0.0f) 
        {
			// ã‚¹ãƒ†ãƒƒãƒ—å®Ÿè¡Œä¸­: dtã‚’ã‚¹ãƒ†ãƒƒãƒ—åˆ†ã ã‘ã«åˆ¶é™
            float use = std::min(stepAccumulator_, unscaledDt);
            stepAccumulator_ -= use;
            unscaledDt = use;
        } 
        else 
        {
			// åœæ­¢ä¸­: dtã‚’0ã«ã—ã¦ã‚¿ã‚¤ãƒžãƒ¼æ›´æ–°ã®ã¿è¡Œã†
            deltaTime_ = 0.0f;
            UpdateTimers(0.0f, unscaledDt);
            return;
        }
    }

	// ã‚¹ãƒ ãƒ¼ã‚ºãªã‚¿ã‚¤ãƒ ã‚¹ã‚±ãƒ¼ãƒ«å¤‰æ›´ã®æ›´æ–°
    if (smoothingEnabled_) 
    {
		// çµŒéŽæ™‚é–“ã‚’é€²ã‚ã‚‹
        smoothElapsed_ += unscaledDt;
        float t = std::clamp(smoothElapsed_ / std::max(1e-6f, smoothDuration_), 0.0f, 1.0f);
        timeScale_ = smoothStart_ + (smoothTarget_ - smoothStart_) * t;
        if (t >= 1.0f) smoothingEnabled_ = false;
        for (auto& cb : timeScaleCallbacks_) if (cb) cb(timeScale_);
    }

	// ã‚¹ã‚±ãƒ¼ãƒ«ã•ã‚ŒãŸãƒ‡ãƒ«ã‚¿ã‚¿ã‚¤ãƒ è¨ˆç®—
    deltaTime_ = unscaledDt * timeScale_;

	// ã‚¿ã‚¤ãƒžãƒ¼æ›´æ–°
    UpdateTimers(deltaTime_, unscaledDt);
}

void TimeManager::CancelSmoothTimeScale()
{
	// ã‚¹ãƒ ãƒ¼ã‚ºå¤‰æ›´ã‚­ãƒ£ãƒ³ã‚»ãƒ«
    smoothingEnabled_ = false;
}

void TimeManager::Pause()
{
	// æ™‚é–“åœæ­¢
    paused_ = true;
}

void TimeManager::Resume()
{
	// æ™‚é–“å†é–‹
    paused_ = false; 
    stepAccumulator_ = 0.0f;
}

void TimeManager::Step(float seconds)
{
    // ä¸€æ™‚åœæ­¢ä¸­ã®ã¿æœ‰åŠ¹
    if (paused_)
    {
        // ã‚¹ãƒ†ãƒƒãƒ—å®Ÿè¡Œç”¨ã«ç§’æ•°ã‚’åŠ ç®—
        stepAccumulator_ += seconds;
    }
}

void TimeManager::CancelTimer(TimerId id)
{
	// ã‚¿ã‚¤ãƒžãƒ¼æ¤œç´¢ãƒ«ãƒ¼ãƒ—
    for (auto& t : timers_)
    {
		// æŒ‡å®šIDã®ã‚¿ã‚¤ãƒžãƒ¼ã‚’æ¤œç´¢
        if (t.id == id) 
        {
			// ã‚¿ã‚¤ãƒžãƒ¼ã‚’ã‚­ãƒ£ãƒ³ã‚»ãƒ«çŠ¶æ…‹ã«è¨­å®š
            t.cancelled = true;
            break; 
        }
    }
}

void TimeManager::SmoothTimeScale(float toScale, float durationSeconds)
{
    // ã‚¹ãƒ ãƒ¼ã‚ºãªã‚¿ã‚¤ãƒ ã‚¹ã‚±ãƒ¼ãƒ«å¤‰æ›´ã®è¨­å®š
    smoothStart_ = timeScale_;
    smoothTarget_ = std::max(0.0f, toScale);
    smoothDuration_ = std::max(0.0f, durationSeconds);
    smoothElapsed_ = 0.0f;
    smoothingEnabled_ = (smoothDuration_ > 0.0f);
	// å³æ™‚å¤‰æ›´ã®å ´åˆã¯ç›´æŽ¥è¨­å®š
    if (!smoothingEnabled_)
    {
        SetTimeScale(toScale);
    }
}

void TimeManager::AddTimeScaleCallback(TimeScaleCallback cb)
{
	// ã‚¿ã‚¤ãƒ ã‚¹ã‚±ãƒ¼ãƒ«å¤‰æ›´ã‚³ãƒ¼ãƒ«ãƒãƒƒã‚¯ã®è¿½åŠ 
    timeScaleCallbacks_.push_back(std::move(cb));
}


============================================================
File Path: project/gameEngine/time/TimeManager.h
============================================================
#pragma once

#include <chrono>
#include <functional>
#include <vector>
#include <cstdint>

using TimerId = uint64_t;

class TimeManager
{
public:

	// ã‚·ãƒ³ã‚°ãƒ«ãƒˆãƒ³
	static TimeManager& Instance();

	/// <summary>
	/// ã‚¿ã‚¤ãƒ ãƒžãƒãƒ¼ã‚¸ãƒ£ãƒ¼ã®æ›´æ–°
	/// å‘¼ã³å‡ºã—ã”ã¨ã«ãƒ‡ãƒ«ã‚¿ã‚¿ã‚¤ãƒ ã‚’è¨ˆç®—ã—ã€ã‚¿ã‚¤ãƒžãƒ¼ã‚„ã‚¿ã‚¤ãƒ ã‚¹ã‚±ãƒ¼ãƒ«ã®æ›´æ–°ã‚’è¡Œã†
	/// </summary>
	void Tick();

	/// <summary>
	/// ã‚¹ãƒ ãƒ¼ã‚ºãªã‚¿ã‚¤ãƒ ã‚¹ã‚±ãƒ¼ãƒ«å¤‰æ›´ã‚’ã‚­ãƒ£ãƒ³ã‚»ãƒ«ã™ã‚‹
	/// </summary>
	void CancelSmoothTimeScale();

	/// <summary>
	/// æ™‚é–“ã®ä¸€æ™‚åœæ­¢
	/// </summary>
	void Pause();
	/// <summary>
	/// æ™‚é–“ã®å†é–‹
	/// </summary>
	void Resume();
	/// <summary>
	/// ä¸€æ™‚åœæ­¢ä¸­ã§ã‚‚æ™‚é–“ã‚’é€²ã‚ã‚‹ã‚¹ãƒ†ãƒƒãƒ—å®Ÿè¡Œ
	/// </summary>
	/// <param name="seconds">é€²ã‚ã‚‹ç§’æ•°</param>
	void Step(float seconds);

	/// <summary>
	/// ã‚¿ã‚¤ãƒžãƒ¼ã®ã‚­ãƒ£ãƒ³ã‚»ãƒ«
	/// </summary>
	/// <param name="id">ã‚­ãƒ£ãƒ³ã‚»ãƒ«ã™ã‚‹ã‚¿ã‚¤ãƒžãƒ¼ã®ID</param>
	void CancelTimer(TimerId id);

	/// <summary>
	/// ã‚¹ãƒ ãƒ¼ã‚ºãªã‚¿ã‚¤ãƒ ã‚¹ã‚±ãƒ¼ãƒ«å¤‰æ›´ã®è¨­å®š
	/// </summary>
	/// <param name="toScale">ç›®æ¨™ã®ã‚¿ã‚¤ãƒ ã‚¹ã‚±ãƒ¼ãƒ«</param>
	/// <param name="durationSeconds">å¤‰æ›´ã«ã‹ã‘ã‚‹æ™‚é–“(ç§’)</param>
	void SmoothTimeScale(float toScale, float durationSeconds);

	/// <summary>
	/// ã‚¿ã‚¤ãƒ ã‚¹ã‚±ãƒ¼ãƒ«å¤‰æ›´ã‚³ãƒ¼ãƒ«ãƒãƒƒã‚¯ã®è¿½åŠ 
	/// </summary>
	using TimeScaleCallback = std::function<void(float newScale)>;
	/// <summary>
	/// ã‚¿ã‚¤ãƒ ã‚¹ã‚±ãƒ¼ãƒ«å¤‰æ›´ã‚³ãƒ¼ãƒ«ãƒãƒƒã‚¯ã®è¿½åŠ 
	/// </summary>
	/// <param name="cb">ã‚³ãƒ¼ãƒ«ãƒãƒƒã‚¯é–¢æ•°</param>
	void AddTimeScaleCallback(TimeScaleCallback cb);

public: // ã‚»ãƒƒã‚¿ãƒ¼

	/// <summary>
	/// å›ºå®šãƒ‡ãƒ«ã‚¿ã‚¿ã‚¤ãƒ ã®è¨­å®š
	/// </summary>
	/// <param name="dt">å›ºå®šãƒ‡ãƒ«ã‚¿ã‚¿ã‚¤ãƒ </param>
	void SetFixedDeltaTime(float dt)
	{
		fixedDeltaTime_ = dt;
	}
	/// <summary>
	/// å›ºå®šãƒ‡ãƒ«ã‚¿ã‚¿ã‚¤ãƒ ãŒã‚¿ã‚¤ãƒ ã‚¹ã‚±ãƒ¼ãƒ«ã®å½±éŸ¿ã‚’å—ã‘ã‚‹ã‹ã©ã†ã‹ã®è¨­å®š
	/// </summary>
	/// <param name="useScaled">å½±éŸ¿ã‚’å—ã‘ã‚‹ãªã‚‰true</param>
	void SetFixedUsesScaled(bool useScaled)
	{
		fixedUsesScaled_ = useScaled;
	}

	/// <summary>
	/// ã‚¿ã‚¤ãƒžãƒ¼ã®è¨­å®š
	/// </summary>
	/// <param name="cb">ã‚³ãƒ¼ãƒ«ãƒãƒƒã‚¯é–¢æ•°</param>
	/// <param name="seconds">é…å»¶æ™‚é–“(ç§’)</param>
	/// <param name="useUnscaled">ã‚¿ã‚¤ãƒ ã‚¹ã‚±ãƒ¼ãƒ«ã®å½±éŸ¿ã‚’å—ã‘ãªã„ãªã‚‰true</param>
	/// <returns>ã‚¿ã‚¤ãƒžãƒ¼ID</returns>
	TimerId SetTimeout(std::function<void()> cb, float seconds, bool useUnscaled = false)
	{
		Timer t;
		t.id = nextTimerId_++;
		t.cb = std::move(cb);
		t.remaining = seconds;
		t.interval = 0.0f;
		t.useUnscaled = useUnscaled;
		timers_.push_back(std::move(t));
		return t.id;
	}
	/// <summary>
	/// ã‚¤ãƒ³ã‚¿ãƒ¼ãƒãƒ«ã‚¿ã‚¤ãƒžãƒ¼ã®è¨­å®š
	/// </summary>
	/// <param name="cb">ã‚³ãƒ¼ãƒ«ãƒãƒƒã‚¯é–¢æ•°</param>
	/// <param name="seconds">é…å»¶æ™‚é–“(ç§’)</param>
	/// <param name="useUnscaled">ã‚¿ã‚¤ãƒ ã‚¹ã‚±ãƒ¼ãƒ«ã®å½±éŸ¿ã‚’å—ã‘ãªã„ãªã‚‰true</param>
	/// <returns>ã‚¿ã‚¤ãƒžãƒ¼ID</returns>
	TimerId SetInterval(std::function<void()> cb, float seconds, bool useUnscaled = false)
	{
		Timer t;
		t.id = nextTimerId_++;
		t.cb = std::move(cb);
		t.remaining = seconds;
		t.interval = seconds;
		t.useUnscaled = useUnscaled;
		timers_.push_back(std::move(t));
		return t.id;
	}

	/// <summary>
	/// ã‚¿ã‚¤ãƒ ã‚¹ã‚±ãƒ¼ãƒ«ã®è¨­å®š
	/// </summary>
	/// <param name="timeScale">æ–°ã—ã„ã‚¿ã‚¤ãƒ ã‚¹ã‚±ãƒ¼ãƒ«</param>
	void SetTimeScale(float scale)
	{
		timeScale_ = std::max(0.0f, scale);
		smoothingEnabled_ = false;
		for (auto& cb : timeScaleCallbacks_) if (cb) cb(timeScale_);
	}
	

public: // ã‚²ãƒƒã‚¿ãƒ¼

	/// <summary>
	/// æ™‚é–“ãŒä¸€æ™‚åœæ­¢ä¸­ã‹ã©ã†ã‹
	/// </summary>
	/// <returns>åœæ­¢ä¸­ãªã‚‰true</returns>
	bool IsPaused() const
	{
		return paused_;
	}

	// ãƒ‡ãƒ«ã‚¿ã‚¿ã‚¤ãƒ å–å¾—
	float GetDeltaTime() const { return deltaTime_; }
	// ã‚¹ã‚±ãƒ¼ãƒ«ã•ã‚Œã¦ã„ãªã„ãƒ‡ãƒ«ã‚¿ã‚¿ã‚¤ãƒ å–å¾—
	float GetUnscaledDeltaTime() const { return unscaledDeltaTime_; }

	// ã‚¿ã‚¤ãƒ ã‚¹ã‚±ãƒ¼ãƒ«æ“ä½œ
	float GetTimeScale() const { return timeScale_; }

	// å›ºå®šãƒ‡ãƒ«ã‚¿ã‚¿ã‚¤ãƒ æ“ä½œ
	float GetFixedDeltaTime() const { return fixedUsesScaled_ ? fixedDeltaTime_ * timeScale_ : fixedDeltaTime_; }
	// å›ºå®šãƒ‡ãƒ«ã‚¿ã‚¿ã‚¤ãƒ ãŒã‚¹ã‚±ãƒ¼ãƒ«ã®å½±éŸ¿ã‚’å—ã‘ã‚‹ã‹ã©ã†ã‹
	bool GetFixedUsesScaled() const { return fixedUsesScaled_; }

private:

	// ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿(ã‚·ãƒ³ã‚°ãƒ«ãƒˆãƒ³)
	TimeManager();
	// ã‚¿ã‚¤ãƒ ã‚¹ã‚±ãƒ¼ãƒ«ã®æ›´æ–°
	void UpdateTimers(float scaledDT, float unscaledDT);
	
	// ãƒ‡ãƒ«ã‚¿ã‚¿ã‚¤ãƒ ã®æ›´æ–°
	struct Timer
	{
		TimerId id = 0;
		std::function<void()> cb;
		float remaining = 0.0f;
		float interval = 0.0f;
		bool useUnscaled = false;
		bool cancelled = false;
	};

	// ã‚¹ãƒ ãƒ¼ã‚ºãªã‚¿ã‚¤ãƒ ã‚¹ã‚±ãƒ¼ãƒ«å¤‰æ›´ã®çŠ¶æ…‹
	bool smoothingEnabled_ = false;
	// ã‚¹ãƒ ãƒ¼ã‚ºå¤‰æ›´ã®é–‹å§‹æ™‚ã®ã‚¿ã‚¤ãƒ ã‚¹ã‚±ãƒ¼ãƒ«
	float smoothStart_ = 1.0f;
	// ã‚¹ãƒ ãƒ¼ã‚ºå¤‰æ›´ã®ç›®æ¨™ã‚¿ã‚¤ãƒ ã‚¹ã‚±ãƒ¼ãƒ«
	float smoothTarget_ = 1.0f;
	// ã‚¹ãƒ ãƒ¼ã‚ºå¤‰æ›´ã«ã‹ã‘ã‚‹æ™‚é–“(ç§’)
	float smoothDuration_ = 0.0f;
	// ã‚¹ãƒ ãƒ¼ã‚ºå¤‰æ›´ã®çµŒéŽæ™‚é–“(ç§’)
	float smoothElapsed_ = 0.0f;

	// ç¾åœ¨ã®ã‚¿ã‚¤ãƒ ã‚¹ã‚±ãƒ¼ãƒ«
	float timeScale_ = 1.0f;
	// ãƒ‡ãƒ«ã‚¿ã‚¿ã‚¤ãƒ 
	float deltaTime_ = 1.0f / 60.0f;
	// ã‚¹ã‚±ãƒ¼ãƒ«ã•ã‚Œã¦ã„ãªã„ãƒ‡ãƒ«ã‚¿ã‚¿ã‚¤ãƒ 
	float unscaledDeltaTime_ = 1.0f / 60.0f;

	// å›ºå®šãƒ‡ãƒ«ã‚¿ã‚¿ã‚¤ãƒ 
	float fixedDeltaTime_ = 1.0f / 60.0f;
	// å›ºå®šãƒ‡ãƒ«ã‚¿ã‚¿ã‚¤ãƒ ãŒã‚¿ã‚¤ãƒ ã‚¹ã‚±ãƒ¼ãƒ«ã®å½±éŸ¿ã‚’å—ã‘ã‚‹ã‹ã©ã†ã‹
	bool fixedUsesScaled_ = true;

	// ä¸€æ™‚åœæ­¢ä¸­ã‹ã©ã†ã‹
	bool paused_ = false;
	// ã‚¹ãƒ†ãƒƒãƒ—å®Ÿè¡Œç”¨ã®æ™‚é–“è“„ç©
	float stepAccumulator_ = 0.0f;

	// å‰å›žã®æ›´æ–°æ™‚é–“
	std::chrono::steady_clock::time_point lastTime_;
	// åˆæœŸåŒ–æ¸ˆã¿ã‹ã©ã†ã‹
	bool initialized_ = false;

	// ç™»éŒ²ã•ã‚Œã¦ã„ã‚‹ã‚¿ã‚¤ãƒžãƒ¼
	std::vector<Timer> timers_;
	// æ¬¡ã«å‰²ã‚Šå½“ã¦ã‚‹ã‚¿ã‚¤ãƒžãƒ¼ID
	TimerId nextTimerId_ = 1;

	// ã‚¿ã‚¤ãƒ ã‚¹ã‚±ãƒ¼ãƒ«å¤‰æ›´ã‚³ãƒ¼ãƒ«ãƒãƒƒã‚¯ç¾¤
	std::vector<TimeScaleCallback> timeScaleCallbacks_;

};



============================================================
File Path: project/gameEngine/transition/BaseTransition.cpp
============================================================
#include "BaseTransition.h"


============================================================
File Path: project/gameEngine/transition/BaseTransition.h
============================================================
#pragma once

#include <functional>

/// <summary>
/// ã‚·ãƒ¼ãƒ³åˆ‡ã‚Šæ›¿ãˆæ™‚ã®ãƒˆãƒ©ãƒ³ã‚¸ã‚·ãƒ§ãƒ³å‡¦ç†ã‚’ç®¡ç†ã™ã‚‹ãŸã‚ã®åŸºåº•ã‚¯ãƒ©ã‚¹
/// ç¶™æ‰¿ã—ã¦ä½¿ç”¨ã™ã‚‹
/// </summary>
class BaseTransition
{
public:

	virtual ~BaseTransition() = default;

	/// <summary>
	/// ã‚·ãƒ¼ãƒ³å¤‰æ›´æ™‚ã«å‘¼ã³å‡ºã•ã‚Œã‚‹ã‚³ãƒ¼ãƒ«ãƒãƒƒã‚¯é–¢æ•°ã‚’ç™»éŒ²
	/// </summary>
	/// <param name="onSceneChange">ã‚·ãƒ¼ãƒ³ãŒå¤‰æ›´ã•ã‚ŒãŸã¨ãã«å®Ÿè¡Œã•ã‚Œã‚‹ã‚³ãƒ¼ãƒ«ãƒãƒƒã‚¯é–¢æ•°</param>
	virtual void Start(std::function<void()> onSceneChange) = 0;

	/// <summary>
	/// æ›´æ–°
	/// </summary>
	virtual void Update() = 0;

	/// <summary>
	/// æç”»
	/// </summary>
	virtual void Draw() = 0;

public: // ã‚²ãƒƒã‚¿ãƒ¼

	// ãƒˆãƒ©ãƒ³ã‚¸ã‚·ãƒ§ãƒ³ãŒçµ‚äº†ã—ãŸã‹
	virtual bool IsFinished() const = 0;

};



============================================================
File Path: project/gameEngine/transition/BlockRiseTransition.cpp
============================================================
#include "BlockRiseTransition.h"

#include <algorithm>
#include <cmath>

#ifndef M_PI
#define M_PI 3.14159265358979f
#endif

BlockRiseTransition::BlockRiseTransition(Mode mode) : mode_(mode)
{
    blocks_.reserve(rows_ * cols_);

    // ã‚°ãƒªãƒƒãƒ‰ç”Ÿæˆ
    for (uint32_t y = 0; y < rows_; ++y) 
    {
        for (uint32_t x = 0; x < cols_; ++x)
        {
            Block block;
            block.sprite = std::make_unique<Sprite>();
            block.sprite->Initialize("white.png", { 0,0 }, { 1.0f,1.0f,1.0f,1.0f }, { 0,0 });

            block.position = { x * blockSize_, y * blockSize_ };
            block.scale = { 0.0f, 0.0f };
            block.delay = ((float)x + (float)y * 0.1f + 1.0f) * blockInterval_;
            block.active = false;
            block.fallSpeed = 0.0f;
			block.verticalOffset = 0.0f;
			block.riseTimer = 0.0f;
            block.dropDelay = 0.0f;//((float)x * 1.5f + std::sin((float)y * 0.7f) * 2.0f + 1.0f) * blockInterval_; <-â†“ã“ã£ã¡ã¯æ³¢çŠ¶ã«ãƒãƒ©ãƒãƒ©è½ã¡ã¦ã„ã
            block.riseDuration = 0.12f + (rand() % 100) * 0.005f; //0.15f + 0.07f * ((float)(rand() % 100) / 100.0f);
            block.isRising = false;
            block.isDropped = false;

            block.sprite->SetSize({ blockSize_, blockSize_ + 2.0f });
            block.sprite->SetColor({ 1,1,1,1 });

            blocks_.push_back(std::move(block));
        }
    }
}

void BlockRiseTransition::Start(std::function<void()> onSceneChange)
{
    onSceneChange_ = onSceneChange;
    sceneChanged_ = false;
    if (mode_ == Mode::DropOnly) 
    {
        state_ = State::Hold;
        timer_ = 0.0f;
    }
    else
    {
        state_ = State::Fill;
        timer_ = -blockInterval_;
    }

    if (mode_ == Mode::DropOnly)
    {
        // å…¨ãƒ–ãƒ­ãƒƒã‚¯ã‚’ã™ã§ã«è¡¨ç¤ºçŠ¶æ…‹ã«ã—ã¦ã€è¦†ã‚ã‚ŒãŸçŠ¶æ…‹ã‹ã‚‰é–‹å§‹
        for (uint32_t y = 0; y < rows_; ++y)
        {
            for (uint32_t x = 0; x < cols_; ++x)
            {
                uint32_t index = y * cols_ + x;
                auto& b = blocks_[index];

                // ä½ç½®ã‚’æ­£ã—ã„ã‚°ãƒªãƒƒãƒ‰ã«è£œæ­£
                b.position = { x * blockSize_, y * blockSize_ };
                b.scale = { blockSize_, blockSize_ + 2.0f };
                b.active = true;
                b.fallSpeed = 0.0f;
            
                b.sprite->SetPosition(b.position);
                b.sprite->SetSize(b.scale);
				b.sprite->Update();
            }
        }

        // 1ãƒ•ãƒ¬ãƒ¼ãƒ ç›®ã‹ã‚‰ã™ã¹ã¦æç”»æ¸ˆã¿çŠ¶æ…‹ã«
        state_ = State::Hold;
        timer_ = 0.0f;
    }
    else
    {
        state_ = State::Fill;
    }
}

void BlockRiseTransition::Update()
{
    for (auto& b : blocks_)
    {
		b.sprite->Update();
    }

    timer_ += 1.0f / 60.0f;

    switch (state_)
    {
    case State::Fill:
       
        for (auto& b : blocks_) 
        {
            if (timer_ > b.delay)
            {
                b.active = true;
                if (b.scale.x < blockSize_)
                {
                    b.scale.x += fillSpeed_;
                    b.scale.y += fillSpeed_;

                    b.sprite->SetPosition(b.position);
                    b.sprite->SetSize(b.scale);
					b.sprite->Update();
                }
            }
        }

        // å…¨ãƒ–ãƒ­ãƒƒã‚¯ãŒæ‹¡å¤§å®Œäº†
        if (std::all_of(blocks_.begin(), blocks_.end(),
            [](auto& b) { return b.scale.x >= 90.0f; }))
        {

            state_ = State::Hold;
            timer_ = 0.0f;

            if (onSceneChange_ && !sceneChanged_) 
            {
                onSceneChange_(); // ã“ã“ã§ã‚·ãƒ¼ãƒ³åˆ‡ã‚Šæ›¿ãˆ
                sceneChanged_ = true;
            }
        }
        break;

    case State::Hold:
       

        if (timer_ > 0.3f) 
        { 
            // å°‘ã—å¾…ã£ã¦ã‹ã‚‰è½ä¸‹é–‹å§‹
            state_ = State::Drop;
        }
        break;

    case State::Drop:

        for (auto& b : blocks_)
        {
            if (!b.active) continue;

            // ä¸Šæ˜‡é–‹å§‹åˆ¤å®š
            if (!b.isRising && !b.isDropped && timer_ > b.dropDelay)
            {
                b.isRising = true;
                b.riseTimer = 0.0f;
                b.fallSpeed = 0.0f;
            }

            // ä¸Šæ˜‡ä¸­
            if (b.isRising)
            {
                float riseAmount = 32.0f;
                b.riseTimer += 1.0f / 60.0f;
                float t = b.riseTimer / b.riseDuration;
                if (t > 1.0f) t = 1.0f;
                b.verticalOffset = -riseAmount * std::sin(t * M_PI);

                if (b.riseTimer >= b.riseDuration)
                {
                    b.isRising = false;
                    b.isDropped = true;
                    b.verticalOffset = 0.0f;
                    b.fallSpeed = 1.2f + (rand() % 100) * 0.012f; // ->ã“ã£ã¡ã¯æ³¢çŠ¶ã«ãƒãƒ©ãƒãƒ©è½ã¡ã¦ã„ã 1.0f + static_cast<float>(rand() % 100) / 100.0f;
                }
            }
            // è½ä¸‹
            if (b.isDropped)
            {
                b.position.y += b.fallSpeed * 10.0f;
            }

            b.sprite->SetPosition({ b.position.x, b.position.y + b.verticalOffset });
            b.sprite->Update();
        }

		// å…¨ãƒ–ãƒ­ãƒƒã‚¯ãŒç”»é¢å¤–ã«è½ä¸‹å®Œäº†
		if (std::all_of(blocks_.begin(), blocks_.end(),
			[](auto& b) { return b.position.y > 900.0f; }))
		{
			state_ = State::Done;
		}

        break;

	case State::Done:

		break;

    default:

        break;
    }
}

void BlockRiseTransition::Draw()
{
    for (auto& b : blocks_)
    {
        if (!b.active) continue;
       
        b.sprite->Draw();
    }
}

bool BlockRiseTransition::IsFinished() const
{
    return state_ == State::Done;
}


============================================================
File Path: project/gameEngine/transition/BlockRiseTransition.h
============================================================
#pragma once

#include <functional>
#include <memory>
#include <vector>

#include "BaseTransition.h"
#include "Sprite.h"

/// <summary>
/// ãƒ–ãƒ­ãƒƒã‚¯ãŒä¸‹ã‹ã‚‰ä¸Šã«ã›ã‚Šä¸ŠãŒã‚‹ãƒˆãƒ©ãƒ³ã‚¸ã‚·ãƒ§ãƒ³
/// </summary>
class BlockRiseTransition : public BaseTransition
{
public:

    enum class Mode { Full, DropOnly};

    BlockRiseTransition(Mode mode = Mode::Full);

    /// <summary>
	/// é–‹å§‹(ã‚·ãƒ¼ãƒ³åˆ‡ã‚Šæ›¿ãˆæ™‚ã«å‘¼ã³å‡ºã™)
    /// </summary>
    /// <param name="onSceneChange">ã‚·ãƒ¼ãƒ³ãŒåˆ‡ã‚Šæ›¿ã‚ã‚‹ã‚¿ã‚¤ãƒŸãƒ³ã‚°ã§å‘¼ã³å‡ºã•ã‚Œã‚‹ã‚³ãƒ¼ãƒ«ãƒãƒƒã‚¯é–¢æ•°</param>
    void Start(std::function<void()> onSceneChange) override;
    
    /// <summary>
	/// æ›´æ–°
    /// </summary>
    void Update() override;
    
    /// <summary>
	/// æç”»
    /// </summary>
    void Draw() override;
    
public: // ã‚²ãƒƒã‚¿ãƒ¼

	// ãƒˆãƒ©ãƒ³ã‚¸ã‚·ãƒ§ãƒ³ãŒçµ‚äº†ã—ãŸã‹
    bool IsFinished() const override;

private:

    /// <summary>
	/// ãƒ–ãƒ­ãƒƒã‚¯1ã¤åˆ†ã®æƒ…å ±
    /// </summary>
    struct Block
    {
        std::unique_ptr<Sprite> sprite;
        Vector2 position;
        Vector2 scale;
        float rotation;
        float delay;
        float dropDelay;
        bool active;
        float fallSpeed;
        float verticalOffset;
        bool isRising;
        bool isDropped;
        float riseTimer;
        float riseDuration;
    };

	// ãƒ–ãƒ­ãƒƒã‚¯ç¾¤
    std::vector<Block> blocks_;

	// ãƒ–ãƒ­ãƒƒã‚¯ã®åˆæœŸåŒ–
    enum class State { Fill, Hold, Drop, Done };
    State state_ = State::Fill;

    
    float timer_ = 0.0f;
    float fillSpeed_ = 4.0f;
    float blockInterval_ = 0.04f;
    uint32_t rows_ = 8;
    uint32_t cols_ = 14;
    float blockSize_ = 1280.0f / 14.0f;

    Mode mode_;
    std::function<void()> onSceneChange_;
    bool sceneChanged_ = false;

};



============================================================
File Path: project/gameEngine/transition/FadeTransition.cpp
============================================================
#include "FadeTransition.h"

#include <algorithm>
#include <iostream>
#include "TransitionManager.h"

FadeTransition::FadeTransition(Mode mode) : mode_(mode) 
{
    fadeSprite_ = std::make_unique<Sprite>();
    fadeSprite_->Initialize("white.png", { 0, 0 }, { 1.0f, 1.0f, 1.0f, 1.0f }, { 0, 0 });
    Vector2 size = fadeSprite_->GetSize();
    size.x = 1280.0f;
    size.y = 720.0f;
	fadeSprite_->SetSize(size);

}

void FadeTransition::Start(std::function<void()> onSceneChange)
{
    onSceneChange_ = onSceneChange;

    if (mode_ == Mode::FadeInOnly)
    {
        state_ = State::FadeIn;
        alpha_ = 1.0f;
    } 
    else
    {
        state_ = State::FadeOut;
        alpha_ = 0.0f;
    }
}

void FadeTransition::Update()
{
	fadeSprite_->Update();

    switch (state_) 
    {
    case State::FadeOut:
        alpha_ += speed_;
        if (alpha_ >= 1.0f) 
        {
            alpha_ = 1.0f;
            if (onSceneChange_) onSceneChange_(); 
            state_ = State::FadeIn;
        }
        break;

    case State::FadeIn:
        alpha_ -= speed_;
        if (alpha_ <= 0.0f)
        {
            alpha_ = 0.0f;
            state_ = State::Done;
        }
        break;

    default:
        
        break;
    }
}

void FadeTransition::Draw()
{
    fadeSprite_->SetColor({ 1.0f, 1.0f, 1.0f, alpha_ });
	fadeSprite_->Draw();
}

bool FadeTransition::IsFinished() const
{
    return state_ == State::Done;
}

============================================================
File Path: project/gameEngine/transition/FadeTransition.h
============================================================
#pragma once

#include <functional>
#include <memory>
#include <Sprite.h>

#include "BaseTransition.h"

/// <summary>
/// ãƒ•ã‚§ãƒ¼ãƒ‰ãƒˆãƒ©ãƒ³ã‚¸ã‚·ãƒ§ãƒ³
/// ãƒ•ã‚§ãƒ¼ãƒ‰ã‚¤ãƒ³ã®ã¿ or ãƒ•ã‚§ãƒ¼ãƒ‰ã‚¢ã‚¦ãƒˆâ†’ã‚·ãƒ¼ãƒ³åˆ‡ã‚Šæ›¿ãˆâ†’ãƒ•ã‚§ãƒ¼ãƒ‰ã‚¤ãƒ³
/// </summary>
class FadeTransition : public BaseTransition
{
public:

	enum class Mode { FadeInOnly, Full };

	FadeTransition(Mode mode = Mode::Full);

	/// <summary>
	/// ã‚·ãƒ¼ãƒ³å¤‰æ›´æ™‚ã«å‘¼ã³å‡ºã•ã‚Œã‚‹ã‚³ãƒ¼ãƒ«ãƒãƒƒã‚¯é–¢æ•°ã‚’ç™»éŒ²
	/// </summary>
	/// <param name="onSceneChange">ã‚·ãƒ¼ãƒ³åˆ‡ã‚Šæ›¿ãˆæ™‚ã«å‘¼ã³å‡ºã•ã‚Œã‚‹ã‚³ãƒ¼ãƒ«ãƒãƒƒã‚¯é–¢æ•°</param>
	void Start(std::function<void()> onSceneChange)override;
	
	//  æ›´æ–°
	void Update() override;
	
	//  æç”»
	void Draw() override;

public: // ã‚²ãƒƒã‚¿ãƒ¼

	// ãƒˆãƒ©ãƒ³ã‚¸ã‚·ãƒ§ãƒ³ãŒçµ‚äº†ã—ãŸã‹
	bool IsFinished() const override;

private:

	std::unique_ptr<Sprite> fadeSprite_ = nullptr;

	Mode mode_;

	enum class State { FadeOut, Hold, FadeIn, Done };
	State state_ = State::FadeOut;
	float alpha_ = 0.0f;
	float speed_ = 0.02f;
	std::function<void()> onSceneChange_;

};



============================================================
File Path: project/gameEngine/transition/TransitionManager.cpp
============================================================
#include "TransitionManager.h"



void TransitionManager::Start(std::unique_ptr<BaseTransition> transition, std::function<void()> onSceneChange)
{
    transition_ = std::move(transition);
    transition_->Start(onSceneChange);
}

void TransitionManager::Update()
{
	// ãƒˆãƒ©ãƒ³ã‚¸ã‚·ãƒ§ãƒ³ä¸­ã§ãªã‘ã‚Œã°ä½•ã‚‚ã—ãªã„
    if (!transition_) return;

    transition_->Update();

    if (transition_->IsFinished())
    {
        transition_.reset();
    }
}

void TransitionManager::Draw()
{
    if (transition_)
    {
        transition_->Draw();
    }
}

bool TransitionManager::IsRunning() const
{
    return transition_ != nullptr;
}


============================================================
File Path: project/gameEngine/transition/TransitionManager.h
============================================================
#pragma once

#include "BaseTransition.h"

#include <memory>
#include <functional>

/// <summary>
/// ãƒˆãƒ©ãƒ³ã‚¸ã‚·ãƒ§ãƒ³ç®¡ç†ã‚¯ãƒ©ã‚¹
/// ä»–ã®ã‚·ãƒ¼ãƒ³ã¸åˆ‡ã‚Šæ›¿ãˆã‚‹éš›ã«ãƒˆãƒ©ãƒ³ã‚¸ã‚·ãƒ§ãƒ³ã‚’ç®¡ç†ã™ã‚‹
/// </summary>
class TransitionManager
{

public:

    /// <summary>
	/// é–‹å§‹(ã‚·ãƒ¼ãƒ³åˆ‡ã‚Šæ›¿ãˆæ™‚ã«å‘¼ã³å‡ºã™)
    /// </summary>
    /// <param name="transition">ãƒˆãƒ©ãƒ³ã‚¸ã‚·ãƒ§ãƒ³å‡¦ç†ã‚’è¡Œã†BaseTransitionæ´¾ç”Ÿã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ</param>
    /// <param name="onSceneChange">ã‚·ãƒ¼ãƒ³åˆ‡ã‚Šæ›¿ãˆæ™‚ã«å‘¼ã³å‡ºã•ã‚Œã‚‹ã‚³ãƒ¼ãƒ«ãƒãƒƒã‚¯é–¢æ•°</param>
    void Start(std::unique_ptr<BaseTransition> transition, std::function<void()> onSceneChange);

	// æ›´æ–°
    void Update();
    
	// æç”»
    void Draw();

public: // ã‚²ãƒƒã‚¿ãƒ¼

	// ãƒˆãƒ©ãƒ³ã‚¸ã‚·ãƒ§ãƒ³ä¸­ã‹
    bool IsRunning() const;

private:

	// ç¾åœ¨ã®ãƒˆãƒ©ãƒ³ã‚¸ã‚·ãƒ§ãƒ³
    std::unique_ptr<BaseTransition> transition_;

};



============================================================
File Path: project/gameEngine/utillity/Logger.cpp
============================================================
#include "Logger.h"

#include <windows.h>

namespace Logger
{
	void Logger::Log(const std::string& message)
	{
		OutputDebugStringA(message.c_str());
	}
}

============================================================
File Path: project/gameEngine/utillity/Logger.h
============================================================
#pragma once
#include <string>


// ãƒ­ã‚°å‡ºåŠ›
namespace Logger
{
	/// <summary>
	/// æŒ‡å®šã•ã‚ŒãŸãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’ãƒ­ã‚°ã«è¨˜éŒ²ã—ã¾ã™ã€‚
	/// </summary>
	/// <param name="message">è¨˜éŒ²ã™ã‚‹æ–‡å­—åˆ—ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã€‚</param>
	void Log(const std::string& message);
}

============================================================
File Path: project/gameEngine/utillity/StringUtility.cpp
============================================================
#include "StringUtility.h"


namespace StringUtility
{
    std::wstring StringUtility::ConvertString(const std::string& str)
    {
		if (str.empty()) {
			return std::wstring();
		}

		auto sizeNeeded = MultiByteToWideChar(CP_UTF8, 0, reinterpret_cast<const char*>(&str[0]), static_cast<int>(str.size()), NULL, 0);
		if (sizeNeeded == 0) {
			return std::wstring();
		}
		std::wstring result(sizeNeeded, 0);
		MultiByteToWideChar(CP_UTF8, 0, reinterpret_cast<const char*>(&str[0]), static_cast<int>(str.size()), &result[0], sizeNeeded);
		return result;
	}
	
    std::string StringUtility::ConvertString(const std::wstring& str)
    {
		if (str.empty()) {
			return std::string();
		}

		auto sizeNeeded = WideCharToMultiByte(CP_UTF8, 0, str.data(), static_cast<int>(str.size()), NULL, 0, NULL, NULL);
		if (sizeNeeded == 0) {
			return std::string();
		}
		std::string result(sizeNeeded, 0);
		WideCharToMultiByte(CP_UTF8, 0, str.data(), static_cast<int>(str.size()), result.data(), sizeNeeded, NULL, NULL);
		return result;
    }
}


============================================================
File Path: project/gameEngine/utillity/StringUtility.h
============================================================
#pragma once
#include <string>
#include <dxgidebug.h>


// æ–‡å­—ã‚³ãƒ¼ãƒ‰ãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£
namespace StringUtility
{
	/// <summary>
	/// stringã‚’ wstringã«å¤‰æ›ã™ã‚‹
	/// </summary>
	/// <param name="str">å¤‰æ›å…ƒã®UTF-8æ–‡å­—åˆ—</param>
	/// <returns></returns>
	std::wstring ConvertString(const std::string& str);

	/// <summary>
	/// wstringã‚’ stringã«å¤‰æ›ã™ã‚‹
	/// </summary>
	/// <param name="str">å¤‰æ›å…ƒã®UTF-16æ–‡å­—åˆ—</param>
	/// <returns></returns>
	std::string ConvertString(const std::wstring& str);

}

============================================================
File Path: project/main.cpp
============================================================
#include "gameEngine/baseScene/MyGame.h"

#include <memory> 

//Windowsã‚¢ãƒ—ãƒªã§ã®ã‚¨ãƒ³ãƒˆãƒªãƒ¼ãƒã‚¤ãƒ³ãƒˆ(mainé–¢æ•°)
int WINAPI WinMain(HINSTANCE, HINSTANCE, LPSTR, int)
{
	std::unique_ptr<Framework> game = std::make_unique<MyGame>();

	game->Run();

	return 0;
}
